"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@codemirror+lang-javascript@6.2.4";
exports.ids = ["vendor-chunks/@codemirror+lang-javascript@6.2.4"];
exports.modules = {

/***/ "(ssr)/../node_modules/.pnpm/@codemirror+lang-javascript@6.2.4/node_modules/@codemirror/lang-javascript/dist/index.js":
/*!**********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@codemirror+lang-javascript@6.2.4/node_modules/@codemirror/lang-javascript/dist/index.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoCloseTags: () => (/* binding */ autoCloseTags),\n/* harmony export */   completionPath: () => (/* binding */ completionPath),\n/* harmony export */   esLint: () => (/* binding */ esLint),\n/* harmony export */   javascript: () => (/* binding */ javascript),\n/* harmony export */   javascriptLanguage: () => (/* binding */ javascriptLanguage),\n/* harmony export */   jsxLanguage: () => (/* binding */ jsxLanguage),\n/* harmony export */   localCompletionSource: () => (/* binding */ localCompletionSource),\n/* harmony export */   scopeCompletionSource: () => (/* binding */ scopeCompletionSource),\n/* harmony export */   snippets: () => (/* binding */ snippets),\n/* harmony export */   tsxLanguage: () => (/* binding */ tsxLanguage),\n/* harmony export */   typescriptLanguage: () => (/* binding */ typescriptLanguage),\n/* harmony export */   typescriptSnippets: () => (/* binding */ typescriptSnippets)\n/* harmony export */ });\n/* harmony import */ var _lezer_javascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/javascript */ \"(ssr)/../node_modules/.pnpm/@lezer+javascript@1.5.1/node_modules/@lezer/javascript/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/language */ \"(ssr)/../node_modules/.pnpm/@codemirror+language@6.11.3/node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/../node_modules/.pnpm/@codemirror+state@6.5.2/node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/../node_modules/.pnpm/@codemirror+view@6.38.1/node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/autocomplete */ \"(ssr)/../node_modules/.pnpm/@codemirror+autocomplete@6.18.6/node_modules/@codemirror/autocomplete/dist/index.js\");\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/../node_modules/.pnpm/@lezer+common@1.2.3/node_modules/@lezer/common/dist/index.js\");\n\n\n\n\n\n\n\n/**\nA collection of JavaScript-related\n[snippets](https://codemirror.net/6/docs/ref/#autocomplete.snippet).\n*/\nconst snippets = [\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"function ${name}(${params}) {\\n\\t${}\\n}\", {\n        label: \"function\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\\n\\t${}\\n}\", {\n        label: \"for\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"for (let ${name} of ${collection}) {\\n\\t${}\\n}\", {\n        label: \"for\",\n        detail: \"of loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"do {\\n\\t${}\\n} while (${})\", {\n        label: \"do\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"while (${}) {\\n\\t${}\\n}\", {\n        label: \"while\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"try {\\n\\t${}\\n} catch (${error}) {\\n\\t${}\\n}\", {\n        label: \"try\",\n        detail: \"/ catch block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"if (${}) {\\n\\t${}\\n}\", {\n        label: \"if\",\n        detail: \"block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"if (${}) {\\n\\t${}\\n} else {\\n\\t${}\\n}\", {\n        label: \"if\",\n        detail: \"/ else block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"class ${name} {\\n\\tconstructor(${params}) {\\n\\t\\t${}\\n\\t}\\n}\", {\n        label: \"class\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"import {${names}} from \\\"${module}\\\"\\n${}\", {\n        label: \"import\",\n        detail: \"named\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"import ${name} from \\\"${module}\\\"\\n${}\", {\n        label: \"import\",\n        detail: \"default\",\n        type: \"keyword\"\n    })\n];\n/**\nA collection of snippet completions for TypeScript. Includes the\nJavaScript [snippets](https://codemirror.net/6/docs/ref/#lang-javascript.snippets).\n*/\nconst typescriptSnippets = /*@__PURE__*/snippets.concat([\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"interface ${name} {\\n\\t${}\\n}\", {\n        label: \"interface\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"type ${name} = ${type}\", {\n        label: \"type\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"enum ${name} {\\n\\t${}\\n}\", {\n        label: \"enum\",\n        detail: \"definition\",\n        type: \"keyword\"\n    })\n]);\n\nconst cache = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_1__.NodeWeakMap();\nconst ScopeNodes = /*@__PURE__*/new Set([\n    \"Script\", \"Block\",\n    \"FunctionExpression\", \"FunctionDeclaration\", \"ArrowFunction\", \"MethodDeclaration\",\n    \"ForStatement\"\n]);\nfunction defID(type) {\n    return (node, def) => {\n        let id = node.node.getChild(\"VariableDefinition\");\n        if (id)\n            def(id, type);\n        return true;\n    };\n}\nconst functionContext = [\"FunctionDeclaration\"];\nconst gatherCompletions = {\n    FunctionDeclaration: /*@__PURE__*/defID(\"function\"),\n    ClassDeclaration: /*@__PURE__*/defID(\"class\"),\n    ClassExpression: () => true,\n    EnumDeclaration: /*@__PURE__*/defID(\"constant\"),\n    TypeAliasDeclaration: /*@__PURE__*/defID(\"type\"),\n    NamespaceDeclaration: /*@__PURE__*/defID(\"namespace\"),\n    VariableDefinition(node, def) { if (!node.matchContext(functionContext))\n        def(node, \"variable\"); },\n    TypeDefinition(node, def) { def(node, \"type\"); },\n    __proto__: null\n};\nfunction getScope(doc, node) {\n    let cached = cache.get(node);\n    if (cached)\n        return cached;\n    let completions = [], top = true;\n    function def(node, type) {\n        let name = doc.sliceString(node.from, node.to);\n        completions.push({ label: name, type });\n    }\n    node.cursor(_lezer_common__WEBPACK_IMPORTED_MODULE_1__.IterMode.IncludeAnonymous).iterate(node => {\n        if (top) {\n            top = false;\n        }\n        else if (node.name) {\n            let gather = gatherCompletions[node.name];\n            if (gather && gather(node, def) || ScopeNodes.has(node.name))\n                return false;\n        }\n        else if (node.to - node.from > 8192) {\n            // Allow caching for bigger internal nodes\n            for (let c of getScope(doc, node.node))\n                completions.push(c);\n            return false;\n        }\n    });\n    cache.set(node, completions);\n    return completions;\n}\nconst Identifier = /^[\\w$\\xa1-\\uffff][\\w$\\d\\xa1-\\uffff]*$/;\nconst dontComplete = [\n    \"TemplateString\", \"String\", \"RegExp\",\n    \"LineComment\", \"BlockComment\",\n    \"VariableDefinition\", \"TypeDefinition\", \"Label\",\n    \"PropertyDefinition\", \"PropertyName\",\n    \"PrivatePropertyDefinition\", \"PrivatePropertyName\",\n    \"JSXText\", \"JSXAttributeValue\", \"JSXOpenTag\", \"JSXCloseTag\", \"JSXSelfClosingTag\",\n    \".\", \"?.\"\n];\n/**\nCompletion source that looks up locally defined names in\nJavaScript code.\n*/\nfunction localCompletionSource(context) {\n    let inner = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(context.state).resolveInner(context.pos, -1);\n    if (dontComplete.indexOf(inner.name) > -1)\n        return null;\n    let isWord = inner.name == \"VariableName\" ||\n        inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));\n    if (!isWord && !context.explicit)\n        return null;\n    let options = [];\n    for (let pos = inner; pos; pos = pos.parent) {\n        if (ScopeNodes.has(pos.name))\n            options = options.concat(getScope(context.state.doc, pos));\n    }\n    return {\n        options,\n        from: isWord ? inner.from : context.pos,\n        validFor: Identifier\n    };\n}\nfunction pathFor(read, member, name) {\n    var _a;\n    let path = [];\n    for (;;) {\n        let obj = member.firstChild, prop;\n        if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"VariableName\") {\n            path.push(read(obj));\n            return { path: path.reverse(), name };\n        }\n        else if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"MemberExpression\" && ((_a = (prop = obj.lastChild)) === null || _a === void 0 ? void 0 : _a.name) == \"PropertyName\") {\n            path.push(read(prop));\n            member = obj;\n        }\n        else {\n            return null;\n        }\n    }\n}\n/**\nHelper function for defining JavaScript completion sources. It\nreturns the completable name and object path for a completion\ncontext, or null if no name/property completion should happen at\nthat position. For example, when completing after `a.b.c` it will\nreturn `{path: [\"a\", \"b\"], name: \"c\"}`. When completing after `x`\nit will return `{path: [], name: \"x\"}`. When not in a property or\nname, it will return null if `context.explicit` is false, and\n`{path: [], name: \"\"}` otherwise.\n*/\nfunction completionPath(context) {\n    let read = (node) => context.state.doc.sliceString(node.from, node.to);\n    let inner = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(context.state).resolveInner(context.pos, -1);\n    if (inner.name == \"PropertyName\") {\n        return pathFor(read, inner.parent, read(inner));\n    }\n    else if ((inner.name == \".\" || inner.name == \"?.\") && inner.parent.name == \"MemberExpression\") {\n        return pathFor(read, inner.parent, \"\");\n    }\n    else if (dontComplete.indexOf(inner.name) > -1) {\n        return null;\n    }\n    else if (inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(read(inner))) {\n        return { path: [], name: read(inner) };\n    }\n    else if (inner.name == \"MemberExpression\") {\n        return pathFor(read, inner, \"\");\n    }\n    else {\n        return context.explicit ? { path: [], name: \"\" } : null;\n    }\n}\nfunction enumeratePropertyCompletions(obj, top) {\n    let options = [], seen = new Set;\n    for (let depth = 0;; depth++) {\n        for (let name of (Object.getOwnPropertyNames || Object.keys)(obj)) {\n            if (!/^[a-zA-Z_$\\xaa-\\uffdc][\\w$\\xaa-\\uffdc]*$/.test(name) || seen.has(name))\n                continue;\n            seen.add(name);\n            let value;\n            try {\n                value = obj[name];\n            }\n            catch (_) {\n                continue;\n            }\n            options.push({\n                label: name,\n                type: typeof value == \"function\" ? (/^[A-Z]/.test(name) ? \"class\" : top ? \"function\" : \"method\")\n                    : top ? \"variable\" : \"property\",\n                boost: -depth\n            });\n        }\n        let next = Object.getPrototypeOf(obj);\n        if (!next)\n            return options;\n        obj = next;\n    }\n}\n/**\nDefines a [completion source](https://codemirror.net/6/docs/ref/#autocomplete.CompletionSource) that\ncompletes from the given scope object (for example `globalThis`).\nWill enter properties of the object when completing properties on\na directly-named path.\n*/\nfunction scopeCompletionSource(scope) {\n    let cache = new Map;\n    return (context) => {\n        let path = completionPath(context);\n        if (!path)\n            return null;\n        let target = scope;\n        for (let step of path.path) {\n            target = target[step];\n            if (!target)\n                return null;\n        }\n        let options = cache.get(target);\n        if (!options)\n            cache.set(target, options = enumeratePropertyCompletions(target, !path.path.length));\n        return {\n            from: context.pos - path.name.length,\n            options,\n            validFor: Identifier\n        };\n    };\n}\n\n/**\nA language provider based on the [Lezer JavaScript\nparser](https://github.com/lezer-parser/javascript), extended with\nhighlighting and indentation information.\n*/\nconst javascriptLanguage = /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.LRLanguage.define({\n    name: \"javascript\",\n    parser: /*@__PURE__*/_lezer_javascript__WEBPACK_IMPORTED_MODULE_0__.parser.configure({\n        props: [\n            /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentNodeProp.add({\n                IfStatement: /*@__PURE__*/(0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.continuedIndent)({ except: /^\\s*({|else\\b)/ }),\n                TryStatement: /*@__PURE__*/(0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.continuedIndent)({ except: /^\\s*({|catch\\b|finally\\b)/ }),\n                LabeledStatement: _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.flatIndent,\n                SwitchBody: context => {\n                    let after = context.textAfter, closed = /^\\s*\\}/.test(after), isCase = /^\\s*(case|default)\\b/.test(after);\n                    return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;\n                },\n                Block: /*@__PURE__*/(0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.delimitedIndent)({ closing: \"}\" }),\n                ArrowFunction: cx => cx.baseIndent + cx.unit,\n                \"TemplateString BlockComment\": () => null,\n                \"Statement Property\": /*@__PURE__*/(0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.continuedIndent)({ except: /^\\s*{/ }),\n                JSXElement(context) {\n                    let closed = /^\\s*<\\//.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                JSXEscape(context) {\n                    let closed = /\\s*\\}/.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                \"JSXOpenTag JSXSelfClosingTag\"(context) {\n                    return context.column(context.node.from) + context.unit;\n                }\n            }),\n            /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.foldNodeProp.add({\n                \"Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType\": _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.foldInside,\n                BlockComment(tree) { return { from: tree.from + 2, to: tree.to - 2 }; }\n            })\n        ]\n    }),\n    languageData: {\n        closeBrackets: { brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"`\"] },\n        commentTokens: { line: \"//\", block: { open: \"/*\", close: \"*/\" } },\n        indentOnInput: /^\\s*(?:case |default:|\\{|\\}|<\\/)$/,\n        wordChars: \"$\"\n    }\n});\nconst jsxSublanguage = {\n    test: node => /^JSX/.test(node.name),\n    facet: /*@__PURE__*/(0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.defineLanguageFacet)({ commentTokens: { block: { open: \"{/*\", close: \"*/}\" } } })\n};\n/**\nA language provider for TypeScript.\n*/\nconst typescriptLanguage = /*@__PURE__*/javascriptLanguage.configure({ dialect: \"ts\" }, \"typescript\");\n/**\nLanguage provider for JSX.\n*/\nconst jsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n    dialect: \"jsx\",\n    props: [/*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]\n});\n/**\nLanguage provider for JSX + TypeScript.\n*/\nconst tsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n    dialect: \"jsx ts\",\n    props: [/*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]\n}, \"typescript\");\nlet kwCompletion = (name) => ({ label: name, type: \"keyword\" });\nconst keywords = /*@__PURE__*/\"break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield\".split(\" \").map(kwCompletion);\nconst typescriptKeywords = /*@__PURE__*/keywords.concat(/*@__PURE__*/[\"declare\", \"implements\", \"private\", \"protected\", \"public\"].map(kwCompletion));\n/**\nJavaScript support. Includes [snippet](https://codemirror.net/6/docs/ref/#lang-javascript.snippets)\nand local variable completion.\n*/\nfunction javascript(config = {}) {\n    let lang = config.jsx ? (config.typescript ? tsxLanguage : jsxLanguage)\n        : config.typescript ? typescriptLanguage : javascriptLanguage;\n    let completions = config.typescript ? typescriptSnippets.concat(typescriptKeywords) : snippets.concat(keywords);\n    return new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.LanguageSupport(lang, [\n        javascriptLanguage.data.of({\n            autocomplete: (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.ifNotIn)(dontComplete, (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.completeFromList)(completions))\n        }),\n        javascriptLanguage.data.of({\n            autocomplete: localCompletionSource\n        }),\n        config.jsx ? autoCloseTags : [],\n    ]);\n}\nfunction findOpenTag(node) {\n    for (;;) {\n        if (node.name == \"JSXOpenTag\" || node.name == \"JSXSelfClosingTag\" || node.name == \"JSXFragmentTag\")\n            return node;\n        if (node.name == \"JSXEscape\" || !node.parent)\n            return null;\n        node = node.parent;\n    }\n}\nfunction elementName(doc, tree, max = doc.length) {\n    for (let ch = tree === null || tree === void 0 ? void 0 : tree.firstChild; ch; ch = ch.nextSibling) {\n        if (ch.name == \"JSXIdentifier\" || ch.name == \"JSXBuiltin\" || ch.name == \"JSXNamespacedName\" ||\n            ch.name == \"JSXMemberExpression\")\n            return doc.sliceString(ch.from, Math.min(ch.to, max));\n    }\n    return \"\";\n}\nconst android = typeof navigator == \"object\" && /*@__PURE__*//Android\\b/.test(navigator.userAgent);\n/**\nExtension that will automatically insert JSX close tags when a `>` or\n`/` is typed.\n*/\nconst autoCloseTags = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.inputHandler.of((view, from, to, text, defaultInsert) => {\n    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly ||\n        from != to || (text != \">\" && text != \"/\") ||\n        !javascriptLanguage.isActiveAt(view.state, from, -1))\n        return false;\n    let base = defaultInsert(), { state } = base;\n    let closeTags = state.changeByRange(range => {\n        var _a;\n        let { head } = range, around = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(head - 1, -1), name;\n        if (around.name == \"JSXStartTag\")\n            around = around.parent;\n        if (state.doc.sliceString(head - 1, head) != text || around.name == \"JSXAttributeValue\" && around.to > head) ;\n        else if (text == \">\" && around.name == \"JSXFragmentTag\") {\n            return { range, changes: { from: head, insert: `</>` } };\n        }\n        else if (text == \"/\" && around.name == \"JSXStartCloseTag\") {\n            let empty = around.parent, base = empty.parent;\n            if (base && empty.from == head - 2 &&\n                ((name = elementName(state.doc, base.firstChild, head)) || ((_a = base.firstChild) === null || _a === void 0 ? void 0 : _a.name) == \"JSXFragmentTag\")) {\n                let insert = `${name}>`;\n                return { range: _codemirror_state__WEBPACK_IMPORTED_MODULE_5__.EditorSelection.cursor(head + insert.length, -1), changes: { from: head, insert } };\n            }\n        }\n        else if (text == \">\") {\n            let openTag = findOpenTag(around);\n            if (openTag && openTag.name == \"JSXOpenTag\" &&\n                !/^\\/?>|^<\\//.test(state.doc.sliceString(head, head + 2)) &&\n                (name = elementName(state.doc, openTag, head)))\n                return { range, changes: { from: head, insert: `</${name}>` } };\n        }\n        return { range };\n    });\n    if (closeTags.changes.empty)\n        return false;\n    view.dispatch([\n        base,\n        state.update(closeTags, { userEvent: \"input.complete\", scrollIntoView: true })\n    ]);\n    return true;\n});\n\n/**\nConnects an [ESLint](https://eslint.org/) linter to CodeMirror's\n[lint](https://codemirror.net/6/docs/ref/#lint) integration. `eslint` should be an instance of the\n[`Linter`](https://eslint.org/docs/developer-guide/nodejs-api#linter)\nclass, and `config` an optional ESLint configuration. The return\nvalue of this function can be passed to [`linter`](https://codemirror.net/6/docs/ref/#lint.linter)\nto create a JavaScript linting extension.\n\nNote that ESLint targets node, and is tricky to run in the\nbrowser. The\n[eslint-linter-browserify](https://github.com/UziTech/eslint-linter-browserify)\npackage may help with that (see\n[example](https://github.com/UziTech/eslint-linter-browserify/blob/master/example/script.js)).\n*/\nfunction esLint(eslint, config) {\n    if (!config) {\n        config = {\n            parserOptions: { ecmaVersion: 2019, sourceType: \"module\" },\n            env: { browser: true, node: true, es6: true, es2015: true, es2017: true, es2020: true },\n            rules: {}\n        };\n        eslint.getRules().forEach((desc, name) => {\n            var _a;\n            if ((_a = desc.meta.docs) === null || _a === void 0 ? void 0 : _a.recommended)\n                config.rules[name] = 2;\n        });\n    }\n    return (view) => {\n        let { state } = view, found = [];\n        for (let { from, to } of javascriptLanguage.findRegions(state)) {\n            let fromLine = state.doc.lineAt(from), offset = { line: fromLine.number - 1, col: from - fromLine.from, pos: from };\n            for (let d of eslint.verify(state.sliceDoc(from, to), config))\n                found.push(translateDiagnostic(d, state.doc, offset));\n        }\n        return found;\n    };\n}\nfunction mapPos(line, col, doc, offset) {\n    return doc.line(line + offset.line).from + col + (line == 1 ? offset.col - 1 : -1);\n}\nfunction translateDiagnostic(input, doc, offset) {\n    let start = mapPos(input.line, input.column, doc, offset);\n    let result = {\n        from: start,\n        to: input.endLine != null && input.endColumn != 1 ? mapPos(input.endLine, input.endColumn, doc, offset) : start,\n        message: input.message,\n        source: input.ruleId ? \"eslint:\" + input.ruleId : \"eslint\",\n        severity: input.severity == 1 ? \"warning\" : \"error\",\n    };\n    if (input.fix) {\n        let { range, text } = input.fix, from = range[0] + offset.pos - start, to = range[1] + offset.pos - start;\n        result.actions = [{\n                name: \"fix\",\n                apply(view, start) {\n                    view.dispatch({ changes: { from: start + from, to: start + to, insert: text }, scrollIntoView: true });\n                }\n            }];\n    }\n    return result;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bjb2RlbWlycm9yK2xhbmctamF2YXNjcmlwdEA2LjIuNC9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZy1qYXZhc2NyaXB0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTJDO0FBQ2tLO0FBQ3pKO0FBQ047QUFDMEM7QUFDbEM7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkVBQWlCLGFBQWEsS0FBSyxHQUFHLE9BQU8sR0FBRyxPQUFPLEdBQUc7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlCQUFpQiwyRUFBaUIsYUFBYSxPQUFPLEtBQUssRUFBRSxPQUFPLElBQUksUUFBUSxFQUFFLE1BQU0sS0FBSyxPQUFPLEdBQUc7QUFDdkc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlCQUFpQiwyRUFBaUIsYUFBYSxNQUFNLEtBQUssV0FBVyxHQUFHLE9BQU8sR0FBRztBQUNsRjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLDJFQUFpQixNQUFNLE9BQU8sSUFBSSxVQUFVO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsMkVBQWlCLFlBQVksR0FBRyxPQUFPLEdBQUc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlCQUFpQiwyRUFBaUIsT0FBTyxPQUFPLElBQUksU0FBUyxNQUFNLEdBQUcsT0FBTyxHQUFHO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsMkVBQWlCLFNBQVMsR0FBRyxPQUFPLEdBQUc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlCQUFpQiwyRUFBaUIsU0FBUyxHQUFHLE9BQU8sSUFBSSxNQUFNLE9BQU8sR0FBRztBQUN6RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLDJFQUFpQixVQUFVLE9BQU8sa0JBQWtCLE9BQU8s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Q0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBLGNBQWMsT0FBTyxrQkFBa0IsZ0VBQVU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsS0FBSztBQUNyQyx5QkFBeUIsT0FBTyw4REFBZSw4Q0FBOEM7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCLHlCQUF5QixLQUFLO0FBQ3pFO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtREFBbUQ7QUFDckY7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlDQUF5QztBQUN0RSxtQkFBbUIsZ0ZBQWdGO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLG1CQUFtQixXQUFXO0FBQzlCLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsV0FBVyxrREFBa0Qsd0JBQXdCO0FBQ3pIO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFMk0iLCJzb3VyY2VzIjpbIi9Vc2Vycy96ZWh1aXB1L215LWRhc2hib2FyZC1hcHAvbm9kZV9tb2R1bGVzLy5wbnBtL0Bjb2RlbWlycm9yK2xhbmctamF2YXNjcmlwdEA2LjIuNC9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZy1qYXZhc2NyaXB0L2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2VyIH0gZnJvbSAnQGxlemVyL2phdmFzY3JpcHQnO1xuaW1wb3J0IHsgc3ludGF4VHJlZSwgTFJMYW5ndWFnZSwgaW5kZW50Tm9kZVByb3AsIGNvbnRpbnVlZEluZGVudCwgZmxhdEluZGVudCwgZGVsaW1pdGVkSW5kZW50LCBmb2xkTm9kZVByb3AsIGZvbGRJbnNpZGUsIGRlZmluZUxhbmd1YWdlRmFjZXQsIHN1Ymxhbmd1YWdlUHJvcCwgTGFuZ3VhZ2VTdXBwb3J0IH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnO1xuaW1wb3J0IHsgRWRpdG9yU2VsZWN0aW9uIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgc25pcHBldENvbXBsZXRpb24sIGlmTm90SW4sIGNvbXBsZXRlRnJvbUxpc3QgfSBmcm9tICdAY29kZW1pcnJvci9hdXRvY29tcGxldGUnO1xuaW1wb3J0IHsgTm9kZVdlYWtNYXAsIEl0ZXJNb2RlIH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5cbi8qKlxuQSBjb2xsZWN0aW9uIG9mIEphdmFTY3JpcHQtcmVsYXRlZFxuW3NuaXBwZXRzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5zbmlwcGV0KS5cbiovXG5jb25zdCBzbmlwcGV0cyA9IFtcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJmdW5jdGlvbiAke25hbWV9KCR7cGFyYW1zfSkge1xcblxcdCR7fVxcbn1cIiwge1xuICAgICAgICBsYWJlbDogXCJmdW5jdGlvblwiLFxuICAgICAgICBkZXRhaWw6IFwiZGVmaW5pdGlvblwiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcImZvciAobGV0ICR7aW5kZXh9ID0gMDsgJHtpbmRleH0gPCAke2JvdW5kfTsgJHtpbmRleH0rKykge1xcblxcdCR7fVxcbn1cIiwge1xuICAgICAgICBsYWJlbDogXCJmb3JcIixcbiAgICAgICAgZGV0YWlsOiBcImxvb3BcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJmb3IgKGxldCAke25hbWV9IG9mICR7Y29sbGVjdGlvbn0pIHtcXG5cXHQke31cXG59XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiZm9yXCIsXG4gICAgICAgIGRldGFpbDogXCJvZiBsb29wXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiZG8ge1xcblxcdCR7fVxcbn0gd2hpbGUgKCR7fSlcIiwge1xuICAgICAgICBsYWJlbDogXCJkb1wiLFxuICAgICAgICBkZXRhaWw6IFwibG9vcFwiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcIndoaWxlICgke30pIHtcXG5cXHQke31cXG59XCIsIHtcbiAgICAgICAgbGFiZWw6IFwid2hpbGVcIixcbiAgICAgICAgZGV0YWlsOiBcImxvb3BcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJ0cnkge1xcblxcdCR7fVxcbn0gY2F0Y2ggKCR7ZXJyb3J9KSB7XFxuXFx0JHt9XFxufVwiLCB7XG4gICAgICAgIGxhYmVsOiBcInRyeVwiLFxuICAgICAgICBkZXRhaWw6IFwiLyBjYXRjaCBibG9ja1wiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcImlmICgke30pIHtcXG5cXHQke31cXG59XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiaWZcIixcbiAgICAgICAgZGV0YWlsOiBcImJsb2NrXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiaWYgKCR7fSkge1xcblxcdCR7fVxcbn0gZWxzZSB7XFxuXFx0JHt9XFxufVwiLCB7XG4gICAgICAgIGxhYmVsOiBcImlmXCIsXG4gICAgICAgIGRldGFpbDogXCIvIGVsc2UgYmxvY2tcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJjbGFzcyAke25hbWV9IHtcXG5cXHRjb25zdHJ1Y3Rvcigke3BhcmFtc30pIHtcXG5cXHRcXHQke31cXG5cXHR9XFxufVwiLCB7XG4gICAgICAgIGxhYmVsOiBcImNsYXNzXCIsXG4gICAgICAgIGRldGFpbDogXCJkZWZpbml0aW9uXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiaW1wb3J0IHske25hbWVzfX0gZnJvbSBcXFwiJHttb2R1bGV9XFxcIlxcbiR7fVwiLCB7XG4gICAgICAgIGxhYmVsOiBcImltcG9ydFwiLFxuICAgICAgICBkZXRhaWw6IFwibmFtZWRcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJpbXBvcnQgJHtuYW1lfSBmcm9tIFxcXCIke21vZHVsZX1cXFwiXFxuJHt9XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiaW1wb3J0XCIsXG4gICAgICAgIGRldGFpbDogXCJkZWZhdWx0XCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSlcbl07XG4vKipcbkEgY29sbGVjdGlvbiBvZiBzbmlwcGV0IGNvbXBsZXRpb25zIGZvciBUeXBlU2NyaXB0LiBJbmNsdWRlcyB0aGVcbkphdmFTY3JpcHQgW3NuaXBwZXRzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmctamF2YXNjcmlwdC5zbmlwcGV0cykuXG4qL1xuY29uc3QgdHlwZXNjcmlwdFNuaXBwZXRzID0gLypAX19QVVJFX18qL3NuaXBwZXRzLmNvbmNhdChbXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiaW50ZXJmYWNlICR7bmFtZX0ge1xcblxcdCR7fVxcbn1cIiwge1xuICAgICAgICBsYWJlbDogXCJpbnRlcmZhY2VcIixcbiAgICAgICAgZGV0YWlsOiBcImRlZmluaXRpb25cIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJ0eXBlICR7bmFtZX0gPSAke3R5cGV9XCIsIHtcbiAgICAgICAgbGFiZWw6IFwidHlwZVwiLFxuICAgICAgICBkZXRhaWw6IFwiZGVmaW5pdGlvblwiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcImVudW0gJHtuYW1lfSB7XFxuXFx0JHt9XFxufVwiLCB7XG4gICAgICAgIGxhYmVsOiBcImVudW1cIixcbiAgICAgICAgZGV0YWlsOiBcImRlZmluaXRpb25cIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KVxuXSk7XG5cbmNvbnN0IGNhY2hlID0gLypAX19QVVJFX18qL25ldyBOb2RlV2Vha01hcCgpO1xuY29uc3QgU2NvcGVOb2RlcyA9IC8qQF9fUFVSRV9fKi9uZXcgU2V0KFtcbiAgICBcIlNjcmlwdFwiLCBcIkJsb2NrXCIsXG4gICAgXCJGdW5jdGlvbkV4cHJlc3Npb25cIiwgXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIsIFwiQXJyb3dGdW5jdGlvblwiLCBcIk1ldGhvZERlY2xhcmF0aW9uXCIsXG4gICAgXCJGb3JTdGF0ZW1lbnRcIlxuXSk7XG5mdW5jdGlvbiBkZWZJRCh0eXBlKSB7XG4gICAgcmV0dXJuIChub2RlLCBkZWYpID0+IHtcbiAgICAgICAgbGV0IGlkID0gbm9kZS5ub2RlLmdldENoaWxkKFwiVmFyaWFibGVEZWZpbml0aW9uXCIpO1xuICAgICAgICBpZiAoaWQpXG4gICAgICAgICAgICBkZWYoaWQsIHR5cGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuY29uc3QgZnVuY3Rpb25Db250ZXh0ID0gW1wiRnVuY3Rpb25EZWNsYXJhdGlvblwiXTtcbmNvbnN0IGdhdGhlckNvbXBsZXRpb25zID0ge1xuICAgIEZ1bmN0aW9uRGVjbGFyYXRpb246IC8qQF9fUFVSRV9fKi9kZWZJRChcImZ1bmN0aW9uXCIpLFxuICAgIENsYXNzRGVjbGFyYXRpb246IC8qQF9fUFVSRV9fKi9kZWZJRChcImNsYXNzXCIpLFxuICAgIENsYXNzRXhwcmVzc2lvbjogKCkgPT4gdHJ1ZSxcbiAgICBFbnVtRGVjbGFyYXRpb246IC8qQF9fUFVSRV9fKi9kZWZJRChcImNvbnN0YW50XCIpLFxuICAgIFR5cGVBbGlhc0RlY2xhcmF0aW9uOiAvKkBfX1BVUkVfXyovZGVmSUQoXCJ0eXBlXCIpLFxuICAgIE5hbWVzcGFjZURlY2xhcmF0aW9uOiAvKkBfX1BVUkVfXyovZGVmSUQoXCJuYW1lc3BhY2VcIiksXG4gICAgVmFyaWFibGVEZWZpbml0aW9uKG5vZGUsIGRlZikgeyBpZiAoIW5vZGUubWF0Y2hDb250ZXh0KGZ1bmN0aW9uQ29udGV4dCkpXG4gICAgICAgIGRlZihub2RlLCBcInZhcmlhYmxlXCIpOyB9LFxuICAgIFR5cGVEZWZpbml0aW9uKG5vZGUsIGRlZikgeyBkZWYobm9kZSwgXCJ0eXBlXCIpOyB9LFxuICAgIF9fcHJvdG9fXzogbnVsbFxufTtcbmZ1bmN0aW9uIGdldFNjb3BlKGRvYywgbm9kZSkge1xuICAgIGxldCBjYWNoZWQgPSBjYWNoZS5nZXQobm9kZSk7XG4gICAgaWYgKGNhY2hlZClcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICBsZXQgY29tcGxldGlvbnMgPSBbXSwgdG9wID0gdHJ1ZTtcbiAgICBmdW5jdGlvbiBkZWYobm9kZSwgdHlwZSkge1xuICAgICAgICBsZXQgbmFtZSA9IGRvYy5zbGljZVN0cmluZyhub2RlLmZyb20sIG5vZGUudG8pO1xuICAgICAgICBjb21wbGV0aW9ucy5wdXNoKHsgbGFiZWw6IG5hbWUsIHR5cGUgfSk7XG4gICAgfVxuICAgIG5vZGUuY3Vyc29yKEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpLml0ZXJhdGUobm9kZSA9PiB7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgIHRvcCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubmFtZSkge1xuICAgICAgICAgICAgbGV0IGdhdGhlciA9IGdhdGhlckNvbXBsZXRpb25zW25vZGUubmFtZV07XG4gICAgICAgICAgICBpZiAoZ2F0aGVyICYmIGdhdGhlcihub2RlLCBkZWYpIHx8IFNjb3BlTm9kZXMuaGFzKG5vZGUubmFtZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUudG8gLSBub2RlLmZyb20gPiA4MTkyKSB7XG4gICAgICAgICAgICAvLyBBbGxvdyBjYWNoaW5nIGZvciBiaWdnZXIgaW50ZXJuYWwgbm9kZXNcbiAgICAgICAgICAgIGZvciAobGV0IGMgb2YgZ2V0U2NvcGUoZG9jLCBub2RlLm5vZGUpKVxuICAgICAgICAgICAgICAgIGNvbXBsZXRpb25zLnB1c2goYyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjYWNoZS5zZXQobm9kZSwgY29tcGxldGlvbnMpO1xuICAgIHJldHVybiBjb21wbGV0aW9ucztcbn1cbmNvbnN0IElkZW50aWZpZXIgPSAvXltcXHckXFx4YTEtXFx1ZmZmZl1bXFx3JFxcZFxceGExLVxcdWZmZmZdKiQvO1xuY29uc3QgZG9udENvbXBsZXRlID0gW1xuICAgIFwiVGVtcGxhdGVTdHJpbmdcIiwgXCJTdHJpbmdcIiwgXCJSZWdFeHBcIixcbiAgICBcIkxpbmVDb21tZW50XCIsIFwiQmxvY2tDb21tZW50XCIsXG4gICAgXCJWYXJpYWJsZURlZmluaXRpb25cIiwgXCJUeXBlRGVmaW5pdGlvblwiLCBcIkxhYmVsXCIsXG4gICAgXCJQcm9wZXJ0eURlZmluaXRpb25cIiwgXCJQcm9wZXJ0eU5hbWVcIixcbiAgICBcIlByaXZhdGVQcm9wZXJ0eURlZmluaXRpb25cIiwgXCJQcml2YXRlUHJvcGVydHlOYW1lXCIsXG4gICAgXCJKU1hUZXh0XCIsIFwiSlNYQXR0cmlidXRlVmFsdWVcIiwgXCJKU1hPcGVuVGFnXCIsIFwiSlNYQ2xvc2VUYWdcIiwgXCJKU1hTZWxmQ2xvc2luZ1RhZ1wiLFxuICAgIFwiLlwiLCBcIj8uXCJcbl07XG4vKipcbkNvbXBsZXRpb24gc291cmNlIHRoYXQgbG9va3MgdXAgbG9jYWxseSBkZWZpbmVkIG5hbWVzIGluXG5KYXZhU2NyaXB0IGNvZGUuXG4qL1xuZnVuY3Rpb24gbG9jYWxDb21wbGV0aW9uU291cmNlKGNvbnRleHQpIHtcbiAgICBsZXQgaW5uZXIgPSBzeW50YXhUcmVlKGNvbnRleHQuc3RhdGUpLnJlc29sdmVJbm5lcihjb250ZXh0LnBvcywgLTEpO1xuICAgIGlmIChkb250Q29tcGxldGUuaW5kZXhPZihpbm5lci5uYW1lKSA+IC0xKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgaXNXb3JkID0gaW5uZXIubmFtZSA9PSBcIlZhcmlhYmxlTmFtZVwiIHx8XG4gICAgICAgIGlubmVyLnRvIC0gaW5uZXIuZnJvbSA8IDIwICYmIElkZW50aWZpZXIudGVzdChjb250ZXh0LnN0YXRlLnNsaWNlRG9jKGlubmVyLmZyb20sIGlubmVyLnRvKSk7XG4gICAgaWYgKCFpc1dvcmQgJiYgIWNvbnRleHQuZXhwbGljaXQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBvcHRpb25zID0gW107XG4gICAgZm9yIChsZXQgcG9zID0gaW5uZXI7IHBvczsgcG9zID0gcG9zLnBhcmVudCkge1xuICAgICAgICBpZiAoU2NvcGVOb2Rlcy5oYXMocG9zLm5hbWUpKVxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMuY29uY2F0KGdldFNjb3BlKGNvbnRleHQuc3RhdGUuZG9jLCBwb3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZnJvbTogaXNXb3JkID8gaW5uZXIuZnJvbSA6IGNvbnRleHQucG9zLFxuICAgICAgICB2YWxpZEZvcjogSWRlbnRpZmllclxuICAgIH07XG59XG5mdW5jdGlvbiBwYXRoRm9yKHJlYWQsIG1lbWJlciwgbmFtZSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgcGF0aCA9IFtdO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IG9iaiA9IG1lbWJlci5maXJzdENoaWxkLCBwcm9wO1xuICAgICAgICBpZiAoKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iai5uYW1lKSA9PSBcIlZhcmlhYmxlTmFtZVwiKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2gocmVhZChvYmopKTtcbiAgICAgICAgICAgIHJldHVybiB7IHBhdGg6IHBhdGgucmV2ZXJzZSgpLCBuYW1lIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iai5uYW1lKSA9PSBcIk1lbWJlckV4cHJlc3Npb25cIiAmJiAoKF9hID0gKHByb3AgPSBvYmoubGFzdENoaWxkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpID09IFwiUHJvcGVydHlOYW1lXCIpIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChyZWFkKHByb3ApKTtcbiAgICAgICAgICAgIG1lbWJlciA9IG9iajtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG5IZWxwZXIgZnVuY3Rpb24gZm9yIGRlZmluaW5nIEphdmFTY3JpcHQgY29tcGxldGlvbiBzb3VyY2VzLiBJdFxucmV0dXJucyB0aGUgY29tcGxldGFibGUgbmFtZSBhbmQgb2JqZWN0IHBhdGggZm9yIGEgY29tcGxldGlvblxuY29udGV4dCwgb3IgbnVsbCBpZiBubyBuYW1lL3Byb3BlcnR5IGNvbXBsZXRpb24gc2hvdWxkIGhhcHBlbiBhdFxudGhhdCBwb3NpdGlvbi4gRm9yIGV4YW1wbGUsIHdoZW4gY29tcGxldGluZyBhZnRlciBgYS5iLmNgIGl0IHdpbGxcbnJldHVybiBge3BhdGg6IFtcImFcIiwgXCJiXCJdLCBuYW1lOiBcImNcIn1gLiBXaGVuIGNvbXBsZXRpbmcgYWZ0ZXIgYHhgXG5pdCB3aWxsIHJldHVybiBge3BhdGg6IFtdLCBuYW1lOiBcInhcIn1gLiBXaGVuIG5vdCBpbiBhIHByb3BlcnR5IG9yXG5uYW1lLCBpdCB3aWxsIHJldHVybiBudWxsIGlmIGBjb250ZXh0LmV4cGxpY2l0YCBpcyBmYWxzZSwgYW5kXG5ge3BhdGg6IFtdLCBuYW1lOiBcIlwifWAgb3RoZXJ3aXNlLlxuKi9cbmZ1bmN0aW9uIGNvbXBsZXRpb25QYXRoKGNvbnRleHQpIHtcbiAgICBsZXQgcmVhZCA9IChub2RlKSA9PiBjb250ZXh0LnN0YXRlLmRvYy5zbGljZVN0cmluZyhub2RlLmZyb20sIG5vZGUudG8pO1xuICAgIGxldCBpbm5lciA9IHN5bnRheFRyZWUoY29udGV4dC5zdGF0ZSkucmVzb2x2ZUlubmVyKGNvbnRleHQucG9zLCAtMSk7XG4gICAgaWYgKGlubmVyLm5hbWUgPT0gXCJQcm9wZXJ0eU5hbWVcIikge1xuICAgICAgICByZXR1cm4gcGF0aEZvcihyZWFkLCBpbm5lci5wYXJlbnQsIHJlYWQoaW5uZXIpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKGlubmVyLm5hbWUgPT0gXCIuXCIgfHwgaW5uZXIubmFtZSA9PSBcIj8uXCIpICYmIGlubmVyLnBhcmVudC5uYW1lID09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHJldHVybiBwYXRoRm9yKHJlYWQsIGlubmVyLnBhcmVudCwgXCJcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvbnRDb21wbGV0ZS5pbmRleE9mKGlubmVyLm5hbWUpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlubmVyLm5hbWUgPT0gXCJWYXJpYWJsZU5hbWVcIiB8fCBpbm5lci50byAtIGlubmVyLmZyb20gPCAyMCAmJiBJZGVudGlmaWVyLnRlc3QocmVhZChpbm5lcikpKSB7XG4gICAgICAgIHJldHVybiB7IHBhdGg6IFtdLCBuYW1lOiByZWFkKGlubmVyKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChpbm5lci5uYW1lID09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHJldHVybiBwYXRoRm9yKHJlYWQsIGlubmVyLCBcIlwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmV4cGxpY2l0ID8geyBwYXRoOiBbXSwgbmFtZTogXCJcIiB9IDogbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBlbnVtZXJhdGVQcm9wZXJ0eUNvbXBsZXRpb25zKG9iaiwgdG9wKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBbXSwgc2VlbiA9IG5ldyBTZXQ7XG4gICAgZm9yIChsZXQgZGVwdGggPSAwOzsgZGVwdGgrKykge1xuICAgICAgICBmb3IgKGxldCBuYW1lIG9mIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBPYmplY3Qua2V5cykob2JqKSkge1xuICAgICAgICAgICAgaWYgKCEvXlthLXpBLVpfJFxceGFhLVxcdWZmZGNdW1xcdyRcXHhhYS1cXHVmZmRjXSokLy50ZXN0KG5hbWUpIHx8IHNlZW4uaGFzKG5hbWUpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgc2Vlbi5hZGQobmFtZSk7XG4gICAgICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbGFiZWw6IG5hbWUsXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZW9mIHZhbHVlID09IFwiZnVuY3Rpb25cIiA/ICgvXltBLVpdLy50ZXN0KG5hbWUpID8gXCJjbGFzc1wiIDogdG9wID8gXCJmdW5jdGlvblwiIDogXCJtZXRob2RcIilcbiAgICAgICAgICAgICAgICAgICAgOiB0b3AgPyBcInZhcmlhYmxlXCIgOiBcInByb3BlcnR5XCIsXG4gICAgICAgICAgICAgICAgYm9vc3Q6IC1kZXB0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICAgICAgaWYgKCFuZXh0KVxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICAgIG9iaiA9IG5leHQ7XG4gICAgfVxufVxuLyoqXG5EZWZpbmVzIGEgW2NvbXBsZXRpb24gc291cmNlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5Db21wbGV0aW9uU291cmNlKSB0aGF0XG5jb21wbGV0ZXMgZnJvbSB0aGUgZ2l2ZW4gc2NvcGUgb2JqZWN0IChmb3IgZXhhbXBsZSBgZ2xvYmFsVGhpc2ApLlxuV2lsbCBlbnRlciBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3Qgd2hlbiBjb21wbGV0aW5nIHByb3BlcnRpZXMgb25cbmEgZGlyZWN0bHktbmFtZWQgcGF0aC5cbiovXG5mdW5jdGlvbiBzY29wZUNvbXBsZXRpb25Tb3VyY2Uoc2NvcGUpIHtcbiAgICBsZXQgY2FjaGUgPSBuZXcgTWFwO1xuICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBsZXQgcGF0aCA9IGNvbXBsZXRpb25QYXRoKGNvbnRleHQpO1xuICAgICAgICBpZiAoIXBhdGgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHRhcmdldCA9IHNjb3BlO1xuICAgICAgICBmb3IgKGxldCBzdGVwIG9mIHBhdGgucGF0aCkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0W3N0ZXBdO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9wdGlvbnMgPSBjYWNoZS5nZXQodGFyZ2V0KTtcbiAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgY2FjaGUuc2V0KHRhcmdldCwgb3B0aW9ucyA9IGVudW1lcmF0ZVByb3BlcnR5Q29tcGxldGlvbnModGFyZ2V0LCAhcGF0aC5wYXRoLmxlbmd0aCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbTogY29udGV4dC5wb3MgLSBwYXRoLm5hbWUubGVuZ3RoLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIHZhbGlkRm9yOiBJZGVudGlmaWVyXG4gICAgICAgIH07XG4gICAgfTtcbn1cblxuLyoqXG5BIGxhbmd1YWdlIHByb3ZpZGVyIGJhc2VkIG9uIHRoZSBbTGV6ZXIgSmF2YVNjcmlwdFxucGFyc2VyXShodHRwczovL2dpdGh1Yi5jb20vbGV6ZXItcGFyc2VyL2phdmFzY3JpcHQpLCBleHRlbmRlZCB3aXRoXG5oaWdobGlnaHRpbmcgYW5kIGluZGVudGF0aW9uIGluZm9ybWF0aW9uLlxuKi9cbmNvbnN0IGphdmFzY3JpcHRMYW5ndWFnZSA9IC8qQF9fUFVSRV9fKi9MUkxhbmd1YWdlLmRlZmluZSh7XG4gICAgbmFtZTogXCJqYXZhc2NyaXB0XCIsXG4gICAgcGFyc2VyOiAvKkBfX1BVUkVfXyovcGFyc2VyLmNvbmZpZ3VyZSh7XG4gICAgICAgIHByb3BzOiBbXG4gICAgICAgICAgICAvKkBfX1BVUkVfXyovaW5kZW50Tm9kZVByb3AuYWRkKHtcbiAgICAgICAgICAgICAgICBJZlN0YXRlbWVudDogLypAX19QVVJFX18qL2NvbnRpbnVlZEluZGVudCh7IGV4Y2VwdDogL15cXHMqKHt8ZWxzZVxcYikvIH0pLFxuICAgICAgICAgICAgICAgIFRyeVN0YXRlbWVudDogLypAX19QVVJFX18qL2NvbnRpbnVlZEluZGVudCh7IGV4Y2VwdDogL15cXHMqKHt8Y2F0Y2hcXGJ8ZmluYWxseVxcYikvIH0pLFxuICAgICAgICAgICAgICAgIExhYmVsZWRTdGF0ZW1lbnQ6IGZsYXRJbmRlbnQsXG4gICAgICAgICAgICAgICAgU3dpdGNoQm9keTogY29udGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhZnRlciA9IGNvbnRleHQudGV4dEFmdGVyLCBjbG9zZWQgPSAvXlxccypcXH0vLnRlc3QoYWZ0ZXIpLCBpc0Nhc2UgPSAvXlxccyooY2FzZXxkZWZhdWx0KVxcYi8udGVzdChhZnRlcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmJhc2VJbmRlbnQgKyAoY2xvc2VkID8gMCA6IGlzQ2FzZSA/IDEgOiAyKSAqIGNvbnRleHQudW5pdDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIEJsb2NrOiAvKkBfX1BVUkVfXyovZGVsaW1pdGVkSW5kZW50KHsgY2xvc2luZzogXCJ9XCIgfSksXG4gICAgICAgICAgICAgICAgQXJyb3dGdW5jdGlvbjogY3ggPT4gY3guYmFzZUluZGVudCArIGN4LnVuaXQsXG4gICAgICAgICAgICAgICAgXCJUZW1wbGF0ZVN0cmluZyBCbG9ja0NvbW1lbnRcIjogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgICAgICBcIlN0YXRlbWVudCBQcm9wZXJ0eVwiOiAvKkBfX1BVUkVfXyovY29udGludWVkSW5kZW50KHsgZXhjZXB0OiAvXlxccyp7LyB9KSxcbiAgICAgICAgICAgICAgICBKU1hFbGVtZW50KGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNsb3NlZCA9IC9eXFxzKjxcXC8vLnRlc3QoY29udGV4dC50ZXh0QWZ0ZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5saW5lSW5kZW50KGNvbnRleHQubm9kZS5mcm9tKSArIChjbG9zZWQgPyAwIDogY29udGV4dC51bml0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIEpTWEVzY2FwZShjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjbG9zZWQgPSAvXFxzKlxcfS8udGVzdChjb250ZXh0LnRleHRBZnRlcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmxpbmVJbmRlbnQoY29udGV4dC5ub2RlLmZyb20pICsgKGNsb3NlZCA/IDAgOiBjb250ZXh0LnVuaXQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJKU1hPcGVuVGFnIEpTWFNlbGZDbG9zaW5nVGFnXCIoY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5jb2x1bW4oY29udGV4dC5ub2RlLmZyb20pICsgY29udGV4dC51bml0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgLypAX19QVVJFX18qL2ZvbGROb2RlUHJvcC5hZGQoe1xuICAgICAgICAgICAgICAgIFwiQmxvY2sgQ2xhc3NCb2R5IFN3aXRjaEJvZHkgRW51bUJvZHkgT2JqZWN0RXhwcmVzc2lvbiBBcnJheUV4cHJlc3Npb24gT2JqZWN0VHlwZVwiOiBmb2xkSW5zaWRlLFxuICAgICAgICAgICAgICAgIEJsb2NrQ29tbWVudCh0cmVlKSB7IHJldHVybiB7IGZyb206IHRyZWUuZnJvbSArIDIsIHRvOiB0cmVlLnRvIC0gMiB9OyB9XG4gICAgICAgICAgICB9KVxuICAgICAgICBdXG4gICAgfSksXG4gICAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgICAgIGNsb3NlQnJhY2tldHM6IHsgYnJhY2tldHM6IFtcIihcIiwgXCJbXCIsIFwie1wiLCBcIidcIiwgJ1wiJywgXCJgXCJdIH0sXG4gICAgICAgIGNvbW1lbnRUb2tlbnM6IHsgbGluZTogXCIvL1wiLCBibG9jazogeyBvcGVuOiBcIi8qXCIsIGNsb3NlOiBcIiovXCIgfSB9LFxuICAgICAgICBpbmRlbnRPbklucHV0OiAvXlxccyooPzpjYXNlIHxkZWZhdWx0OnxcXHt8XFx9fDxcXC8pJC8sXG4gICAgICAgIHdvcmRDaGFyczogXCIkXCJcbiAgICB9XG59KTtcbmNvbnN0IGpzeFN1Ymxhbmd1YWdlID0ge1xuICAgIHRlc3Q6IG5vZGUgPT4gL15KU1gvLnRlc3Qobm9kZS5uYW1lKSxcbiAgICBmYWNldDogLypAX19QVVJFX18qL2RlZmluZUxhbmd1YWdlRmFjZXQoeyBjb21tZW50VG9rZW5zOiB7IGJsb2NrOiB7IG9wZW46IFwiey8qXCIsIGNsb3NlOiBcIiovfVwiIH0gfSB9KVxufTtcbi8qKlxuQSBsYW5ndWFnZSBwcm92aWRlciBmb3IgVHlwZVNjcmlwdC5cbiovXG5jb25zdCB0eXBlc2NyaXB0TGFuZ3VhZ2UgPSAvKkBfX1BVUkVfXyovamF2YXNjcmlwdExhbmd1YWdlLmNvbmZpZ3VyZSh7IGRpYWxlY3Q6IFwidHNcIiB9LCBcInR5cGVzY3JpcHRcIik7XG4vKipcbkxhbmd1YWdlIHByb3ZpZGVyIGZvciBKU1guXG4qL1xuY29uc3QganN4TGFuZ3VhZ2UgPSAvKkBfX1BVUkVfXyovamF2YXNjcmlwdExhbmd1YWdlLmNvbmZpZ3VyZSh7XG4gICAgZGlhbGVjdDogXCJqc3hcIixcbiAgICBwcm9wczogWy8qQF9fUFVSRV9fKi9zdWJsYW5ndWFnZVByb3AuYWRkKG4gPT4gbi5pc1RvcCA/IFtqc3hTdWJsYW5ndWFnZV0gOiB1bmRlZmluZWQpXVxufSk7XG4vKipcbkxhbmd1YWdlIHByb3ZpZGVyIGZvciBKU1ggKyBUeXBlU2NyaXB0LlxuKi9cbmNvbnN0IHRzeExhbmd1YWdlID0gLypAX19QVVJFX18qL2phdmFzY3JpcHRMYW5ndWFnZS5jb25maWd1cmUoe1xuICAgIGRpYWxlY3Q6IFwianN4IHRzXCIsXG4gICAgcHJvcHM6IFsvKkBfX1BVUkVfXyovc3VibGFuZ3VhZ2VQcm9wLmFkZChuID0+IG4uaXNUb3AgPyBbanN4U3VibGFuZ3VhZ2VdIDogdW5kZWZpbmVkKV1cbn0sIFwidHlwZXNjcmlwdFwiKTtcbmxldCBrd0NvbXBsZXRpb24gPSAobmFtZSkgPT4gKHsgbGFiZWw6IG5hbWUsIHR5cGU6IFwia2V5d29yZFwiIH0pO1xuY29uc3Qga2V5d29yZHMgPSAvKkBfX1BVUkVfXyovXCJicmVhayBjYXNlIGNvbnN0IGNvbnRpbnVlIGRlZmF1bHQgZGVsZXRlIGV4cG9ydCBleHRlbmRzIGZhbHNlIGZpbmFsbHkgaW4gaW5zdGFuY2VvZiBsZXQgbmV3IHJldHVybiBzdGF0aWMgc3VwZXIgc3dpdGNoIHRoaXMgdGhyb3cgdHJ1ZSB0eXBlb2YgdmFyIHlpZWxkXCIuc3BsaXQoXCIgXCIpLm1hcChrd0NvbXBsZXRpb24pO1xuY29uc3QgdHlwZXNjcmlwdEtleXdvcmRzID0gLypAX19QVVJFX18qL2tleXdvcmRzLmNvbmNhdCgvKkBfX1BVUkVfXyovW1wiZGVjbGFyZVwiLCBcImltcGxlbWVudHNcIiwgXCJwcml2YXRlXCIsIFwicHJvdGVjdGVkXCIsIFwicHVibGljXCJdLm1hcChrd0NvbXBsZXRpb24pKTtcbi8qKlxuSmF2YVNjcmlwdCBzdXBwb3J0LiBJbmNsdWRlcyBbc25pcHBldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5nLWphdmFzY3JpcHQuc25pcHBldHMpXG5hbmQgbG9jYWwgdmFyaWFibGUgY29tcGxldGlvbi5cbiovXG5mdW5jdGlvbiBqYXZhc2NyaXB0KGNvbmZpZyA9IHt9KSB7XG4gICAgbGV0IGxhbmcgPSBjb25maWcuanN4ID8gKGNvbmZpZy50eXBlc2NyaXB0ID8gdHN4TGFuZ3VhZ2UgOiBqc3hMYW5ndWFnZSlcbiAgICAgICAgOiBjb25maWcudHlwZXNjcmlwdCA/IHR5cGVzY3JpcHRMYW5ndWFnZSA6IGphdmFzY3JpcHRMYW5ndWFnZTtcbiAgICBsZXQgY29tcGxldGlvbnMgPSBjb25maWcudHlwZXNjcmlwdCA/IHR5cGVzY3JpcHRTbmlwcGV0cy5jb25jYXQodHlwZXNjcmlwdEtleXdvcmRzKSA6IHNuaXBwZXRzLmNvbmNhdChrZXl3b3Jkcyk7XG4gICAgcmV0dXJuIG5ldyBMYW5ndWFnZVN1cHBvcnQobGFuZywgW1xuICAgICAgICBqYXZhc2NyaXB0TGFuZ3VhZ2UuZGF0YS5vZih7XG4gICAgICAgICAgICBhdXRvY29tcGxldGU6IGlmTm90SW4oZG9udENvbXBsZXRlLCBjb21wbGV0ZUZyb21MaXN0KGNvbXBsZXRpb25zKSlcbiAgICAgICAgfSksXG4gICAgICAgIGphdmFzY3JpcHRMYW5ndWFnZS5kYXRhLm9mKHtcbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZTogbG9jYWxDb21wbGV0aW9uU291cmNlXG4gICAgICAgIH0pLFxuICAgICAgICBjb25maWcuanN4ID8gYXV0b0Nsb3NlVGFncyA6IFtdLFxuICAgIF0pO1xufVxuZnVuY3Rpb24gZmluZE9wZW5UYWcobm9kZSkge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUubmFtZSA9PSBcIkpTWE9wZW5UYWdcIiB8fCBub2RlLm5hbWUgPT0gXCJKU1hTZWxmQ2xvc2luZ1RhZ1wiIHx8IG5vZGUubmFtZSA9PSBcIkpTWEZyYWdtZW50VGFnXCIpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgaWYgKG5vZGUubmFtZSA9PSBcIkpTWEVzY2FwZVwiIHx8ICFub2RlLnBhcmVudClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgfVxufVxuZnVuY3Rpb24gZWxlbWVudE5hbWUoZG9jLCB0cmVlLCBtYXggPSBkb2MubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgY2ggPSB0cmVlID09PSBudWxsIHx8IHRyZWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyZWUuZmlyc3RDaGlsZDsgY2g7IGNoID0gY2gubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgaWYgKGNoLm5hbWUgPT0gXCJKU1hJZGVudGlmaWVyXCIgfHwgY2gubmFtZSA9PSBcIkpTWEJ1aWx0aW5cIiB8fCBjaC5uYW1lID09IFwiSlNYTmFtZXNwYWNlZE5hbWVcIiB8fFxuICAgICAgICAgICAgY2gubmFtZSA9PSBcIkpTWE1lbWJlckV4cHJlc3Npb25cIilcbiAgICAgICAgICAgIHJldHVybiBkb2Muc2xpY2VTdHJpbmcoY2guZnJvbSwgTWF0aC5taW4oY2gudG8sIG1heCkpO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbn1cbmNvbnN0IGFuZHJvaWQgPSB0eXBlb2YgbmF2aWdhdG9yID09IFwib2JqZWN0XCIgJiYgLypAX19QVVJFX18qLy9BbmRyb2lkXFxiLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuLyoqXG5FeHRlbnNpb24gdGhhdCB3aWxsIGF1dG9tYXRpY2FsbHkgaW5zZXJ0IEpTWCBjbG9zZSB0YWdzIHdoZW4gYSBgPmAgb3JcbmAvYCBpcyB0eXBlZC5cbiovXG5jb25zdCBhdXRvQ2xvc2VUYWdzID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuaW5wdXRIYW5kbGVyLm9mKCh2aWV3LCBmcm9tLCB0bywgdGV4dCwgZGVmYXVsdEluc2VydCkgPT4ge1xuICAgIGlmICgoYW5kcm9pZCA/IHZpZXcuY29tcG9zaW5nIDogdmlldy5jb21wb3NpdGlvblN0YXJ0ZWQpIHx8IHZpZXcuc3RhdGUucmVhZE9ubHkgfHxcbiAgICAgICAgZnJvbSAhPSB0byB8fCAodGV4dCAhPSBcIj5cIiAmJiB0ZXh0ICE9IFwiL1wiKSB8fFxuICAgICAgICAhamF2YXNjcmlwdExhbmd1YWdlLmlzQWN0aXZlQXQodmlldy5zdGF0ZSwgZnJvbSwgLTEpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGJhc2UgPSBkZWZhdWx0SW5zZXJ0KCksIHsgc3RhdGUgfSA9IGJhc2U7XG4gICAgbGV0IGNsb3NlVGFncyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCB7IGhlYWQgfSA9IHJhbmdlLCBhcm91bmQgPSBzeW50YXhUcmVlKHN0YXRlKS5yZXNvbHZlSW5uZXIoaGVhZCAtIDEsIC0xKSwgbmFtZTtcbiAgICAgICAgaWYgKGFyb3VuZC5uYW1lID09IFwiSlNYU3RhcnRUYWdcIilcbiAgICAgICAgICAgIGFyb3VuZCA9IGFyb3VuZC5wYXJlbnQ7XG4gICAgICAgIGlmIChzdGF0ZS5kb2Muc2xpY2VTdHJpbmcoaGVhZCAtIDEsIGhlYWQpICE9IHRleHQgfHwgYXJvdW5kLm5hbWUgPT0gXCJKU1hBdHRyaWJ1dGVWYWx1ZVwiICYmIGFyb3VuZC50byA+IGhlYWQpIDtcbiAgICAgICAgZWxzZSBpZiAodGV4dCA9PSBcIj5cIiAmJiBhcm91bmQubmFtZSA9PSBcIkpTWEZyYWdtZW50VGFnXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHJhbmdlLCBjaGFuZ2VzOiB7IGZyb206IGhlYWQsIGluc2VydDogYDwvPmAgfSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRleHQgPT0gXCIvXCIgJiYgYXJvdW5kLm5hbWUgPT0gXCJKU1hTdGFydENsb3NlVGFnXCIpIHtcbiAgICAgICAgICAgIGxldCBlbXB0eSA9IGFyb3VuZC5wYXJlbnQsIGJhc2UgPSBlbXB0eS5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoYmFzZSAmJiBlbXB0eS5mcm9tID09IGhlYWQgLSAyICYmXG4gICAgICAgICAgICAgICAgKChuYW1lID0gZWxlbWVudE5hbWUoc3RhdGUuZG9jLCBiYXNlLmZpcnN0Q2hpbGQsIGhlYWQpKSB8fCAoKF9hID0gYmFzZS5maXJzdENoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgPT0gXCJKU1hGcmFnbWVudFRhZ1wiKSkge1xuICAgICAgICAgICAgICAgIGxldCBpbnNlcnQgPSBgJHtuYW1lfT5gO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGhlYWQgKyBpbnNlcnQubGVuZ3RoLCAtMSksIGNoYW5nZXM6IHsgZnJvbTogaGVhZCwgaW5zZXJ0IH0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXh0ID09IFwiPlwiKSB7XG4gICAgICAgICAgICBsZXQgb3BlblRhZyA9IGZpbmRPcGVuVGFnKGFyb3VuZCk7XG4gICAgICAgICAgICBpZiAob3BlblRhZyAmJiBvcGVuVGFnLm5hbWUgPT0gXCJKU1hPcGVuVGFnXCIgJiZcbiAgICAgICAgICAgICAgICAhL15cXC8/PnxePFxcLy8udGVzdChzdGF0ZS5kb2Muc2xpY2VTdHJpbmcoaGVhZCwgaGVhZCArIDIpKSAmJlxuICAgICAgICAgICAgICAgIChuYW1lID0gZWxlbWVudE5hbWUoc3RhdGUuZG9jLCBvcGVuVGFnLCBoZWFkKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UsIGNoYW5nZXM6IHsgZnJvbTogaGVhZCwgaW5zZXJ0OiBgPC8ke25hbWV9PmAgfSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgfSk7XG4gICAgaWYgKGNsb3NlVGFncy5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaChbXG4gICAgICAgIGJhc2UsXG4gICAgICAgIHN0YXRlLnVwZGF0ZShjbG9zZVRhZ3MsIHsgdXNlckV2ZW50OiBcImlucHV0LmNvbXBsZXRlXCIsIHNjcm9sbEludG9WaWV3OiB0cnVlIH0pXG4gICAgXSk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcblxuLyoqXG5Db25uZWN0cyBhbiBbRVNMaW50XShodHRwczovL2VzbGludC5vcmcvKSBsaW50ZXIgdG8gQ29kZU1pcnJvcidzXG5bbGludF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsaW50KSBpbnRlZ3JhdGlvbi4gYGVzbGludGAgc2hvdWxkIGJlIGFuIGluc3RhbmNlIG9mIHRoZVxuW2BMaW50ZXJgXShodHRwczovL2VzbGludC5vcmcvZG9jcy9kZXZlbG9wZXItZ3VpZGUvbm9kZWpzLWFwaSNsaW50ZXIpXG5jbGFzcywgYW5kIGBjb25maWdgIGFuIG9wdGlvbmFsIEVTTGludCBjb25maWd1cmF0aW9uLiBUaGUgcmV0dXJuXG52YWx1ZSBvZiB0aGlzIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgdG8gW2BsaW50ZXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xpbnQubGludGVyKVxudG8gY3JlYXRlIGEgSmF2YVNjcmlwdCBsaW50aW5nIGV4dGVuc2lvbi5cblxuTm90ZSB0aGF0IEVTTGludCB0YXJnZXRzIG5vZGUsIGFuZCBpcyB0cmlja3kgdG8gcnVuIGluIHRoZVxuYnJvd3Nlci4gVGhlXG5bZXNsaW50LWxpbnRlci1icm93c2VyaWZ5XShodHRwczovL2dpdGh1Yi5jb20vVXppVGVjaC9lc2xpbnQtbGludGVyLWJyb3dzZXJpZnkpXG5wYWNrYWdlIG1heSBoZWxwIHdpdGggdGhhdCAoc2VlXG5bZXhhbXBsZV0oaHR0cHM6Ly9naXRodWIuY29tL1V6aVRlY2gvZXNsaW50LWxpbnRlci1icm93c2VyaWZ5L2Jsb2IvbWFzdGVyL2V4YW1wbGUvc2NyaXB0LmpzKSkuXG4qL1xuZnVuY3Rpb24gZXNMaW50KGVzbGludCwgY29uZmlnKSB7XG4gICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgcGFyc2VyT3B0aW9uczogeyBlY21hVmVyc2lvbjogMjAxOSwgc291cmNlVHlwZTogXCJtb2R1bGVcIiB9LFxuICAgICAgICAgICAgZW52OiB7IGJyb3dzZXI6IHRydWUsIG5vZGU6IHRydWUsIGVzNjogdHJ1ZSwgZXMyMDE1OiB0cnVlLCBlczIwMTc6IHRydWUsIGVzMjAyMDogdHJ1ZSB9LFxuICAgICAgICAgICAgcnVsZXM6IHt9XG4gICAgICAgIH07XG4gICAgICAgIGVzbGludC5nZXRSdWxlcygpLmZvckVhY2goKGRlc2MsIG5hbWUpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICgoX2EgPSBkZXNjLm1ldGEuZG9jcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlY29tbWVuZGVkKVxuICAgICAgICAgICAgICAgIGNvbmZpZy5ydWxlc1tuYW1lXSA9IDI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKHZpZXcpID0+IHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIGZvdW5kID0gW107XG4gICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiBqYXZhc2NyaXB0TGFuZ3VhZ2UuZmluZFJlZ2lvbnMoc3RhdGUpKSB7XG4gICAgICAgICAgICBsZXQgZnJvbUxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KGZyb20pLCBvZmZzZXQgPSB7IGxpbmU6IGZyb21MaW5lLm51bWJlciAtIDEsIGNvbDogZnJvbSAtIGZyb21MaW5lLmZyb20sIHBvczogZnJvbSB9O1xuICAgICAgICAgICAgZm9yIChsZXQgZCBvZiBlc2xpbnQudmVyaWZ5KHN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKSwgY29uZmlnKSlcbiAgICAgICAgICAgICAgICBmb3VuZC5wdXNoKHRyYW5zbGF0ZURpYWdub3N0aWMoZCwgc3RhdGUuZG9jLCBvZmZzZXQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1hcFBvcyhsaW5lLCBjb2wsIGRvYywgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGRvYy5saW5lKGxpbmUgKyBvZmZzZXQubGluZSkuZnJvbSArIGNvbCArIChsaW5lID09IDEgPyBvZmZzZXQuY29sIC0gMSA6IC0xKTtcbn1cbmZ1bmN0aW9uIHRyYW5zbGF0ZURpYWdub3N0aWMoaW5wdXQsIGRvYywgb2Zmc2V0KSB7XG4gICAgbGV0IHN0YXJ0ID0gbWFwUG9zKGlucHV0LmxpbmUsIGlucHV0LmNvbHVtbiwgZG9jLCBvZmZzZXQpO1xuICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIGZyb206IHN0YXJ0LFxuICAgICAgICB0bzogaW5wdXQuZW5kTGluZSAhPSBudWxsICYmIGlucHV0LmVuZENvbHVtbiAhPSAxID8gbWFwUG9zKGlucHV0LmVuZExpbmUsIGlucHV0LmVuZENvbHVtbiwgZG9jLCBvZmZzZXQpIDogc3RhcnQsXG4gICAgICAgIG1lc3NhZ2U6IGlucHV0Lm1lc3NhZ2UsXG4gICAgICAgIHNvdXJjZTogaW5wdXQucnVsZUlkID8gXCJlc2xpbnQ6XCIgKyBpbnB1dC5ydWxlSWQgOiBcImVzbGludFwiLFxuICAgICAgICBzZXZlcml0eTogaW5wdXQuc2V2ZXJpdHkgPT0gMSA/IFwid2FybmluZ1wiIDogXCJlcnJvclwiLFxuICAgIH07XG4gICAgaWYgKGlucHV0LmZpeCkge1xuICAgICAgICBsZXQgeyByYW5nZSwgdGV4dCB9ID0gaW5wdXQuZml4LCBmcm9tID0gcmFuZ2VbMF0gKyBvZmZzZXQucG9zIC0gc3RhcnQsIHRvID0gcmFuZ2VbMV0gKyBvZmZzZXQucG9zIC0gc3RhcnQ7XG4gICAgICAgIHJlc3VsdC5hY3Rpb25zID0gW3tcbiAgICAgICAgICAgICAgICBuYW1lOiBcImZpeFwiLFxuICAgICAgICAgICAgICAgIGFwcGx5KHZpZXcsIHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBjaGFuZ2VzOiB7IGZyb206IHN0YXJ0ICsgZnJvbSwgdG86IHN0YXJ0ICsgdG8sIGluc2VydDogdGV4dCB9LCBzY3JvbGxJbnRvVmlldzogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgYXV0b0Nsb3NlVGFncywgY29tcGxldGlvblBhdGgsIGVzTGludCwgamF2YXNjcmlwdCwgamF2YXNjcmlwdExhbmd1YWdlLCBqc3hMYW5ndWFnZSwgbG9jYWxDb21wbGV0aW9uU291cmNlLCBzY29wZUNvbXBsZXRpb25Tb3VyY2UsIHNuaXBwZXRzLCB0c3hMYW5ndWFnZSwgdHlwZXNjcmlwdExhbmd1YWdlLCB0eXBlc2NyaXB0U25pcHBldHMgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/@codemirror+lang-javascript@6.2.4/node_modules/@codemirror/lang-javascript/dist/index.js\n");

/***/ })

};
;