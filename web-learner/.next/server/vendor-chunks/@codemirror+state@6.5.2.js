"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@codemirror+state@6.5.2";
exports.ids = ["vendor-chunks/@codemirror+state@6.5.2"];
exports.modules = {

/***/ "(ssr)/../node_modules/.pnpm/@codemirror+state@6.5.2/node_modules/@codemirror/state/dist/index.js":
/*!**************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@codemirror+state@6.5.2/node_modules/@codemirror/state/dist/index.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Annotation: () => (/* binding */ Annotation),\n/* harmony export */   AnnotationType: () => (/* binding */ AnnotationType),\n/* harmony export */   ChangeDesc: () => (/* binding */ ChangeDesc),\n/* harmony export */   ChangeSet: () => (/* binding */ ChangeSet),\n/* harmony export */   CharCategory: () => (/* binding */ CharCategory),\n/* harmony export */   Compartment: () => (/* binding */ Compartment),\n/* harmony export */   EditorSelection: () => (/* binding */ EditorSelection),\n/* harmony export */   EditorState: () => (/* binding */ EditorState),\n/* harmony export */   Facet: () => (/* binding */ Facet),\n/* harmony export */   Line: () => (/* binding */ Line),\n/* harmony export */   MapMode: () => (/* binding */ MapMode),\n/* harmony export */   Prec: () => (/* binding */ Prec),\n/* harmony export */   Range: () => (/* binding */ Range),\n/* harmony export */   RangeSet: () => (/* binding */ RangeSet),\n/* harmony export */   RangeSetBuilder: () => (/* binding */ RangeSetBuilder),\n/* harmony export */   RangeValue: () => (/* binding */ RangeValue),\n/* harmony export */   SelectionRange: () => (/* binding */ SelectionRange),\n/* harmony export */   StateEffect: () => (/* binding */ StateEffect),\n/* harmony export */   StateEffectType: () => (/* binding */ StateEffectType),\n/* harmony export */   StateField: () => (/* binding */ StateField),\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   codePointAt: () => (/* binding */ codePointAt),\n/* harmony export */   codePointSize: () => (/* binding */ codePointSize),\n/* harmony export */   combineConfig: () => (/* binding */ combineConfig),\n/* harmony export */   countColumn: () => (/* binding */ countColumn),\n/* harmony export */   findClusterBreak: () => (/* binding */ findClusterBreak),\n/* harmony export */   findColumn: () => (/* binding */ findColumn),\n/* harmony export */   fromCodePoint: () => (/* binding */ fromCodePoint)\n/* harmony export */ });\n/* harmony import */ var _marijn_find_cluster_break__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @marijn/find-cluster-break */ \"(ssr)/../node_modules/.pnpm/@marijn+find-cluster-break@1.0.2/node_modules/@marijn/find-cluster-break/src/index.js\");\n\n\n/**\nThe data structure for documents. @nonabstract\n*/\nclass Text {\n    /**\n    Get the line description around the given position.\n    */\n    lineAt(pos) {\n        if (pos < 0 || pos > this.length)\n            throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);\n        return this.lineInner(pos, false, 1, 0);\n    }\n    /**\n    Get the description for the given (1-based) line number.\n    */\n    line(n) {\n        if (n < 1 || n > this.lines)\n            throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);\n        return this.lineInner(n, true, 1, 0);\n    }\n    /**\n    Replace a range of the text with the given content.\n    */\n    replace(from, to, text) {\n        [from, to] = clip(this, from, to);\n        let parts = [];\n        this.decompose(0, from, parts, 2 /* Open.To */);\n        if (text.length)\n            text.decompose(0, text.length, parts, 1 /* Open.From */ | 2 /* Open.To */);\n        this.decompose(to, this.length, parts, 1 /* Open.From */);\n        return TextNode.from(parts, this.length - (to - from) + text.length);\n    }\n    /**\n    Append another document to this one.\n    */\n    append(other) {\n        return this.replace(this.length, this.length, other);\n    }\n    /**\n    Retrieve the text between the given points.\n    */\n    slice(from, to = this.length) {\n        [from, to] = clip(this, from, to);\n        let parts = [];\n        this.decompose(from, to, parts, 0);\n        return TextNode.from(parts, to - from);\n    }\n    /**\n    Test whether this text is equal to another instance.\n    */\n    eq(other) {\n        if (other == this)\n            return true;\n        if (other.length != this.length || other.lines != this.lines)\n            return false;\n        let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);\n        let a = new RawTextCursor(this), b = new RawTextCursor(other);\n        for (let skip = start, pos = start;;) {\n            a.next(skip);\n            b.next(skip);\n            skip = 0;\n            if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)\n                return false;\n            pos += a.value.length;\n            if (a.done || pos >= end)\n                return true;\n        }\n    }\n    /**\n    Iterate over the text. When `dir` is `-1`, iteration happens\n    from end to start. This will return lines and the breaks between\n    them as separate strings.\n    */\n    iter(dir = 1) { return new RawTextCursor(this, dir); }\n    /**\n    Iterate over a range of the text. When `from` > `to`, the\n    iterator will run in reverse.\n    */\n    iterRange(from, to = this.length) { return new PartialTextCursor(this, from, to); }\n    /**\n    Return a cursor that iterates over the given range of lines,\n    _without_ returning the line breaks between, and yielding empty\n    strings for empty lines.\n    \n    When `from` and `to` are given, they should be 1-based line numbers.\n    */\n    iterLines(from, to) {\n        let inner;\n        if (from == null) {\n            inner = this.iter();\n        }\n        else {\n            if (to == null)\n                to = this.lines + 1;\n            let start = this.line(from).from;\n            inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));\n        }\n        return new LineCursor(inner);\n    }\n    /**\n    Return the document as a string, using newline characters to\n    separate lines.\n    */\n    toString() { return this.sliceString(0); }\n    /**\n    Convert the document to an array of lines (which can be\n    deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).\n    */\n    toJSON() {\n        let lines = [];\n        this.flatten(lines);\n        return lines;\n    }\n    /**\n    @internal\n    */\n    constructor() { }\n    /**\n    Create a `Text` instance for the given array of lines.\n    */\n    static of(text) {\n        if (text.length == 0)\n            throw new RangeError(\"A document must have at least one line\");\n        if (text.length == 1 && !text[0])\n            return Text.empty;\n        return text.length <= 32 /* Tree.Branch */ ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));\n    }\n}\n// Leaves store an array of line strings. There are always line breaks\n// between these strings. Leaves are limited in size and have to be\n// contained in TextNode instances for bigger documents.\nclass TextLeaf extends Text {\n    constructor(text, length = textLength(text)) {\n        super();\n        this.text = text;\n        this.length = length;\n    }\n    get lines() { return this.text.length; }\n    get children() { return null; }\n    lineInner(target, isLine, line, offset) {\n        for (let i = 0;; i++) {\n            let string = this.text[i], end = offset + string.length;\n            if ((isLine ? line : end) >= target)\n                return new Line(offset, end, line, string);\n            offset = end + 1;\n            line++;\n        }\n    }\n    decompose(from, to, target, open) {\n        let text = from <= 0 && to >= this.length ? this\n            : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));\n        if (open & 1 /* Open.From */) {\n            let prev = target.pop();\n            let joined = appendText(text.text, prev.text.slice(), 0, text.length);\n            if (joined.length <= 32 /* Tree.Branch */) {\n                target.push(new TextLeaf(joined, prev.length + text.length));\n            }\n            else {\n                let mid = joined.length >> 1;\n                target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));\n            }\n        }\n        else {\n            target.push(text);\n        }\n    }\n    replace(from, to, text) {\n        if (!(text instanceof TextLeaf))\n            return super.replace(from, to, text);\n        [from, to] = clip(this, from, to);\n        let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);\n        let newLen = this.length + text.length - (to - from);\n        if (lines.length <= 32 /* Tree.Branch */)\n            return new TextLeaf(lines, newLen);\n        return TextNode.from(TextLeaf.split(lines, []), newLen);\n    }\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\n        [from, to] = clip(this, from, to);\n        let result = \"\";\n        for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {\n            let line = this.text[i], end = pos + line.length;\n            if (pos > from && i)\n                result += lineSep;\n            if (from < end && to > pos)\n                result += line.slice(Math.max(0, from - pos), to - pos);\n            pos = end + 1;\n        }\n        return result;\n    }\n    flatten(target) {\n        for (let line of this.text)\n            target.push(line);\n    }\n    scanIdentical() { return 0; }\n    static split(text, target) {\n        let part = [], len = -1;\n        for (let line of text) {\n            part.push(line);\n            len += line.length + 1;\n            if (part.length == 32 /* Tree.Branch */) {\n                target.push(new TextLeaf(part, len));\n                part = [];\n                len = -1;\n            }\n        }\n        if (len > -1)\n            target.push(new TextLeaf(part, len));\n        return target;\n    }\n}\n// Nodes provide the tree structure of the `Text` type. They store a\n// number of other nodes or leaves, taking care to balance themselves\n// on changes. There are implied line breaks _between_ the children of\n// a node (but not before the first or after the last child).\nclass TextNode extends Text {\n    constructor(children, length) {\n        super();\n        this.children = children;\n        this.length = length;\n        this.lines = 0;\n        for (let child of children)\n            this.lines += child.lines;\n    }\n    lineInner(target, isLine, line, offset) {\n        for (let i = 0;; i++) {\n            let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;\n            if ((isLine ? endLine : end) >= target)\n                return child.lineInner(target, isLine, line, offset);\n            offset = end + 1;\n            line = endLine + 1;\n        }\n    }\n    decompose(from, to, target, open) {\n        for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (from <= end && to >= pos) {\n                let childOpen = open & ((pos <= from ? 1 /* Open.From */ : 0) | (end >= to ? 2 /* Open.To */ : 0));\n                if (pos >= from && end <= to && !childOpen)\n                    target.push(child);\n                else\n                    child.decompose(from - pos, to - pos, target, childOpen);\n            }\n            pos = end + 1;\n        }\n    }\n    replace(from, to, text) {\n        [from, to] = clip(this, from, to);\n        if (text.lines < this.lines)\n            for (let i = 0, pos = 0; i < this.children.length; i++) {\n                let child = this.children[i], end = pos + child.length;\n                // Fast path: if the change only affects one child and the\n                // child's size remains in the acceptable range, only update\n                // that child\n                if (from >= pos && to <= end) {\n                    let updated = child.replace(from - pos, to - pos, text);\n                    let totalLines = this.lines - child.lines + updated.lines;\n                    if (updated.lines < (totalLines >> (5 /* Tree.BranchShift */ - 1)) &&\n                        updated.lines > (totalLines >> (5 /* Tree.BranchShift */ + 1))) {\n                        let copy = this.children.slice();\n                        copy[i] = updated;\n                        return new TextNode(copy, this.length - (to - from) + text.length);\n                    }\n                    return super.replace(pos, end, updated);\n                }\n                pos = end + 1;\n            }\n        return super.replace(from, to, text);\n    }\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\n        [from, to] = clip(this, from, to);\n        let result = \"\";\n        for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (pos > from && i)\n                result += lineSep;\n            if (from < end && to > pos)\n                result += child.sliceString(from - pos, to - pos, lineSep);\n            pos = end + 1;\n        }\n        return result;\n    }\n    flatten(target) {\n        for (let child of this.children)\n            child.flatten(target);\n    }\n    scanIdentical(other, dir) {\n        if (!(other instanceof TextNode))\n            return 0;\n        let length = 0;\n        let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length]\n            : [this.children.length - 1, other.children.length - 1, -1, -1];\n        for (;; iA += dir, iB += dir) {\n            if (iA == eA || iB == eB)\n                return length;\n            let chA = this.children[iA], chB = other.children[iB];\n            if (chA != chB)\n                return length + chA.scanIdentical(chB, dir);\n            length += chA.length + 1;\n        }\n    }\n    static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {\n        let lines = 0;\n        for (let ch of children)\n            lines += ch.lines;\n        if (lines < 32 /* Tree.Branch */) {\n            let flat = [];\n            for (let ch of children)\n                ch.flatten(flat);\n            return new TextLeaf(flat, length);\n        }\n        let chunk = Math.max(32 /* Tree.Branch */, lines >> 5 /* Tree.BranchShift */), maxChunk = chunk << 1, minChunk = chunk >> 1;\n        let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];\n        function add(child) {\n            let last;\n            if (child.lines > maxChunk && child instanceof TextNode) {\n                for (let node of child.children)\n                    add(node);\n            }\n            else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {\n                flush();\n                chunked.push(child);\n            }\n            else if (child instanceof TextLeaf && currentLines &&\n                (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf &&\n                child.lines + last.lines <= 32 /* Tree.Branch */) {\n                currentLines += child.lines;\n                currentLen += child.length + 1;\n                currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);\n            }\n            else {\n                if (currentLines + child.lines > chunk)\n                    flush();\n                currentLines += child.lines;\n                currentLen += child.length + 1;\n                currentChunk.push(child);\n            }\n        }\n        function flush() {\n            if (currentLines == 0)\n                return;\n            chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));\n            currentLen = -1;\n            currentLines = currentChunk.length = 0;\n        }\n        for (let child of children)\n            add(child);\n        flush();\n        return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);\n    }\n}\nText.empty = /*@__PURE__*/new TextLeaf([\"\"], 0);\nfunction textLength(text) {\n    let length = -1;\n    for (let line of text)\n        length += line.length + 1;\n    return length;\n}\nfunction appendText(text, target, from = 0, to = 1e9) {\n    for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {\n        let line = text[i], end = pos + line.length;\n        if (end >= from) {\n            if (end > to)\n                line = line.slice(0, to - pos);\n            if (pos < from)\n                line = line.slice(from - pos);\n            if (first) {\n                target[target.length - 1] += line;\n                first = false;\n            }\n            else\n                target.push(line);\n        }\n        pos = end + 1;\n    }\n    return target;\n}\nfunction sliceText(text, from, to) {\n    return appendText(text, [\"\"], from, to);\n}\nclass RawTextCursor {\n    constructor(text, dir = 1) {\n        this.dir = dir;\n        this.done = false;\n        this.lineBreak = false;\n        this.value = \"\";\n        this.nodes = [text];\n        this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];\n    }\n    nextInner(skip, dir) {\n        this.done = this.lineBreak = false;\n        for (;;) {\n            let last = this.nodes.length - 1;\n            let top = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;\n            let size = top instanceof TextLeaf ? top.text.length : top.children.length;\n            if (offset == (dir > 0 ? size : 0)) {\n                if (last == 0) {\n                    this.done = true;\n                    this.value = \"\";\n                    return this;\n                }\n                if (dir > 0)\n                    this.offsets[last - 1]++;\n                this.nodes.pop();\n                this.offsets.pop();\n            }\n            else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {\n                this.offsets[last] += dir;\n                if (skip == 0) {\n                    this.lineBreak = true;\n                    this.value = \"\\n\";\n                    return this;\n                }\n                skip--;\n            }\n            else if (top instanceof TextLeaf) {\n                // Move to the next string\n                let next = top.text[offset + (dir < 0 ? -1 : 0)];\n                this.offsets[last] += dir;\n                if (next.length > Math.max(0, skip)) {\n                    this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);\n                    return this;\n                }\n                skip -= next.length;\n            }\n            else {\n                let next = top.children[offset + (dir < 0 ? -1 : 0)];\n                if (skip > next.length) {\n                    skip -= next.length;\n                    this.offsets[last] += dir;\n                }\n                else {\n                    if (dir < 0)\n                        this.offsets[last]--;\n                    this.nodes.push(next);\n                    this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);\n                }\n            }\n        }\n    }\n    next(skip = 0) {\n        if (skip < 0) {\n            this.nextInner(-skip, (-this.dir));\n            skip = this.value.length;\n        }\n        return this.nextInner(skip, this.dir);\n    }\n}\nclass PartialTextCursor {\n    constructor(text, start, end) {\n        this.value = \"\";\n        this.done = false;\n        this.cursor = new RawTextCursor(text, start > end ? -1 : 1);\n        this.pos = start > end ? text.length : 0;\n        this.from = Math.min(start, end);\n        this.to = Math.max(start, end);\n    }\n    nextInner(skip, dir) {\n        if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {\n            this.value = \"\";\n            this.done = true;\n            return this;\n        }\n        skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);\n        let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;\n        if (skip > limit)\n            skip = limit;\n        limit -= skip;\n        let { value } = this.cursor.next(skip);\n        this.pos += (value.length + skip) * dir;\n        this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);\n        this.done = !this.value;\n        return this;\n    }\n    next(skip = 0) {\n        if (skip < 0)\n            skip = Math.max(skip, this.from - this.pos);\n        else if (skip > 0)\n            skip = Math.min(skip, this.to - this.pos);\n        return this.nextInner(skip, this.cursor.dir);\n    }\n    get lineBreak() { return this.cursor.lineBreak && this.value != \"\"; }\n}\nclass LineCursor {\n    constructor(inner) {\n        this.inner = inner;\n        this.afterBreak = true;\n        this.value = \"\";\n        this.done = false;\n    }\n    next(skip = 0) {\n        let { done, lineBreak, value } = this.inner.next(skip);\n        if (done && this.afterBreak) {\n            this.value = \"\";\n            this.afterBreak = false;\n        }\n        else if (done) {\n            this.done = true;\n            this.value = \"\";\n        }\n        else if (lineBreak) {\n            if (this.afterBreak) {\n                this.value = \"\";\n            }\n            else {\n                this.afterBreak = true;\n                this.next();\n            }\n        }\n        else {\n            this.value = value;\n            this.afterBreak = false;\n        }\n        return this;\n    }\n    get lineBreak() { return false; }\n}\nif (typeof Symbol != \"undefined\") {\n    Text.prototype[Symbol.iterator] = function () { return this.iter(); };\n    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] =\n        LineCursor.prototype[Symbol.iterator] = function () { return this; };\n}\n/**\nThis type describes a line in the document. It is created\non-demand when lines are [queried](https://codemirror.net/6/docs/ref/#state.Text.lineAt).\n*/\nclass Line {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The position of the start of the line.\n    */\n    from, \n    /**\n    The position at the end of the line (_before_ the line break,\n    or at the end of document for the last line).\n    */\n    to, \n    /**\n    This line's line number (1-based).\n    */\n    number, \n    /**\n    The line's content.\n    */\n    text) {\n        this.from = from;\n        this.to = to;\n        this.number = number;\n        this.text = text;\n    }\n    /**\n    The length of the line (not including any line break after it).\n    */\n    get length() { return this.to - this.from; }\n}\nfunction clip(text, from, to) {\n    from = Math.max(0, Math.min(text.length, from));\n    return [from, Math.max(from, Math.min(text.length, to))];\n}\n\n/**\nReturns a next grapheme cluster break _after_ (not equal to)\n`pos`, if `forward` is true, or before otherwise. Returns `pos`\nitself if no further cluster break is available in the string.\nMoves across surrogate pairs, extending characters (when\n`includeExtending` is true), characters joined with zero-width\njoiners, and flag emoji.\n*/\nfunction findClusterBreak(str, pos, forward = true, includeExtending = true) {\n    return (0,_marijn_find_cluster_break__WEBPACK_IMPORTED_MODULE_0__.findClusterBreak)(str, pos, forward, includeExtending);\n}\nfunction surrogateLow(ch) { return ch >= 0xDC00 && ch < 0xE000; }\nfunction surrogateHigh(ch) { return ch >= 0xD800 && ch < 0xDC00; }\n/**\nFind the code point at the given position in a string (like the\n[`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)\nstring method).\n*/\nfunction codePointAt(str, pos) {\n    let code0 = str.charCodeAt(pos);\n    if (!surrogateHigh(code0) || pos + 1 == str.length)\n        return code0;\n    let code1 = str.charCodeAt(pos + 1);\n    if (!surrogateLow(code1))\n        return code0;\n    return ((code0 - 0xd800) << 10) + (code1 - 0xdc00) + 0x10000;\n}\n/**\nGiven a Unicode codepoint, return the JavaScript string that\nrespresents it (like\n[`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).\n*/\nfunction fromCodePoint(code) {\n    if (code <= 0xffff)\n        return String.fromCharCode(code);\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);\n}\n/**\nThe amount of positions a character takes up in a JavaScript string.\n*/\nfunction codePointSize(code) { return code < 0x10000 ? 1 : 2; }\n\nconst DefaultSplit = /\\r\\n?|\\n/;\n/**\nDistinguishes different ways in which positions can be mapped.\n*/\nvar MapMode = /*@__PURE__*/(function (MapMode) {\n    /**\n    Map a position to a valid new position, even when its context\n    was deleted.\n    */\n    MapMode[MapMode[\"Simple\"] = 0] = \"Simple\";\n    /**\n    Return null if deletion happens across the position.\n    */\n    MapMode[MapMode[\"TrackDel\"] = 1] = \"TrackDel\";\n    /**\n    Return null if the character _before_ the position is deleted.\n    */\n    MapMode[MapMode[\"TrackBefore\"] = 2] = \"TrackBefore\";\n    /**\n    Return null if the character _after_ the position is deleted.\n    */\n    MapMode[MapMode[\"TrackAfter\"] = 3] = \"TrackAfter\";\nreturn MapMode})(MapMode || (MapMode = {}));\n/**\nA change description is a variant of [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet)\nthat doesn't store the inserted text. As such, it can't be\napplied, but is cheaper to store and manipulate.\n*/\nclass ChangeDesc {\n    // Sections are encoded as pairs of integers. The first is the\n    // length in the current document, and the second is -1 for\n    // unaffected sections, and the length of the replacement content\n    // otherwise. So an insertion would be (0, n>0), a deletion (n>0,\n    // 0), and a replacement two positive numbers.\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    sections) {\n        this.sections = sections;\n    }\n    /**\n    The length of the document before the change.\n    */\n    get length() {\n        let result = 0;\n        for (let i = 0; i < this.sections.length; i += 2)\n            result += this.sections[i];\n        return result;\n    }\n    /**\n    The length of the document after the change.\n    */\n    get newLength() {\n        let result = 0;\n        for (let i = 0; i < this.sections.length; i += 2) {\n            let ins = this.sections[i + 1];\n            result += ins < 0 ? this.sections[i] : ins;\n        }\n        return result;\n    }\n    /**\n    False when there are actual changes in this set.\n    */\n    get empty() { return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0; }\n    /**\n    Iterate over the unchanged parts left by these changes. `posA`\n    provides the position of the range in the old document, `posB`\n    the new position in the changed document.\n    */\n    iterGaps(f) {\n        for (let i = 0, posA = 0, posB = 0; i < this.sections.length;) {\n            let len = this.sections[i++], ins = this.sections[i++];\n            if (ins < 0) {\n                f(posA, posB, len);\n                posB += len;\n            }\n            else {\n                posB += ins;\n            }\n            posA += len;\n        }\n    }\n    /**\n    Iterate over the ranges changed by these changes. (See\n    [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a\n    variant that also provides you with the inserted text.)\n    `fromA`/`toA` provides the extent of the change in the starting\n    document, `fromB`/`toB` the extent of the replacement in the\n    changed document.\n    \n    When `individual` is true, adjacent changes (which are kept\n    separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are\n    reported separately.\n    */\n    iterChangedRanges(f, individual = false) {\n        iterChanges(this, f, individual);\n    }\n    /**\n    Get a description of the inverted form of these changes.\n    */\n    get invertedDesc() {\n        let sections = [];\n        for (let i = 0; i < this.sections.length;) {\n            let len = this.sections[i++], ins = this.sections[i++];\n            if (ins < 0)\n                sections.push(len, ins);\n            else\n                sections.push(ins, len);\n        }\n        return new ChangeDesc(sections);\n    }\n    /**\n    Compute the combined effect of applying another set of changes\n    after this one. The length of the document after this set should\n    match the length before `other`.\n    */\n    composeDesc(other) { return this.empty ? other : other.empty ? this : composeSets(this, other); }\n    /**\n    Map this description, which should start with the same document\n    as `other`, over another set of changes, so that it can be\n    applied after it. When `before` is true, map as if the changes\n    in `this` happened before the ones in `other`.\n    */\n    mapDesc(other, before = false) { return other.empty ? this : mapSet(this, other, before); }\n    mapPos(pos, assoc = -1, mode = MapMode.Simple) {\n        let posA = 0, posB = 0;\n        for (let i = 0; i < this.sections.length;) {\n            let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;\n            if (ins < 0) {\n                if (endA > pos)\n                    return posB + (pos - posA);\n                posB += len;\n            }\n            else {\n                if (mode != MapMode.Simple && endA >= pos &&\n                    (mode == MapMode.TrackDel && posA < pos && endA > pos ||\n                        mode == MapMode.TrackBefore && posA < pos ||\n                        mode == MapMode.TrackAfter && endA > pos))\n                    return null;\n                if (endA > pos || endA == pos && assoc < 0 && !len)\n                    return pos == posA || assoc < 0 ? posB : posB + ins;\n                posB += ins;\n            }\n            posA = endA;\n        }\n        if (pos > posA)\n            throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);\n        return posB;\n    }\n    /**\n    Check whether these changes touch a given range. When one of the\n    changes entirely covers the range, the string `\"cover\"` is\n    returned.\n    */\n    touchesRange(from, to = from) {\n        for (let i = 0, pos = 0; i < this.sections.length && pos <= to;) {\n            let len = this.sections[i++], ins = this.sections[i++], end = pos + len;\n            if (ins >= 0 && pos <= to && end >= from)\n                return pos < from && end > to ? \"cover\" : true;\n            pos = end;\n        }\n        return false;\n    }\n    /**\n    @internal\n    */\n    toString() {\n        let result = \"\";\n        for (let i = 0; i < this.sections.length;) {\n            let len = this.sections[i++], ins = this.sections[i++];\n            result += (result ? \" \" : \"\") + len + (ins >= 0 ? \":\" + ins : \"\");\n        }\n        return result;\n    }\n    /**\n    Serialize this change desc to a JSON-representable value.\n    */\n    toJSON() { return this.sections; }\n    /**\n    Create a change desc from its JSON representation (as produced\n    by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).\n    */\n    static fromJSON(json) {\n        if (!Array.isArray(json) || json.length % 2 || json.some(a => typeof a != \"number\"))\n            throw new RangeError(\"Invalid JSON representation of ChangeDesc\");\n        return new ChangeDesc(json);\n    }\n    /**\n    @internal\n    */\n    static create(sections) { return new ChangeDesc(sections); }\n}\n/**\nA change set represents a group of modifications to a document. It\nstores the document length, and can only be applied to documents\nwith exactly that length.\n*/\nclass ChangeSet extends ChangeDesc {\n    constructor(sections, \n    /**\n    @internal\n    */\n    inserted) {\n        super(sections);\n        this.inserted = inserted;\n    }\n    /**\n    Apply the changes to a document, returning the modified\n    document.\n    */\n    apply(doc) {\n        if (this.length != doc.length)\n            throw new RangeError(\"Applying change set to a document with the wrong length\");\n        iterChanges(this, (fromA, toA, fromB, _toB, text) => doc = doc.replace(fromB, fromB + (toA - fromA), text), false);\n        return doc;\n    }\n    mapDesc(other, before = false) { return mapSet(this, other, before, true); }\n    /**\n    Given the document as it existed _before_ the changes, return a\n    change set that represents the inverse of this set, which could\n    be used to go from the document created by the changes back to\n    the document as it existed before the changes.\n    */\n    invert(doc) {\n        let sections = this.sections.slice(), inserted = [];\n        for (let i = 0, pos = 0; i < sections.length; i += 2) {\n            let len = sections[i], ins = sections[i + 1];\n            if (ins >= 0) {\n                sections[i] = ins;\n                sections[i + 1] = len;\n                let index = i >> 1;\n                while (inserted.length < index)\n                    inserted.push(Text.empty);\n                inserted.push(len ? doc.slice(pos, pos + len) : Text.empty);\n            }\n            pos += len;\n        }\n        return new ChangeSet(sections, inserted);\n    }\n    /**\n    Combine two subsequent change sets into a single set. `other`\n    must start in the document produced by `this`. If `this` goes\n    `docA` → `docB` and `other` represents `docB` → `docC`, the\n    returned value will represent the change `docA` → `docC`.\n    */\n    compose(other) { return this.empty ? other : other.empty ? this : composeSets(this, other, true); }\n    /**\n    Given another change set starting in the same document, maps this\n    change set over the other, producing a new change set that can be\n    applied to the document produced by applying `other`. When\n    `before` is `true`, order changes as if `this` comes before\n    `other`, otherwise (the default) treat `other` as coming first.\n    \n    Given two changes `A` and `B`, `A.compose(B.map(A))` and\n    `B.compose(A.map(B, true))` will produce the same document. This\n    provides a basic form of [operational\n    transformation](https://en.wikipedia.org/wiki/Operational_transformation),\n    and can be used for collaborative editing.\n    */\n    map(other, before = false) { return other.empty ? this : mapSet(this, other, before, true); }\n    /**\n    Iterate over the changed ranges in the document, calling `f` for\n    each, with the range in the original document (`fromA`-`toA`)\n    and the range that replaces it in the new document\n    (`fromB`-`toB`).\n    \n    When `individual` is true, adjacent changes are reported\n    separately.\n    */\n    iterChanges(f, individual = false) {\n        iterChanges(this, f, individual);\n    }\n    /**\n    Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change\n    set.\n    */\n    get desc() { return ChangeDesc.create(this.sections); }\n    /**\n    @internal\n    */\n    filter(ranges) {\n        let resultSections = [], resultInserted = [], filteredSections = [];\n        let iter = new SectionIter(this);\n        done: for (let i = 0, pos = 0;;) {\n            let next = i == ranges.length ? 1e9 : ranges[i++];\n            while (pos < next || pos == next && iter.len == 0) {\n                if (iter.done)\n                    break done;\n                let len = Math.min(iter.len, next - pos);\n                addSection(filteredSections, len, -1);\n                let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;\n                addSection(resultSections, len, ins);\n                if (ins > 0)\n                    addInsert(resultInserted, resultSections, iter.text);\n                iter.forward(len);\n                pos += len;\n            }\n            let end = ranges[i++];\n            while (pos < end) {\n                if (iter.done)\n                    break done;\n                let len = Math.min(iter.len, end - pos);\n                addSection(resultSections, len, -1);\n                addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);\n                iter.forward(len);\n                pos += len;\n            }\n        }\n        return { changes: new ChangeSet(resultSections, resultInserted),\n            filtered: ChangeDesc.create(filteredSections) };\n    }\n    /**\n    Serialize this change set to a JSON-representable value.\n    */\n    toJSON() {\n        let parts = [];\n        for (let i = 0; i < this.sections.length; i += 2) {\n            let len = this.sections[i], ins = this.sections[i + 1];\n            if (ins < 0)\n                parts.push(len);\n            else if (ins == 0)\n                parts.push([len]);\n            else\n                parts.push([len].concat(this.inserted[i >> 1].toJSON()));\n        }\n        return parts;\n    }\n    /**\n    Create a change set for the given changes, for a document of the\n    given length, using `lineSep` as line separator.\n    */\n    static of(changes, length, lineSep) {\n        let sections = [], inserted = [], pos = 0;\n        let total = null;\n        function flush(force = false) {\n            if (!force && !sections.length)\n                return;\n            if (pos < length)\n                addSection(sections, length - pos, -1);\n            let set = new ChangeSet(sections, inserted);\n            total = total ? total.compose(set.map(total)) : set;\n            sections = [];\n            inserted = [];\n            pos = 0;\n        }\n        function process(spec) {\n            if (Array.isArray(spec)) {\n                for (let sub of spec)\n                    process(sub);\n            }\n            else if (spec instanceof ChangeSet) {\n                if (spec.length != length)\n                    throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);\n                flush();\n                total = total ? total.compose(spec.map(total)) : spec;\n            }\n            else {\n                let { from, to = from, insert } = spec;\n                if (from > to || from < 0 || to > length)\n                    throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);\n                let insText = !insert ? Text.empty : typeof insert == \"string\" ? Text.of(insert.split(lineSep || DefaultSplit)) : insert;\n                let insLen = insText.length;\n                if (from == to && insLen == 0)\n                    return;\n                if (from < pos)\n                    flush();\n                if (from > pos)\n                    addSection(sections, from - pos, -1);\n                addSection(sections, to - from, insLen);\n                addInsert(inserted, sections, insText);\n                pos = to;\n            }\n        }\n        process(changes);\n        flush(!total);\n        return total;\n    }\n    /**\n    Create an empty changeset of the given length.\n    */\n    static empty(length) {\n        return new ChangeSet(length ? [length, -1] : [], []);\n    }\n    /**\n    Create a changeset from its JSON representation (as produced by\n    [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).\n    */\n    static fromJSON(json) {\n        if (!Array.isArray(json))\n            throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n        let sections = [], inserted = [];\n        for (let i = 0; i < json.length; i++) {\n            let part = json[i];\n            if (typeof part == \"number\") {\n                sections.push(part, -1);\n            }\n            else if (!Array.isArray(part) || typeof part[0] != \"number\" || part.some((e, i) => i && typeof e != \"string\")) {\n                throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n            }\n            else if (part.length == 1) {\n                sections.push(part[0], 0);\n            }\n            else {\n                while (inserted.length < i)\n                    inserted.push(Text.empty);\n                inserted[i] = Text.of(part.slice(1));\n                sections.push(part[0], inserted[i].length);\n            }\n        }\n        return new ChangeSet(sections, inserted);\n    }\n    /**\n    @internal\n    */\n    static createSet(sections, inserted) {\n        return new ChangeSet(sections, inserted);\n    }\n}\nfunction addSection(sections, len, ins, forceJoin = false) {\n    if (len == 0 && ins <= 0)\n        return;\n    let last = sections.length - 2;\n    if (last >= 0 && ins <= 0 && ins == sections[last + 1])\n        sections[last] += len;\n    else if (last >= 0 && len == 0 && sections[last] == 0)\n        sections[last + 1] += ins;\n    else if (forceJoin) {\n        sections[last] += len;\n        sections[last + 1] += ins;\n    }\n    else\n        sections.push(len, ins);\n}\nfunction addInsert(values, sections, value) {\n    if (value.length == 0)\n        return;\n    let index = (sections.length - 2) >> 1;\n    if (index < values.length) {\n        values[values.length - 1] = values[values.length - 1].append(value);\n    }\n    else {\n        while (values.length < index)\n            values.push(Text.empty);\n        values.push(value);\n    }\n}\nfunction iterChanges(desc, f, individual) {\n    let inserted = desc.inserted;\n    for (let posA = 0, posB = 0, i = 0; i < desc.sections.length;) {\n        let len = desc.sections[i++], ins = desc.sections[i++];\n        if (ins < 0) {\n            posA += len;\n            posB += len;\n        }\n        else {\n            let endA = posA, endB = posB, text = Text.empty;\n            for (;;) {\n                endA += len;\n                endB += ins;\n                if (ins && inserted)\n                    text = text.append(inserted[(i - 2) >> 1]);\n                if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)\n                    break;\n                len = desc.sections[i++];\n                ins = desc.sections[i++];\n            }\n            f(posA, endA, posB, endB, text);\n            posA = endA;\n            posB = endB;\n        }\n    }\n}\nfunction mapSet(setA, setB, before, mkSet = false) {\n    // Produce a copy of setA that applies to the document after setB\n    // has been applied (assuming both start at the same document).\n    let sections = [], insert = mkSet ? [] : null;\n    let a = new SectionIter(setA), b = new SectionIter(setB);\n    // Iterate over both sets in parallel. inserted tracks, for changes\n    // in A that have to be processed piece-by-piece, whether their\n    // content has been inserted already, and refers to the section\n    // index.\n    for (let inserted = -1;;) {\n        if (a.done && b.len || b.done && a.len) {\n            throw new Error(\"Mismatched change set lengths\");\n        }\n        else if (a.ins == -1 && b.ins == -1) {\n            // Move across ranges skipped by both sets.\n            let len = Math.min(a.len, b.len);\n            addSection(sections, len, -1);\n            a.forward(len);\n            b.forward(len);\n        }\n        else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {\n            // If there's a change in B that comes before the next change in\n            // A (ordered by start pos, then len, then before flag), skip\n            // that (and process any changes in A it covers).\n            let len = b.len;\n            addSection(sections, b.ins, -1);\n            while (len) {\n                let piece = Math.min(a.len, len);\n                if (a.ins >= 0 && inserted < a.i && a.len <= piece) {\n                    addSection(sections, 0, a.ins);\n                    if (insert)\n                        addInsert(insert, sections, a.text);\n                    inserted = a.i;\n                }\n                a.forward(piece);\n                len -= piece;\n            }\n            b.next();\n        }\n        else if (a.ins >= 0) {\n            // Process the part of a change in A up to the start of the next\n            // non-deletion change in B (if overlapping).\n            let len = 0, left = a.len;\n            while (left) {\n                if (b.ins == -1) {\n                    let piece = Math.min(left, b.len);\n                    len += piece;\n                    left -= piece;\n                    b.forward(piece);\n                }\n                else if (b.ins == 0 && b.len < left) {\n                    left -= b.len;\n                    b.next();\n                }\n                else {\n                    break;\n                }\n            }\n            addSection(sections, len, inserted < a.i ? a.ins : 0);\n            if (insert && inserted < a.i)\n                addInsert(insert, sections, a.text);\n            inserted = a.i;\n            a.forward(a.len - left);\n        }\n        else if (a.done && b.done) {\n            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);\n        }\n        else {\n            throw new Error(\"Mismatched change set lengths\");\n        }\n    }\n}\nfunction composeSets(setA, setB, mkSet = false) {\n    let sections = [];\n    let insert = mkSet ? [] : null;\n    let a = new SectionIter(setA), b = new SectionIter(setB);\n    for (let open = false;;) {\n        if (a.done && b.done) {\n            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);\n        }\n        else if (a.ins == 0) { // Deletion in A\n            addSection(sections, a.len, 0, open);\n            a.next();\n        }\n        else if (b.len == 0 && !b.done) { // Insertion in B\n            addSection(sections, 0, b.ins, open);\n            if (insert)\n                addInsert(insert, sections, b.text);\n            b.next();\n        }\n        else if (a.done || b.done) {\n            throw new Error(\"Mismatched change set lengths\");\n        }\n        else {\n            let len = Math.min(a.len2, b.len), sectionLen = sections.length;\n            if (a.ins == -1) {\n                let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;\n                addSection(sections, len, insB, open);\n                if (insert && insB)\n                    addInsert(insert, sections, b.text);\n            }\n            else if (b.ins == -1) {\n                addSection(sections, a.off ? 0 : a.len, len, open);\n                if (insert)\n                    addInsert(insert, sections, a.textBit(len));\n            }\n            else {\n                addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);\n                if (insert && !b.off)\n                    addInsert(insert, sections, b.text);\n            }\n            open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);\n            a.forward2(len);\n            b.forward(len);\n        }\n    }\n}\nclass SectionIter {\n    constructor(set) {\n        this.set = set;\n        this.i = 0;\n        this.next();\n    }\n    next() {\n        let { sections } = this.set;\n        if (this.i < sections.length) {\n            this.len = sections[this.i++];\n            this.ins = sections[this.i++];\n        }\n        else {\n            this.len = 0;\n            this.ins = -2;\n        }\n        this.off = 0;\n    }\n    get done() { return this.ins == -2; }\n    get len2() { return this.ins < 0 ? this.len : this.ins; }\n    get text() {\n        let { inserted } = this.set, index = (this.i - 2) >> 1;\n        return index >= inserted.length ? Text.empty : inserted[index];\n    }\n    textBit(len) {\n        let { inserted } = this.set, index = (this.i - 2) >> 1;\n        return index >= inserted.length && !len ? Text.empty\n            : inserted[index].slice(this.off, len == null ? undefined : this.off + len);\n    }\n    forward(len) {\n        if (len == this.len)\n            this.next();\n        else {\n            this.len -= len;\n            this.off += len;\n        }\n    }\n    forward2(len) {\n        if (this.ins == -1)\n            this.forward(len);\n        else if (len == this.ins)\n            this.next();\n        else {\n            this.ins -= len;\n            this.off += len;\n        }\n    }\n}\n\n/**\nA single selection range. When\n[`allowMultipleSelections`](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)\nis enabled, a [selection](https://codemirror.net/6/docs/ref/#state.EditorSelection) may hold\nmultiple ranges. By default, selections hold exactly one range.\n*/\nclass SelectionRange {\n    constructor(\n    /**\n    The lower boundary of the range.\n    */\n    from, \n    /**\n    The upper boundary of the range.\n    */\n    to, flags) {\n        this.from = from;\n        this.to = to;\n        this.flags = flags;\n    }\n    /**\n    The anchor of the range—the side that doesn't move when you\n    extend it.\n    */\n    get anchor() { return this.flags & 32 /* RangeFlag.Inverted */ ? this.to : this.from; }\n    /**\n    The head of the range, which is moved when the range is\n    [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).\n    */\n    get head() { return this.flags & 32 /* RangeFlag.Inverted */ ? this.from : this.to; }\n    /**\n    True when `anchor` and `head` are at the same position.\n    */\n    get empty() { return this.from == this.to; }\n    /**\n    If this is a cursor that is explicitly associated with the\n    character on one of its sides, this returns the side. -1 means\n    the character before its position, 1 the character after, and 0\n    means no association.\n    */\n    get assoc() { return this.flags & 8 /* RangeFlag.AssocBefore */ ? -1 : this.flags & 16 /* RangeFlag.AssocAfter */ ? 1 : 0; }\n    /**\n    The bidirectional text level associated with this cursor, if\n    any.\n    */\n    get bidiLevel() {\n        let level = this.flags & 7 /* RangeFlag.BidiLevelMask */;\n        return level == 7 ? null : level;\n    }\n    /**\n    The goal column (stored vertical offset) associated with a\n    cursor. This is used to preserve the vertical position when\n    [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across\n    lines of different length.\n    */\n    get goalColumn() {\n        let value = this.flags >> 6 /* RangeFlag.GoalColumnOffset */;\n        return value == 16777215 /* RangeFlag.NoGoalColumn */ ? undefined : value;\n    }\n    /**\n    Map this range through a change, producing a valid range in the\n    updated document.\n    */\n    map(change, assoc = -1) {\n        let from, to;\n        if (this.empty) {\n            from = to = change.mapPos(this.from, assoc);\n        }\n        else {\n            from = change.mapPos(this.from, 1);\n            to = change.mapPos(this.to, -1);\n        }\n        return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);\n    }\n    /**\n    Extend this range to cover at least `from` to `to`.\n    */\n    extend(from, to = from) {\n        if (from <= this.anchor && to >= this.anchor)\n            return EditorSelection.range(from, to);\n        let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;\n        return EditorSelection.range(this.anchor, head);\n    }\n    /**\n    Compare this range to another range.\n    */\n    eq(other, includeAssoc = false) {\n        return this.anchor == other.anchor && this.head == other.head &&\n            (!includeAssoc || !this.empty || this.assoc == other.assoc);\n    }\n    /**\n    Return a JSON-serializable object representing the range.\n    */\n    toJSON() { return { anchor: this.anchor, head: this.head }; }\n    /**\n    Convert a JSON representation of a range to a `SelectionRange`\n    instance.\n    */\n    static fromJSON(json) {\n        if (!json || typeof json.anchor != \"number\" || typeof json.head != \"number\")\n            throw new RangeError(\"Invalid JSON representation for SelectionRange\");\n        return EditorSelection.range(json.anchor, json.head);\n    }\n    /**\n    @internal\n    */\n    static create(from, to, flags) {\n        return new SelectionRange(from, to, flags);\n    }\n}\n/**\nAn editor selection holds one or more selection ranges.\n*/\nclass EditorSelection {\n    constructor(\n    /**\n    The ranges in the selection, sorted by position. Ranges cannot\n    overlap (but they may touch, if they aren't empty).\n    */\n    ranges, \n    /**\n    The index of the _main_ range in the selection (which is\n    usually the range that was added last).\n    */\n    mainIndex) {\n        this.ranges = ranges;\n        this.mainIndex = mainIndex;\n    }\n    /**\n    Map a selection through a change. Used to adjust the selection\n    position for changes.\n    */\n    map(change, assoc = -1) {\n        if (change.empty)\n            return this;\n        return EditorSelection.create(this.ranges.map(r => r.map(change, assoc)), this.mainIndex);\n    }\n    /**\n    Compare this selection to another selection. By default, ranges\n    are compared only by position. When `includeAssoc` is true,\n    cursor ranges must also have the same\n    [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.\n    */\n    eq(other, includeAssoc = false) {\n        if (this.ranges.length != other.ranges.length ||\n            this.mainIndex != other.mainIndex)\n            return false;\n        for (let i = 0; i < this.ranges.length; i++)\n            if (!this.ranges[i].eq(other.ranges[i], includeAssoc))\n                return false;\n        return true;\n    }\n    /**\n    Get the primary selection range. Usually, you should make sure\n    your code applies to _all_ ranges, by using methods like\n    [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).\n    */\n    get main() { return this.ranges[this.mainIndex]; }\n    /**\n    Make sure the selection only has one range. Returns a selection\n    holding only the main range from this selection.\n    */\n    asSingle() {\n        return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);\n    }\n    /**\n    Extend this selection with an extra range.\n    */\n    addRange(range, main = true) {\n        return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);\n    }\n    /**\n    Replace a given range with another range, and then normalize the\n    selection to merge and sort ranges if necessary.\n    */\n    replaceRange(range, which = this.mainIndex) {\n        let ranges = this.ranges.slice();\n        ranges[which] = range;\n        return EditorSelection.create(ranges, this.mainIndex);\n    }\n    /**\n    Convert this selection to an object that can be serialized to\n    JSON.\n    */\n    toJSON() {\n        return { ranges: this.ranges.map(r => r.toJSON()), main: this.mainIndex };\n    }\n    /**\n    Create a selection from a JSON representation.\n    */\n    static fromJSON(json) {\n        if (!json || !Array.isArray(json.ranges) || typeof json.main != \"number\" || json.main >= json.ranges.length)\n            throw new RangeError(\"Invalid JSON representation for EditorSelection\");\n        return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);\n    }\n    /**\n    Create a selection holding a single range.\n    */\n    static single(anchor, head = anchor) {\n        return new EditorSelection([EditorSelection.range(anchor, head)], 0);\n    }\n    /**\n    Sort and merge the given set of ranges, creating a valid\n    selection.\n    */\n    static create(ranges, mainIndex = 0) {\n        if (ranges.length == 0)\n            throw new RangeError(\"A selection needs at least one range\");\n        for (let pos = 0, i = 0; i < ranges.length; i++) {\n            let range = ranges[i];\n            if (range.empty ? range.from <= pos : range.from < pos)\n                return EditorSelection.normalized(ranges.slice(), mainIndex);\n            pos = range.to;\n        }\n        return new EditorSelection(ranges, mainIndex);\n    }\n    /**\n    Create a cursor selection range at the given position. You can\n    safely ignore the optional arguments in most situations.\n    */\n    static cursor(pos, assoc = 0, bidiLevel, goalColumn) {\n        return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 /* RangeFlag.AssocBefore */ : 16 /* RangeFlag.AssocAfter */) |\n            (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) |\n            ((goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215 /* RangeFlag.NoGoalColumn */) << 6 /* RangeFlag.GoalColumnOffset */));\n    }\n    /**\n    Create a selection range.\n    */\n    static range(anchor, head, goalColumn, bidiLevel) {\n        let flags = ((goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215 /* RangeFlag.NoGoalColumn */) << 6 /* RangeFlag.GoalColumnOffset */) |\n            (bidiLevel == null ? 7 : Math.min(6, bidiLevel));\n        return head < anchor ? SelectionRange.create(head, anchor, 32 /* RangeFlag.Inverted */ | 16 /* RangeFlag.AssocAfter */ | flags)\n            : SelectionRange.create(anchor, head, (head > anchor ? 8 /* RangeFlag.AssocBefore */ : 0) | flags);\n    }\n    /**\n    @internal\n    */\n    static normalized(ranges, mainIndex = 0) {\n        let main = ranges[mainIndex];\n        ranges.sort((a, b) => a.from - b.from);\n        mainIndex = ranges.indexOf(main);\n        for (let i = 1; i < ranges.length; i++) {\n            let range = ranges[i], prev = ranges[i - 1];\n            if (range.empty ? range.from <= prev.to : range.from < prev.to) {\n                let from = prev.from, to = Math.max(range.to, prev.to);\n                if (i <= mainIndex)\n                    mainIndex--;\n                ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));\n            }\n        }\n        return new EditorSelection(ranges, mainIndex);\n    }\n}\nfunction checkSelection(selection, docLength) {\n    for (let range of selection.ranges)\n        if (range.to > docLength)\n            throw new RangeError(\"Selection points outside of document\");\n}\n\nlet nextID = 0;\n/**\nA facet is a labeled value that is associated with an editor\nstate. It takes inputs from any number of extensions, and combines\nthose into a single output value.\n\nExamples of uses of facets are the [tab\nsize](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize), [editor\nattributes](https://codemirror.net/6/docs/ref/#view.EditorView^editorAttributes), and [update\nlisteners](https://codemirror.net/6/docs/ref/#view.EditorView^updateListener).\n\nNote that `Facet` instances can be used anywhere where\n[`FacetReader`](https://codemirror.net/6/docs/ref/#state.FacetReader) is expected.\n*/\nclass Facet {\n    constructor(\n    /**\n    @internal\n    */\n    combine, \n    /**\n    @internal\n    */\n    compareInput, \n    /**\n    @internal\n    */\n    compare, isStatic, enables) {\n        this.combine = combine;\n        this.compareInput = compareInput;\n        this.compare = compare;\n        this.isStatic = isStatic;\n        /**\n        @internal\n        */\n        this.id = nextID++;\n        this.default = combine([]);\n        this.extensions = typeof enables == \"function\" ? enables(this) : enables;\n    }\n    /**\n    Returns a facet reader for this facet, which can be used to\n    [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.\n    */\n    get reader() { return this; }\n    /**\n    Define a new facet.\n    */\n    static define(config = {}) {\n        return new Facet(config.combine || ((a) => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static, config.enables);\n    }\n    /**\n    Returns an extension that adds the given value to this facet.\n    */\n    of(value) {\n        return new FacetProvider([], this, 0 /* Provider.Static */, value);\n    }\n    /**\n    Create an extension that computes a value for the facet from a\n    state. You must take care to declare the parts of the state that\n    this value depends on, since your function is only called again\n    for a new state when one of those parts changed.\n    \n    In cases where your value depends only on a single field, you'll\n    want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.\n    */\n    compute(deps, get) {\n        if (this.isStatic)\n            throw new Error(\"Can't compute a static facet\");\n        return new FacetProvider(deps, this, 1 /* Provider.Single */, get);\n    }\n    /**\n    Create an extension that computes zero or more values for this\n    facet from a state.\n    */\n    computeN(deps, get) {\n        if (this.isStatic)\n            throw new Error(\"Can't compute a static facet\");\n        return new FacetProvider(deps, this, 2 /* Provider.Multi */, get);\n    }\n    from(field, get) {\n        if (!get)\n            get = x => x;\n        return this.compute([field], state => get(state.field(field)));\n    }\n}\nfunction sameArray(a, b) {\n    return a == b || a.length == b.length && a.every((e, i) => e === b[i]);\n}\nclass FacetProvider {\n    constructor(dependencies, facet, type, value) {\n        this.dependencies = dependencies;\n        this.facet = facet;\n        this.type = type;\n        this.value = value;\n        this.id = nextID++;\n    }\n    dynamicSlot(addresses) {\n        var _a;\n        let getter = this.value;\n        let compare = this.facet.compareInput;\n        let id = this.id, idx = addresses[id] >> 1, multi = this.type == 2 /* Provider.Multi */;\n        let depDoc = false, depSel = false, depAddrs = [];\n        for (let dep of this.dependencies) {\n            if (dep == \"doc\")\n                depDoc = true;\n            else if (dep == \"selection\")\n                depSel = true;\n            else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0)\n                depAddrs.push(addresses[dep.id]);\n        }\n        return {\n            create(state) {\n                state.values[idx] = getter(state);\n                return 1 /* SlotStatus.Changed */;\n            },\n            update(state, tr) {\n                if ((depDoc && tr.docChanged) || (depSel && (tr.docChanged || tr.selection)) || ensureAll(state, depAddrs)) {\n                    let newVal = getter(state);\n                    if (multi ? !compareArray(newVal, state.values[idx], compare) : !compare(newVal, state.values[idx])) {\n                        state.values[idx] = newVal;\n                        return 1 /* SlotStatus.Changed */;\n                    }\n                }\n                return 0;\n            },\n            reconfigure: (state, oldState) => {\n                let newVal, oldAddr = oldState.config.address[id];\n                if (oldAddr != null) {\n                    let oldVal = getAddr(oldState, oldAddr);\n                    if (this.dependencies.every(dep => {\n                        return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) :\n                            dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;\n                    }) || (multi ? compareArray(newVal = getter(state), oldVal, compare) : compare(newVal = getter(state), oldVal))) {\n                        state.values[idx] = oldVal;\n                        return 0;\n                    }\n                }\n                else {\n                    newVal = getter(state);\n                }\n                state.values[idx] = newVal;\n                return 1 /* SlotStatus.Changed */;\n            }\n        };\n    }\n}\nfunction compareArray(a, b, compare) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!compare(a[i], b[i]))\n            return false;\n    return true;\n}\nfunction ensureAll(state, addrs) {\n    let changed = false;\n    for (let addr of addrs)\n        if (ensureAddr(state, addr) & 1 /* SlotStatus.Changed */)\n            changed = true;\n    return changed;\n}\nfunction dynamicFacetSlot(addresses, facet, providers) {\n    let providerAddrs = providers.map(p => addresses[p.id]);\n    let providerTypes = providers.map(p => p.type);\n    let dynamic = providerAddrs.filter(p => !(p & 1));\n    let idx = addresses[facet.id] >> 1;\n    function get(state) {\n        let values = [];\n        for (let i = 0; i < providerAddrs.length; i++) {\n            let value = getAddr(state, providerAddrs[i]);\n            if (providerTypes[i] == 2 /* Provider.Multi */)\n                for (let val of value)\n                    values.push(val);\n            else\n                values.push(value);\n        }\n        return facet.combine(values);\n    }\n    return {\n        create(state) {\n            for (let addr of providerAddrs)\n                ensureAddr(state, addr);\n            state.values[idx] = get(state);\n            return 1 /* SlotStatus.Changed */;\n        },\n        update(state, tr) {\n            if (!ensureAll(state, dynamic))\n                return 0;\n            let value = get(state);\n            if (facet.compare(value, state.values[idx]))\n                return 0;\n            state.values[idx] = value;\n            return 1 /* SlotStatus.Changed */;\n        },\n        reconfigure(state, oldState) {\n            let depChanged = ensureAll(state, providerAddrs);\n            let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);\n            if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {\n                state.values[idx] = oldValue;\n                return 0;\n            }\n            let value = get(state);\n            if (facet.compare(value, oldValue)) {\n                state.values[idx] = oldValue;\n                return 0;\n            }\n            state.values[idx] = value;\n            return 1 /* SlotStatus.Changed */;\n        }\n    };\n}\nconst initField = /*@__PURE__*/Facet.define({ static: true });\n/**\nFields can store additional information in an editor state, and\nkeep it in sync with the rest of the state.\n*/\nclass StateField {\n    constructor(\n    /**\n    @internal\n    */\n    id, createF, updateF, compareF, \n    /**\n    @internal\n    */\n    spec) {\n        this.id = id;\n        this.createF = createF;\n        this.updateF = updateF;\n        this.compareF = compareF;\n        this.spec = spec;\n        /**\n        @internal\n        */\n        this.provides = undefined;\n    }\n    /**\n    Define a state field.\n    */\n    static define(config) {\n        let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);\n        if (config.provide)\n            field.provides = config.provide(field);\n        return field;\n    }\n    create(state) {\n        let init = state.facet(initField).find(i => i.field == this);\n        return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);\n    }\n    /**\n    @internal\n    */\n    slot(addresses) {\n        let idx = addresses[this.id] >> 1;\n        return {\n            create: (state) => {\n                state.values[idx] = this.create(state);\n                return 1 /* SlotStatus.Changed */;\n            },\n            update: (state, tr) => {\n                let oldVal = state.values[idx];\n                let value = this.updateF(oldVal, tr);\n                if (this.compareF(oldVal, value))\n                    return 0;\n                state.values[idx] = value;\n                return 1 /* SlotStatus.Changed */;\n            },\n            reconfigure: (state, oldState) => {\n                let init = state.facet(initField), oldInit = oldState.facet(initField), reInit;\n                if ((reInit = init.find(i => i.field == this)) && reInit != oldInit.find(i => i.field == this)) {\n                    state.values[idx] = reInit.create(state);\n                    return 1 /* SlotStatus.Changed */;\n                }\n                if (oldState.config.address[this.id] != null) {\n                    state.values[idx] = oldState.field(this);\n                    return 0;\n                }\n                state.values[idx] = this.create(state);\n                return 1 /* SlotStatus.Changed */;\n            }\n        };\n    }\n    /**\n    Returns an extension that enables this field and overrides the\n    way it is initialized. Can be useful when you need to provide a\n    non-default starting value for the field.\n    */\n    init(create) {\n        return [this, initField.of({ field: this, create })];\n    }\n    /**\n    State field instances can be used as\n    [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a\n    given state.\n    */\n    get extension() { return this; }\n}\nconst Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };\nfunction prec(value) {\n    return (ext) => new PrecExtension(ext, value);\n}\n/**\nBy default extensions are registered in the order they are found\nin the flattened form of nested array that was provided.\nIndividual extension values can be assigned a precedence to\noverride this. Extensions that do not have a precedence set get\nthe precedence of the nearest parent with a precedence, or\n[`default`](https://codemirror.net/6/docs/ref/#state.Prec.default) if there is no such parent. The\nfinal ordering of extensions is determined by first sorting by\nprecedence and then by order within each precedence.\n*/\nconst Prec = {\n    /**\n    The highest precedence level, for extensions that should end up\n    near the start of the precedence ordering.\n    */\n    highest: /*@__PURE__*/prec(Prec_.highest),\n    /**\n    A higher-than-default precedence, for extensions that should\n    come before those with default precedence.\n    */\n    high: /*@__PURE__*/prec(Prec_.high),\n    /**\n    The default precedence, which is also used for extensions\n    without an explicit precedence.\n    */\n    default: /*@__PURE__*/prec(Prec_.default),\n    /**\n    A lower-than-default precedence.\n    */\n    low: /*@__PURE__*/prec(Prec_.low),\n    /**\n    The lowest precedence level. Meant for things that should end up\n    near the end of the extension order.\n    */\n    lowest: /*@__PURE__*/prec(Prec_.lowest)\n};\nclass PrecExtension {\n    constructor(inner, prec) {\n        this.inner = inner;\n        this.prec = prec;\n    }\n}\n/**\nExtension compartments can be used to make a configuration\ndynamic. By [wrapping](https://codemirror.net/6/docs/ref/#state.Compartment.of) part of your\nconfiguration in a compartment, you can later\n[replace](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure) that part through a\ntransaction.\n*/\nclass Compartment {\n    /**\n    Create an instance of this compartment to add to your [state\n    configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).\n    */\n    of(ext) { return new CompartmentInstance(this, ext); }\n    /**\n    Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that\n    reconfigures this compartment.\n    */\n    reconfigure(content) {\n        return Compartment.reconfigure.of({ compartment: this, extension: content });\n    }\n    /**\n    Get the current content of the compartment in the state, or\n    `undefined` if it isn't present.\n    */\n    get(state) {\n        return state.config.compartments.get(this);\n    }\n}\nclass CompartmentInstance {\n    constructor(compartment, inner) {\n        this.compartment = compartment;\n        this.inner = inner;\n    }\n}\nclass Configuration {\n    constructor(base, compartments, dynamicSlots, address, staticValues, facets) {\n        this.base = base;\n        this.compartments = compartments;\n        this.dynamicSlots = dynamicSlots;\n        this.address = address;\n        this.staticValues = staticValues;\n        this.facets = facets;\n        this.statusTemplate = [];\n        while (this.statusTemplate.length < dynamicSlots.length)\n            this.statusTemplate.push(0 /* SlotStatus.Unresolved */);\n    }\n    staticFacet(facet) {\n        let addr = this.address[facet.id];\n        return addr == null ? facet.default : this.staticValues[addr >> 1];\n    }\n    static resolve(base, compartments, oldState) {\n        let fields = [];\n        let facets = Object.create(null);\n        let newCompartments = new Map();\n        for (let ext of flatten(base, compartments, newCompartments)) {\n            if (ext instanceof StateField)\n                fields.push(ext);\n            else\n                (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);\n        }\n        let address = Object.create(null);\n        let staticValues = [];\n        let dynamicSlots = [];\n        for (let field of fields) {\n            address[field.id] = dynamicSlots.length << 1;\n            dynamicSlots.push(a => field.slot(a));\n        }\n        let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;\n        for (let id in facets) {\n            let providers = facets[id], facet = providers[0].facet;\n            let oldProviders = oldFacets && oldFacets[id] || [];\n            if (providers.every(p => p.type == 0 /* Provider.Static */)) {\n                address[facet.id] = (staticValues.length << 1) | 1;\n                if (sameArray(oldProviders, providers)) {\n                    staticValues.push(oldState.facet(facet));\n                }\n                else {\n                    let value = facet.combine(providers.map(p => p.value));\n                    staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);\n                }\n            }\n            else {\n                for (let p of providers) {\n                    if (p.type == 0 /* Provider.Static */) {\n                        address[p.id] = (staticValues.length << 1) | 1;\n                        staticValues.push(p.value);\n                    }\n                    else {\n                        address[p.id] = dynamicSlots.length << 1;\n                        dynamicSlots.push(a => p.dynamicSlot(a));\n                    }\n                }\n                address[facet.id] = dynamicSlots.length << 1;\n                dynamicSlots.push(a => dynamicFacetSlot(a, facet, providers));\n            }\n        }\n        let dynamic = dynamicSlots.map(f => f(address));\n        return new Configuration(base, newCompartments, dynamic, address, staticValues, facets);\n    }\n}\nfunction flatten(extension, compartments, newCompartments) {\n    let result = [[], [], [], [], []];\n    let seen = new Map();\n    function inner(ext, prec) {\n        let known = seen.get(ext);\n        if (known != null) {\n            if (known <= prec)\n                return;\n            let found = result[known].indexOf(ext);\n            if (found > -1)\n                result[known].splice(found, 1);\n            if (ext instanceof CompartmentInstance)\n                newCompartments.delete(ext.compartment);\n        }\n        seen.set(ext, prec);\n        if (Array.isArray(ext)) {\n            for (let e of ext)\n                inner(e, prec);\n        }\n        else if (ext instanceof CompartmentInstance) {\n            if (newCompartments.has(ext.compartment))\n                throw new RangeError(`Duplicate use of compartment in extensions`);\n            let content = compartments.get(ext.compartment) || ext.inner;\n            newCompartments.set(ext.compartment, content);\n            inner(content, prec);\n        }\n        else if (ext instanceof PrecExtension) {\n            inner(ext.inner, ext.prec);\n        }\n        else if (ext instanceof StateField) {\n            result[prec].push(ext);\n            if (ext.provides)\n                inner(ext.provides, prec);\n        }\n        else if (ext instanceof FacetProvider) {\n            result[prec].push(ext);\n            if (ext.facet.extensions)\n                inner(ext.facet.extensions, Prec_.default);\n        }\n        else {\n            let content = ext.extension;\n            if (!content)\n                throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);\n            inner(content, prec);\n        }\n    }\n    inner(extension, Prec_.default);\n    return result.reduce((a, b) => a.concat(b));\n}\nfunction ensureAddr(state, addr) {\n    if (addr & 1)\n        return 2 /* SlotStatus.Computed */;\n    let idx = addr >> 1;\n    let status = state.status[idx];\n    if (status == 4 /* SlotStatus.Computing */)\n        throw new Error(\"Cyclic dependency between fields and/or facets\");\n    if (status & 2 /* SlotStatus.Computed */)\n        return status;\n    state.status[idx] = 4 /* SlotStatus.Computing */;\n    let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);\n    return state.status[idx] = 2 /* SlotStatus.Computed */ | changed;\n}\nfunction getAddr(state, addr) {\n    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];\n}\n\nconst languageData = /*@__PURE__*/Facet.define();\nconst allowMultipleSelections = /*@__PURE__*/Facet.define({\n    combine: values => values.some(v => v),\n    static: true\n});\nconst lineSeparator = /*@__PURE__*/Facet.define({\n    combine: values => values.length ? values[0] : undefined,\n    static: true\n});\nconst changeFilter = /*@__PURE__*/Facet.define();\nconst transactionFilter = /*@__PURE__*/Facet.define();\nconst transactionExtender = /*@__PURE__*/Facet.define();\nconst readOnly = /*@__PURE__*/Facet.define({\n    combine: values => values.length ? values[0] : false\n});\n\n/**\nAnnotations are tagged values that are used to add metadata to\ntransactions in an extensible way. They should be used to model\nthings that effect the entire transaction (such as its [time\nstamp](https://codemirror.net/6/docs/ref/#state.Transaction^time) or information about its\n[origin](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent)). For effects that happen\n_alongside_ the other changes made by the transaction, [state\neffects](https://codemirror.net/6/docs/ref/#state.StateEffect) are more appropriate.\n*/\nclass Annotation {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The annotation type.\n    */\n    type, \n    /**\n    The value of this annotation.\n    */\n    value) {\n        this.type = type;\n        this.value = value;\n    }\n    /**\n    Define a new type of annotation.\n    */\n    static define() { return new AnnotationType(); }\n}\n/**\nMarker that identifies a type of [annotation](https://codemirror.net/6/docs/ref/#state.Annotation).\n*/\nclass AnnotationType {\n    /**\n    Create an instance of this annotation.\n    */\n    of(value) { return new Annotation(this, value); }\n}\n/**\nRepresentation of a type of state effect. Defined with\n[`StateEffect.define`](https://codemirror.net/6/docs/ref/#state.StateEffect^define).\n*/\nclass StateEffectType {\n    /**\n    @internal\n    */\n    constructor(\n    // The `any` types in these function types are there to work\n    // around TypeScript issue #37631, where the type guard on\n    // `StateEffect.is` mysteriously stops working when these properly\n    // have type `Value`.\n    /**\n    @internal\n    */\n    map) {\n        this.map = map;\n    }\n    /**\n    Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this\n    type.\n    */\n    of(value) { return new StateEffect(this, value); }\n}\n/**\nState effects can be used to represent additional effects\nassociated with a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction.effects). They\nare often useful to model changes to custom [state\nfields](https://codemirror.net/6/docs/ref/#state.StateField), when those changes aren't implicit in\ndocument or selection changes.\n*/\nclass StateEffect {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    type, \n    /**\n    The value of this effect.\n    */\n    value) {\n        this.type = type;\n        this.value = value;\n    }\n    /**\n    Map this effect through a position mapping. Will return\n    `undefined` when that ends up deleting the effect.\n    */\n    map(mapping) {\n        let mapped = this.type.map(this.value, mapping);\n        return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);\n    }\n    /**\n    Tells you whether this effect object is of a given\n    [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).\n    */\n    is(type) { return this.type == type; }\n    /**\n    Define a new effect type. The type parameter indicates the type\n    of values that his effect holds. It should be a type that\n    doesn't include `undefined`, since that is used in\n    [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is\n    removed.\n    */\n    static define(spec = {}) {\n        return new StateEffectType(spec.map || (v => v));\n    }\n    /**\n    Map an array of effects through a change set.\n    */\n    static mapEffects(effects, mapping) {\n        if (!effects.length)\n            return effects;\n        let result = [];\n        for (let effect of effects) {\n            let mapped = effect.map(mapping);\n            if (mapped)\n                result.push(mapped);\n        }\n        return result;\n    }\n}\n/**\nThis effect can be used to reconfigure the root extensions of\nthe editor. Doing this will discard any extensions\n[appended](https://codemirror.net/6/docs/ref/#state.StateEffect^appendConfig), but does not reset\nthe content of [reconfigured](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure)\ncompartments.\n*/\nStateEffect.reconfigure = /*@__PURE__*/StateEffect.define();\n/**\nAppend extensions to the top-level configuration of the editor.\n*/\nStateEffect.appendConfig = /*@__PURE__*/StateEffect.define();\n/**\nChanges to the editor state are grouped into transactions.\nTypically, a user action creates a single transaction, which may\ncontain any number of document changes, may change the selection,\nor have other effects. Create a transaction by calling\n[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update), or immediately\ndispatch one by calling\n[`EditorView.dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch).\n*/\nclass Transaction {\n    constructor(\n    /**\n    The state from which the transaction starts.\n    */\n    startState, \n    /**\n    The document changes made by this transaction.\n    */\n    changes, \n    /**\n    The selection set by this transaction, or undefined if it\n    doesn't explicitly set a selection.\n    */\n    selection, \n    /**\n    The effects added to the transaction.\n    */\n    effects, \n    /**\n    @internal\n    */\n    annotations, \n    /**\n    Whether the selection should be scrolled into view after this\n    transaction is dispatched.\n    */\n    scrollIntoView) {\n        this.startState = startState;\n        this.changes = changes;\n        this.selection = selection;\n        this.effects = effects;\n        this.annotations = annotations;\n        this.scrollIntoView = scrollIntoView;\n        /**\n        @internal\n        */\n        this._doc = null;\n        /**\n        @internal\n        */\n        this._state = null;\n        if (selection)\n            checkSelection(selection, changes.newLength);\n        if (!annotations.some((a) => a.type == Transaction.time))\n            this.annotations = annotations.concat(Transaction.time.of(Date.now()));\n    }\n    /**\n    @internal\n    */\n    static create(startState, changes, selection, effects, annotations, scrollIntoView) {\n        return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView);\n    }\n    /**\n    The new document produced by the transaction. Contrary to\n    [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't\n    force the entire new state to be computed right away, so it is\n    recommended that [transaction\n    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter\n    when they need to look at the new document.\n    */\n    get newDoc() {\n        return this._doc || (this._doc = this.changes.apply(this.startState.doc));\n    }\n    /**\n    The new selection produced by the transaction. If\n    [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,\n    this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's\n    current selection through the changes made by the transaction.\n    */\n    get newSelection() {\n        return this.selection || this.startState.selection.map(this.changes);\n    }\n    /**\n    The new state created by the transaction. Computed on demand\n    (but retained for subsequent access), so it is recommended not to\n    access it in [transaction\n    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.\n    */\n    get state() {\n        if (!this._state)\n            this.startState.applyTransaction(this);\n        return this._state;\n    }\n    /**\n    Get the value of the given annotation type, if any.\n    */\n    annotation(type) {\n        for (let ann of this.annotations)\n            if (ann.type == type)\n                return ann.value;\n        return undefined;\n    }\n    /**\n    Indicates whether the transaction changed the document.\n    */\n    get docChanged() { return !this.changes.empty; }\n    /**\n    Indicates whether this transaction reconfigures the state\n    (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or\n    with a top-level configuration\n    [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).\n    */\n    get reconfigured() { return this.startState.config != this.state.config; }\n    /**\n    Returns true if the transaction has a [user\n    event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to\n    or more specific than `event`. For example, if the transaction\n    has `\"select.pointer\"` as user event, `\"select\"` and\n    `\"select.pointer\"` will match it.\n    */\n    isUserEvent(event) {\n        let e = this.annotation(Transaction.userEvent);\n        return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == \".\"));\n    }\n}\n/**\nAnnotation used to store transaction timestamps. Automatically\nadded to every transaction, holding `Date.now()`.\n*/\nTransaction.time = /*@__PURE__*/Annotation.define();\n/**\nAnnotation used to associate a transaction with a user interface\nevent. Holds a string identifying the event, using a\ndot-separated format to support attaching more specific\ninformation. The events used by the core libraries are:\n\n - `\"input\"` when content is entered\n   - `\"input.type\"` for typed input\n     - `\"input.type.compose\"` for composition\n   - `\"input.paste\"` for pasted input\n   - `\"input.drop\"` when adding content with drag-and-drop\n   - `\"input.complete\"` when autocompleting\n - `\"delete\"` when the user deletes content\n   - `\"delete.selection\"` when deleting the selection\n   - `\"delete.forward\"` when deleting forward from the selection\n   - `\"delete.backward\"` when deleting backward from the selection\n   - `\"delete.cut\"` when cutting to the clipboard\n - `\"move\"` when content is moved\n   - `\"move.drop\"` when content is moved within the editor through drag-and-drop\n - `\"select\"` when explicitly changing the selection\n   - `\"select.pointer\"` when selecting with a mouse or other pointing device\n - `\"undo\"` and `\"redo\"` for history actions\n\nUse [`isUserEvent`](https://codemirror.net/6/docs/ref/#state.Transaction.isUserEvent) to check\nwhether the annotation matches a given event.\n*/\nTransaction.userEvent = /*@__PURE__*/Annotation.define();\n/**\nAnnotation indicating whether a transaction should be added to\nthe undo history or not.\n*/\nTransaction.addToHistory = /*@__PURE__*/Annotation.define();\n/**\nAnnotation indicating (when present and true) that a transaction\nrepresents a change made by some other actor, not the user. This\nis used, for example, to tag other people's changes in\ncollaborative editing.\n*/\nTransaction.remote = /*@__PURE__*/Annotation.define();\nfunction joinRanges(a, b) {\n    let result = [];\n    for (let iA = 0, iB = 0;;) {\n        let from, to;\n        if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {\n            from = a[iA++];\n            to = a[iA++];\n        }\n        else if (iB < b.length) {\n            from = b[iB++];\n            to = b[iB++];\n        }\n        else\n            return result;\n        if (!result.length || result[result.length - 1] < from)\n            result.push(from, to);\n        else if (result[result.length - 1] < to)\n            result[result.length - 1] = to;\n    }\n}\nfunction mergeTransaction(a, b, sequential) {\n    var _a;\n    let mapForA, mapForB, changes;\n    if (sequential) {\n        mapForA = b.changes;\n        mapForB = ChangeSet.empty(b.changes.length);\n        changes = a.changes.compose(b.changes);\n    }\n    else {\n        mapForA = b.changes.map(a.changes);\n        mapForB = a.changes.mapDesc(b.changes, true);\n        changes = a.changes.compose(mapForA);\n    }\n    return {\n        changes,\n        selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),\n        effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),\n        annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,\n        scrollIntoView: a.scrollIntoView || b.scrollIntoView\n    };\n}\nfunction resolveTransactionInner(state, spec, docSize) {\n    let sel = spec.selection, annotations = asArray(spec.annotations);\n    if (spec.userEvent)\n        annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));\n    return {\n        changes: spec.changes instanceof ChangeSet ? spec.changes\n            : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),\n        selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),\n        effects: asArray(spec.effects),\n        annotations,\n        scrollIntoView: !!spec.scrollIntoView\n    };\n}\nfunction resolveTransaction(state, specs, filter) {\n    let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);\n    if (specs.length && specs[0].filter === false)\n        filter = false;\n    for (let i = 1; i < specs.length; i++) {\n        if (specs[i].filter === false)\n            filter = false;\n        let seq = !!specs[i].sequential;\n        s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);\n    }\n    let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);\n    return extendTransaction(filter ? filterTransaction(tr) : tr);\n}\n// Finish a transaction by applying filters if necessary.\nfunction filterTransaction(tr) {\n    let state = tr.startState;\n    // Change filters\n    let result = true;\n    for (let filter of state.facet(changeFilter)) {\n        let value = filter(tr);\n        if (value === false) {\n            result = false;\n            break;\n        }\n        if (Array.isArray(value))\n            result = result === true ? value : joinRanges(result, value);\n    }\n    if (result !== true) {\n        let changes, back;\n        if (result === false) {\n            back = tr.changes.invertedDesc;\n            changes = ChangeSet.empty(state.doc.length);\n        }\n        else {\n            let filtered = tr.changes.filter(result);\n            changes = filtered.changes;\n            back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;\n        }\n        tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);\n    }\n    // Transaction filters\n    let filters = state.facet(transactionFilter);\n    for (let i = filters.length - 1; i >= 0; i--) {\n        let filtered = filters[i](tr);\n        if (filtered instanceof Transaction)\n            tr = filtered;\n        else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)\n            tr = filtered[0];\n        else\n            tr = resolveTransaction(state, asArray(filtered), false);\n    }\n    return tr;\n}\nfunction extendTransaction(tr) {\n    let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;\n    for (let i = extenders.length - 1; i >= 0; i--) {\n        let extension = extenders[i](tr);\n        if (extension && Object.keys(extension).length)\n            spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);\n    }\n    return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);\n}\nconst none = [];\nfunction asArray(value) {\n    return value == null ? none : Array.isArray(value) ? value : [value];\n}\n\n/**\nThe categories produced by a [character\ncategorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer). These are used\ndo things like selecting by word.\n*/\nvar CharCategory = /*@__PURE__*/(function (CharCategory) {\n    /**\n    Word characters.\n    */\n    CharCategory[CharCategory[\"Word\"] = 0] = \"Word\";\n    /**\n    Whitespace.\n    */\n    CharCategory[CharCategory[\"Space\"] = 1] = \"Space\";\n    /**\n    Anything else.\n    */\n    CharCategory[CharCategory[\"Other\"] = 2] = \"Other\";\nreturn CharCategory})(CharCategory || (CharCategory = {}));\nconst nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nlet wordChar;\ntry {\n    wordChar = /*@__PURE__*/new RegExp(\"[\\\\p{Alphabetic}\\\\p{Number}_]\", \"u\");\n}\ncatch (_) { }\nfunction hasWordChar(str) {\n    if (wordChar)\n        return wordChar.test(str);\n    for (let i = 0; i < str.length; i++) {\n        let ch = str[i];\n        if (/\\w/.test(ch) || ch > \"\\x80\" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))\n            return true;\n    }\n    return false;\n}\nfunction makeCategorizer(wordChars) {\n    return (char) => {\n        if (!/\\S/.test(char))\n            return CharCategory.Space;\n        if (hasWordChar(char))\n            return CharCategory.Word;\n        for (let i = 0; i < wordChars.length; i++)\n            if (char.indexOf(wordChars[i]) > -1)\n                return CharCategory.Word;\n        return CharCategory.Other;\n    };\n}\n\n/**\nThe editor state class is a persistent (immutable) data structure.\nTo update a state, you [create](https://codemirror.net/6/docs/ref/#state.EditorState.update) a\n[transaction](https://codemirror.net/6/docs/ref/#state.Transaction), which produces a _new_ state\ninstance, without modifying the original object.\n\nAs such, _never_ mutate properties of a state directly. That'll\njust break things.\n*/\nclass EditorState {\n    constructor(\n    /**\n    @internal\n    */\n    config, \n    /**\n    The current document.\n    */\n    doc, \n    /**\n    The current selection.\n    */\n    selection, \n    /**\n    @internal\n    */\n    values, computeSlot, tr) {\n        this.config = config;\n        this.doc = doc;\n        this.selection = selection;\n        this.values = values;\n        this.status = config.statusTemplate.slice();\n        this.computeSlot = computeSlot;\n        // Fill in the computed state immediately, so that further queries\n        // for it made during the update return this state\n        if (tr)\n            tr._state = this;\n        for (let i = 0; i < this.config.dynamicSlots.length; i++)\n            ensureAddr(this, i << 1);\n        this.computeSlot = null;\n    }\n    field(field, require = true) {\n        let addr = this.config.address[field.id];\n        if (addr == null) {\n            if (require)\n                throw new RangeError(\"Field is not present in this state\");\n            return undefined;\n        }\n        ensureAddr(this, addr);\n        return getAddr(this, addr);\n    }\n    /**\n    Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this\n    state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)\n    can be passed. Unless\n    [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the\n    [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec\n    are assumed to start in the _current_ document (not the document\n    produced by previous specs), and its\n    [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and\n    [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer\n    to the document created by its _own_ changes. The resulting\n    transaction contains the combined effect of all the different\n    specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later\n    specs take precedence over earlier ones.\n    */\n    update(...specs) {\n        return resolveTransaction(this, specs, true);\n    }\n    /**\n    @internal\n    */\n    applyTransaction(tr) {\n        let conf = this.config, { base, compartments } = conf;\n        for (let effect of tr.effects) {\n            if (effect.is(Compartment.reconfigure)) {\n                if (conf) {\n                    compartments = new Map;\n                    conf.compartments.forEach((val, key) => compartments.set(key, val));\n                    conf = null;\n                }\n                compartments.set(effect.value.compartment, effect.value.extension);\n            }\n            else if (effect.is(StateEffect.reconfigure)) {\n                conf = null;\n                base = effect.value;\n            }\n            else if (effect.is(StateEffect.appendConfig)) {\n                conf = null;\n                base = asArray(base).concat(effect.value);\n            }\n        }\n        let startValues;\n        if (!conf) {\n            conf = Configuration.resolve(base, compartments, this);\n            let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);\n            startValues = intermediateState.values;\n        }\n        else {\n            startValues = tr.startState.values.slice();\n        }\n        let selection = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();\n        new EditorState(conf, tr.newDoc, selection, startValues, (state, slot) => slot.update(state, tr), tr);\n    }\n    /**\n    Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that\n    replaces every selection range with the given content.\n    */\n    replaceSelection(text) {\n        if (typeof text == \"string\")\n            text = this.toText(text);\n        return this.changeByRange(range => ({ changes: { from: range.from, to: range.to, insert: text },\n            range: EditorSelection.cursor(range.from + text.length) }));\n    }\n    /**\n    Create a set of changes and a new selection by running the given\n    function for each range in the active selection. The function\n    can return an optional set of changes (in the coordinate space\n    of the start document), plus an updated range (in the coordinate\n    space of the document produced by the call's own changes). This\n    method will merge all the changes and ranges into a single\n    changeset and selection, and return it as a [transaction\n    spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to\n    [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).\n    */\n    changeByRange(f) {\n        let sel = this.selection;\n        let result1 = f(sel.ranges[0]);\n        let changes = this.changes(result1.changes), ranges = [result1.range];\n        let effects = asArray(result1.effects);\n        for (let i = 1; i < sel.ranges.length; i++) {\n            let result = f(sel.ranges[i]);\n            let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);\n            for (let j = 0; j < i; j++)\n                ranges[j] = ranges[j].map(newMapped);\n            let mapBy = changes.mapDesc(newChanges, true);\n            ranges.push(result.range.map(mapBy));\n            changes = changes.compose(newMapped);\n            effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));\n        }\n        return {\n            changes,\n            selection: EditorSelection.create(ranges, sel.mainIndex),\n            effects\n        };\n    }\n    /**\n    Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change\n    description, taking the state's document length and line\n    separator into account.\n    */\n    changes(spec = []) {\n        if (spec instanceof ChangeSet)\n            return spec;\n        return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));\n    }\n    /**\n    Using the state's [line\n    separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a\n    [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.\n    */\n    toText(string) {\n        return Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));\n    }\n    /**\n    Return the given range of the document as a string.\n    */\n    sliceDoc(from = 0, to = this.doc.length) {\n        return this.doc.sliceString(from, to, this.lineBreak);\n    }\n    /**\n    Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).\n    */\n    facet(facet) {\n        let addr = this.config.address[facet.id];\n        if (addr == null)\n            return facet.default;\n        ensureAddr(this, addr);\n        return getAddr(this, addr);\n    }\n    /**\n    Convert this state to a JSON-serializable object. When custom\n    fields should be serialized, you can pass them in as an object\n    mapping property names (in the resulting object, which should\n    not use `doc` or `selection`) to fields.\n    */\n    toJSON(fields) {\n        let result = {\n            doc: this.sliceDoc(),\n            selection: this.selection.toJSON()\n        };\n        if (fields)\n            for (let prop in fields) {\n                let value = fields[prop];\n                if (value instanceof StateField && this.config.address[value.id] != null)\n                    result[prop] = value.spec.toJSON(this.field(fields[prop]), this);\n            }\n        return result;\n    }\n    /**\n    Deserialize a state from its JSON representation. When custom\n    fields should be deserialized, pass the same object you passed\n    to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as\n    third argument.\n    */\n    static fromJSON(json, config = {}, fields) {\n        if (!json || typeof json.doc != \"string\")\n            throw new RangeError(\"Invalid JSON representation for EditorState\");\n        let fieldInit = [];\n        if (fields)\n            for (let prop in fields) {\n                if (Object.prototype.hasOwnProperty.call(json, prop)) {\n                    let field = fields[prop], value = json[prop];\n                    fieldInit.push(field.init(state => field.spec.fromJSON(value, state)));\n                }\n            }\n        return EditorState.create({\n            doc: json.doc,\n            selection: EditorSelection.fromJSON(json.selection),\n            extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit\n        });\n    }\n    /**\n    Create a new state. You'll usually only need this when\n    initializing an editor—updated states are created by applying\n    transactions.\n    */\n    static create(config = {}) {\n        let configuration = Configuration.resolve(config.extensions || [], new Map);\n        let doc = config.doc instanceof Text ? config.doc\n            : Text.of((config.doc || \"\").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));\n        let selection = !config.selection ? EditorSelection.single(0)\n            : config.selection instanceof EditorSelection ? config.selection\n                : EditorSelection.single(config.selection.anchor, config.selection.head);\n        checkSelection(selection, doc.length);\n        if (!configuration.staticFacet(allowMultipleSelections))\n            selection = selection.asSingle();\n        return new EditorState(configuration, doc, selection, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);\n    }\n    /**\n    The size (in columns) of a tab in the document, determined by\n    the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.\n    */\n    get tabSize() { return this.facet(EditorState.tabSize); }\n    /**\n    Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)\n    string for this state.\n    */\n    get lineBreak() { return this.facet(EditorState.lineSeparator) || \"\\n\"; }\n    /**\n    Returns true when the editor is\n    [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.\n    */\n    get readOnly() { return this.facet(readOnly); }\n    /**\n    Look up a translation for the given phrase (via the\n    [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the\n    original string if no translation is found.\n    \n    If additional arguments are passed, they will be inserted in\n    place of markers like `$1` (for the first value) and `$2`, etc.\n    A single `$` is equivalent to `$1`, and `$$` will produce a\n    literal dollar sign.\n    */\n    phrase(phrase, ...insert) {\n        for (let map of this.facet(EditorState.phrases))\n            if (Object.prototype.hasOwnProperty.call(map, phrase)) {\n                phrase = map[phrase];\n                break;\n            }\n        if (insert.length)\n            phrase = phrase.replace(/\\$(\\$|\\d*)/g, (m, i) => {\n                if (i == \"$\")\n                    return \"$\";\n                let n = +(i || 1);\n                return !n || n > insert.length ? m : insert[n - 1];\n            });\n        return phrase;\n    }\n    /**\n    Find the values for a given language data field, provided by the\n    the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.\n    \n    Examples of language data fields are...\n    \n    - [`\"commentTokens\"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying\n      comment syntax.\n    - [`\"autocomplete\"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)\n      for providing language-specific completion sources.\n    - [`\"wordChars\"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding\n      characters that should be considered part of words in this\n      language.\n    - [`\"closeBrackets\"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls\n      bracket closing behavior.\n    */\n    languageDataAt(name, pos, side = -1) {\n        let values = [];\n        for (let provider of this.facet(languageData)) {\n            for (let result of provider(this, pos, side)) {\n                if (Object.prototype.hasOwnProperty.call(result, name))\n                    values.push(result[name]);\n            }\n        }\n        return values;\n    }\n    /**\n    Return a function that can categorize strings (expected to\n    represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))\n    into one of:\n    \n     - Word (contains an alphanumeric character or a character\n       explicitly listed in the local language's `\"wordChars\"`\n       language data, which should be a string)\n     - Space (contains only whitespace)\n     - Other (anything else)\n    */\n    charCategorizer(at) {\n        return makeCategorizer(this.languageDataAt(\"wordChars\", at).join(\"\"));\n    }\n    /**\n    Find the word at the given position, meaning the range\n    containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters\n    around it. If no word characters are adjacent to the position,\n    this returns null.\n    */\n    wordAt(pos) {\n        let { text, from, length } = this.doc.lineAt(pos);\n        let cat = this.charCategorizer(pos);\n        let start = pos - from, end = pos - from;\n        while (start > 0) {\n            let prev = findClusterBreak(text, start, false);\n            if (cat(text.slice(prev, start)) != CharCategory.Word)\n                break;\n            start = prev;\n        }\n        while (end < length) {\n            let next = findClusterBreak(text, end);\n            if (cat(text.slice(end, next)) != CharCategory.Word)\n                break;\n            end = next;\n        }\n        return start == end ? null : EditorSelection.range(start + from, end + from);\n    }\n}\n/**\nA facet that, when enabled, causes the editor to allow multiple\nranges to be selected. Be careful though, because by default the\neditor relies on the native DOM selection, which cannot handle\nmultiple selections. An extension like\n[`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) can be used to make\nsecondary selections visible to the user.\n*/\nEditorState.allowMultipleSelections = allowMultipleSelections;\n/**\nConfigures the tab size to use in this state. The first\n(highest-precedence) value of the facet is used. If no value is\ngiven, this defaults to 4.\n*/\nEditorState.tabSize = /*@__PURE__*/Facet.define({\n    combine: values => values.length ? values[0] : 4\n});\n/**\nThe line separator to use. By default, any of `\"\\n\"`, `\"\\r\\n\"`\nand `\"\\r\"` is treated as a separator when splitting lines, and\nlines are joined with `\"\\n\"`.\n\nWhen you configure a value here, only that precise separator\nwill be used, allowing you to round-trip documents through the\neditor without normalizing line separators.\n*/\nEditorState.lineSeparator = lineSeparator;\n/**\nThis facet controls the value of the\n[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) getter, which is\nconsulted by commands and extensions that implement editing\nfunctionality to determine whether they should apply. It\ndefaults to false, but when its highest-precedence value is\n`true`, such functionality disables itself.\n\nNot to be confused with\n[`EditorView.editable`](https://codemirror.net/6/docs/ref/#view.EditorView^editable), which\ncontrols whether the editor's DOM is set to be editable (and\nthus focusable).\n*/\nEditorState.readOnly = readOnly;\n/**\nRegisters translation phrases. The\n[`phrase`](https://codemirror.net/6/docs/ref/#state.EditorState.phrase) method will look through\nall objects registered with this facet to find translations for\nits argument.\n*/\nEditorState.phrases = /*@__PURE__*/Facet.define({\n    compare(a, b) {\n        let kA = Object.keys(a), kB = Object.keys(b);\n        return kA.length == kB.length && kA.every(k => a[k] == b[k]);\n    }\n});\n/**\nA facet used to register [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) providers.\n*/\nEditorState.languageData = languageData;\n/**\nFacet used to register change filters, which are called for each\ntransaction (unless explicitly\n[disabled](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter)), and can suppress\npart of the transaction's changes.\n\nSuch a function can return `true` to indicate that it doesn't\nwant to do anything, `false` to completely stop the changes in\nthe transaction, or a set of ranges in which changes should be\nsuppressed. Such ranges are represented as an array of numbers,\nwith each pair of two numbers indicating the start and end of a\nrange. So for example `[10, 20, 100, 110]` suppresses changes\nbetween 10 and 20, and between 100 and 110.\n*/\nEditorState.changeFilter = changeFilter;\n/**\nFacet used to register a hook that gets a chance to update or\nreplace transaction specs before they are applied. This will\nonly be applied for transactions that don't have\n[`filter`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter) set to `false`. You\ncan either return a single transaction spec (possibly the input\ntransaction), or an array of specs (which will be combined in\nthe same way as the arguments to\n[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update)).\n\nWhen possible, it is recommended to avoid accessing\n[`Transaction.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state) in a filter,\nsince it will force creation of a state that will then be\ndiscarded again, if the transaction is actually filtered.\n\n(This functionality should be used with care. Indiscriminately\nmodifying transaction is likely to break something or degrade\nthe user experience.)\n*/\nEditorState.transactionFilter = transactionFilter;\n/**\nThis is a more limited form of\n[`transactionFilter`](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter),\nwhich can only add\n[annotations](https://codemirror.net/6/docs/ref/#state.TransactionSpec.annotations) and\n[effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects). _But_, this type\nof filter runs even if the transaction has disabled regular\n[filtering](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter), making it suitable\nfor effects that don't need to touch the changes or selection,\nbut do want to process every transaction.\n\nExtenders run _after_ filters, when both are present.\n*/\nEditorState.transactionExtender = transactionExtender;\nCompartment.reconfigure = /*@__PURE__*/StateEffect.define();\n\n/**\nUtility function for combining behaviors to fill in a config\nobject from an array of provided configs. `defaults` should hold\ndefault values for all optional fields in `Config`.\n\nThe function will, by default, error\nwhen a field gets two values that aren't `===`-equal, but you can\nprovide combine functions per field to do something else.\n*/\nfunction combineConfig(configs, defaults, // Should hold only the optional properties of Config, but I haven't managed to express that\ncombine = {}) {\n    let result = {};\n    for (let config of configs)\n        for (let key of Object.keys(config)) {\n            let value = config[key], current = result[key];\n            if (current === undefined)\n                result[key] = value;\n            else if (current === value || value === undefined) ; // No conflict\n            else if (Object.hasOwnProperty.call(combine, key))\n                result[key] = combine[key](current, value);\n            else\n                throw new Error(\"Config merge conflict for field \" + key);\n        }\n    for (let key in defaults)\n        if (result[key] === undefined)\n            result[key] = defaults[key];\n    return result;\n}\n\n/**\nEach range is associated with a value, which must inherit from\nthis class.\n*/\nclass RangeValue {\n    /**\n    Compare this value with another value. Used when comparing\n    rangesets. The default implementation compares by identity.\n    Unless you are only creating a fixed number of unique instances\n    of your value type, it is a good idea to implement this\n    properly.\n    */\n    eq(other) { return this == other; }\n    /**\n    Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.\n    */\n    range(from, to = from) { return Range.create(from, to, this); }\n}\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.mapMode = MapMode.TrackDel;\n/**\nA range associates a value with a range of positions.\n*/\nclass Range {\n    constructor(\n    /**\n    The range's start position.\n    */\n    from, \n    /**\n    Its end position.\n    */\n    to, \n    /**\n    The value associated with this range.\n    */\n    value) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n    }\n    /**\n    @internal\n    */\n    static create(from, to, value) {\n        return new Range(from, to, value);\n    }\n}\nfunction cmpRange(a, b) {\n    return a.from - b.from || a.value.startSide - b.value.startSide;\n}\nclass Chunk {\n    constructor(from, to, value, \n    // Chunks are marked with the largest point that occurs\n    // in them (or -1 for no points), so that scans that are\n    // only interested in points (such as the\n    // heightmap-related logic) can skip range-only chunks.\n    maxPoint) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n        this.maxPoint = maxPoint;\n    }\n    get length() { return this.to[this.to.length - 1]; }\n    // Find the index of the given position and side. Use the ranges'\n    // `from` pos when `end == false`, `to` when `end == true`.\n    findIndex(pos, side, end, startAt = 0) {\n        let arr = end ? this.to : this.from;\n        for (let lo = startAt, hi = arr.length;;) {\n            if (lo == hi)\n                return lo;\n            let mid = (lo + hi) >> 1;\n            let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;\n            if (mid == lo)\n                return diff >= 0 ? lo : hi;\n            if (diff >= 0)\n                hi = mid;\n            else\n                lo = mid + 1;\n        }\n    }\n    between(offset, from, to, f) {\n        for (let i = this.findIndex(from, -1000000000 /* C.Far */, true), e = this.findIndex(to, 1000000000 /* C.Far */, false, i); i < e; i++)\n            if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)\n                return false;\n    }\n    map(offset, changes) {\n        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;\n        for (let i = 0; i < this.value.length; i++) {\n            let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;\n            if (curFrom == curTo) {\n                let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);\n                if (mapped == null)\n                    continue;\n                newFrom = newTo = mapped;\n                if (val.startSide != val.endSide) {\n                    newTo = changes.mapPos(curFrom, val.endSide);\n                    if (newTo < newFrom)\n                        continue;\n                }\n            }\n            else {\n                newFrom = changes.mapPos(curFrom, val.startSide);\n                newTo = changes.mapPos(curTo, val.endSide);\n                if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)\n                    continue;\n            }\n            if ((newTo - newFrom || val.endSide - val.startSide) < 0)\n                continue;\n            if (newPos < 0)\n                newPos = newFrom;\n            if (val.point)\n                maxPoint = Math.max(maxPoint, newTo - newFrom);\n            value.push(val);\n            from.push(newFrom - newPos);\n            to.push(newTo - newPos);\n        }\n        return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };\n    }\n}\n/**\nA range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#state.Range) in a\nway that makes them efficient to [map](https://codemirror.net/6/docs/ref/#state.RangeSet.map) and\n[update](https://codemirror.net/6/docs/ref/#state.RangeSet.update). This is an immutable data\nstructure.\n*/\nclass RangeSet {\n    constructor(\n    /**\n    @internal\n    */\n    chunkPos, \n    /**\n    @internal\n    */\n    chunk, \n    /**\n    @internal\n    */\n    nextLayer, \n    /**\n    @internal\n    */\n    maxPoint) {\n        this.chunkPos = chunkPos;\n        this.chunk = chunk;\n        this.nextLayer = nextLayer;\n        this.maxPoint = maxPoint;\n    }\n    /**\n    @internal\n    */\n    static create(chunkPos, chunk, nextLayer, maxPoint) {\n        return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);\n    }\n    /**\n    @internal\n    */\n    get length() {\n        let last = this.chunk.length - 1;\n        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n    }\n    /**\n    The number of ranges in the set.\n    */\n    get size() {\n        if (this.isEmpty)\n            return 0;\n        let size = this.nextLayer.size;\n        for (let chunk of this.chunk)\n            size += chunk.value.length;\n        return size;\n    }\n    /**\n    @internal\n    */\n    chunkEnd(index) {\n        return this.chunkPos[index] + this.chunk[index].length;\n    }\n    /**\n    Update the range set, optionally adding new ranges or filtering\n    out existing ones.\n    \n    (Note: The type parameter is just there as a kludge to work\n    around TypeScript variance issues that prevented `RangeSet<X>`\n    from being a subtype of `RangeSet<Y>` when `X` is a subtype of\n    `Y`.)\n    */\n    update(updateSpec) {\n        let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;\n        let filter = updateSpec.filter;\n        if (add.length == 0 && !filter)\n            return this;\n        if (sort)\n            add = add.slice().sort(cmpRange);\n        if (this.isEmpty)\n            return add.length ? RangeSet.of(add) : this;\n        let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];\n        let builder = new RangeSetBuilder();\n        while (cur.value || i < add.length) {\n            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n                let range = add[i++];\n                if (!builder.addInner(range.from, range.to, range.value))\n                    spill.push(range);\n            }\n            else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length &&\n                (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) &&\n                (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) &&\n                builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n                cur.nextChunk();\n            }\n            else {\n                if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n                    if (!builder.addInner(cur.from, cur.to, cur.value))\n                        spill.push(Range.create(cur.from, cur.to, cur.value));\n                }\n                cur.next();\n            }\n        }\n        return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty\n            : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));\n    }\n    /**\n    Map this range set through a set of changes, return the new set.\n    */\n    map(changes) {\n        if (changes.empty || this.isEmpty)\n            return this;\n        let chunks = [], chunkPos = [], maxPoint = -1;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            let touch = changes.touchesRange(start, start + chunk.length);\n            if (touch === false) {\n                maxPoint = Math.max(maxPoint, chunk.maxPoint);\n                chunks.push(chunk);\n                chunkPos.push(changes.mapPos(start));\n            }\n            else if (touch === true) {\n                let { mapped, pos } = chunk.map(start, changes);\n                if (mapped) {\n                    maxPoint = Math.max(maxPoint, mapped.maxPoint);\n                    chunks.push(mapped);\n                    chunkPos.push(pos);\n                }\n            }\n        }\n        let next = this.nextLayer.map(changes);\n        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);\n    }\n    /**\n    Iterate over the ranges that touch the region `from` to `to`,\n    calling `f` for each. There is no guarantee that the ranges will\n    be reported in any specific order. When the callback returns\n    `false`, iteration stops.\n    */\n    between(from, to, f) {\n        if (this.isEmpty)\n            return;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            if (to >= start && from <= start + chunk.length &&\n                chunk.between(start, from - start, to - start, f) === false)\n                return;\n        }\n        this.nextLayer.between(from, to, f);\n    }\n    /**\n    Iterate over the ranges in this set, in order, including all\n    ranges that end at or after `from`.\n    */\n    iter(from = 0) {\n        return HeapCursor.from([this]).goto(from);\n    }\n    /**\n    @internal\n    */\n    get isEmpty() { return this.nextLayer == this; }\n    /**\n    Iterate over the ranges in a collection of sets, in order,\n    starting from `from`.\n    */\n    static iter(sets, from = 0) {\n        return HeapCursor.from(sets).goto(from);\n    }\n    /**\n    Iterate over two groups of sets, calling methods on `comparator`\n    to notify it of possible differences.\n    */\n    static compare(oldSets, newSets, \n    /**\n    This indicates how the underlying data changed between these\n    ranges, and is needed to synchronize the iteration.\n    */\n    textDiff, comparator, \n    /**\n    Can be used to ignore all non-point ranges, and points below\n    the given size. When -1, all ranges are compared.\n    */\n    minPointSize = -1) {\n        let a = oldSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n        let b = newSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n        let sharedChunks = findSharedChunks(a, b, textDiff);\n        let sideA = new SpanCursor(a, sharedChunks, minPointSize);\n        let sideB = new SpanCursor(b, sharedChunks, minPointSize);\n        textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));\n        if (textDiff.empty && textDiff.length == 0)\n            compare(sideA, 0, sideB, 0, 0, comparator);\n    }\n    /**\n    Compare the contents of two groups of range sets, returning true\n    if they are equivalent in the given range.\n    */\n    static eq(oldSets, newSets, from = 0, to) {\n        if (to == null)\n            to = 1000000000 /* C.Far */ - 1;\n        let a = oldSets.filter(set => !set.isEmpty && newSets.indexOf(set) < 0);\n        let b = newSets.filter(set => !set.isEmpty && oldSets.indexOf(set) < 0);\n        if (a.length != b.length)\n            return false;\n        if (!a.length)\n            return true;\n        let sharedChunks = findSharedChunks(a, b);\n        let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);\n        for (;;) {\n            if (sideA.to != sideB.to ||\n                !sameValues(sideA.active, sideB.active) ||\n                sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))\n                return false;\n            if (sideA.to > to)\n                return true;\n            sideA.next();\n            sideB.next();\n        }\n    }\n    /**\n    Iterate over a group of range sets at the same time, notifying\n    the iterator about the ranges covering every given piece of\n    content. Returns the open count (see\n    [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end\n    of the iteration.\n    */\n    static spans(sets, from, to, iterator, \n    /**\n    When given and greater than -1, only points of at least this\n    size are taken into account.\n    */\n    minPointSize = -1) {\n        let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;\n        let openRanges = cursor.openStart;\n        for (;;) {\n            let curTo = Math.min(cursor.to, to);\n            if (cursor.point) {\n                let active = cursor.activeForPoint(cursor.to);\n                let openCount = cursor.pointFrom < from ? active.length + 1\n                    : cursor.point.startSide < 0 ? active.length\n                        : Math.min(active.length, openRanges);\n                iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);\n                openRanges = Math.min(cursor.openEnd(curTo), active.length);\n            }\n            else if (curTo > pos) {\n                iterator.span(pos, curTo, cursor.active, openRanges);\n                openRanges = cursor.openEnd(curTo);\n            }\n            if (cursor.to > to)\n                return openRanges + (cursor.point && cursor.to > to ? 1 : 0);\n            pos = cursor.to;\n            cursor.next();\n        }\n    }\n    /**\n    Create a range set for the given range or array of ranges. By\n    default, this expects the ranges to be _sorted_ (by start\n    position and, if two start at the same position,\n    `value.startSide`). You can pass `true` as second argument to\n    cause the method to sort them.\n    */\n    static of(ranges, sort = false) {\n        let build = new RangeSetBuilder();\n        for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)\n            build.add(range.from, range.to, range.value);\n        return build.finish();\n    }\n    /**\n    Join an array of range sets into a single set.\n    */\n    static join(sets) {\n        if (!sets.length)\n            return RangeSet.empty;\n        let result = sets[sets.length - 1];\n        for (let i = sets.length - 2; i >= 0; i--) {\n            for (let layer = sets[i]; layer != RangeSet.empty; layer = layer.nextLayer)\n                result = new RangeSet(layer.chunkPos, layer.chunk, result, Math.max(layer.maxPoint, result.maxPoint));\n        }\n        return result;\n    }\n}\n/**\nThe empty set of ranges.\n*/\nRangeSet.empty = /*@__PURE__*/new RangeSet([], [], null, -1);\nfunction lazySort(ranges) {\n    if (ranges.length > 1)\n        for (let prev = ranges[0], i = 1; i < ranges.length; i++) {\n            let cur = ranges[i];\n            if (cmpRange(prev, cur) > 0)\n                return ranges.slice().sort(cmpRange);\n            prev = cur;\n        }\n    return ranges;\n}\nRangeSet.empty.nextLayer = RangeSet.empty;\n/**\nA range set builder is a data structure that helps build up a\n[range set](https://codemirror.net/6/docs/ref/#state.RangeSet) directly, without first allocating\nan array of [`Range`](https://codemirror.net/6/docs/ref/#state.Range) objects.\n*/\nclass RangeSetBuilder {\n    finishChunk(newArrays) {\n        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n        this.chunkPos.push(this.chunkStart);\n        this.chunkStart = -1;\n        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n        this.maxPoint = -1;\n        if (newArrays) {\n            this.from = [];\n            this.to = [];\n            this.value = [];\n        }\n    }\n    /**\n    Create an empty builder.\n    */\n    constructor() {\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunkStart = -1;\n        this.last = null;\n        this.lastFrom = -1000000000 /* C.Far */;\n        this.lastTo = -1000000000 /* C.Far */;\n        this.from = [];\n        this.to = [];\n        this.value = [];\n        this.maxPoint = -1;\n        this.setMaxPoint = -1;\n        this.nextLayer = null;\n    }\n    /**\n    Add a range. Ranges should be added in sorted (by `from` and\n    `value.startSide`) order.\n    */\n    add(from, to, value) {\n        if (!this.addInner(from, to, value))\n            (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);\n    }\n    /**\n    @internal\n    */\n    addInner(from, to, value) {\n        let diff = from - this.lastTo || value.startSide - this.last.endSide;\n        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)\n            throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n        if (diff < 0)\n            return false;\n        if (this.from.length == 250 /* C.ChunkSize */)\n            this.finishChunk(true);\n        if (this.chunkStart < 0)\n            this.chunkStart = from;\n        this.from.push(from - this.chunkStart);\n        this.to.push(to - this.chunkStart);\n        this.last = value;\n        this.lastFrom = from;\n        this.lastTo = to;\n        this.value.push(value);\n        if (value.point)\n            this.maxPoint = Math.max(this.maxPoint, to - from);\n        return true;\n    }\n    /**\n    @internal\n    */\n    addChunk(from, chunk) {\n        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)\n            return false;\n        if (this.from.length)\n            this.finishChunk(true);\n        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n        this.chunks.push(chunk);\n        this.chunkPos.push(from);\n        let last = chunk.value.length - 1;\n        this.last = chunk.value[last];\n        this.lastFrom = chunk.from[last] + from;\n        this.lastTo = chunk.to[last] + from;\n        return true;\n    }\n    /**\n    Finish the range set. Returns the new set. The builder can't be\n    used anymore after this has been called.\n    */\n    finish() { return this.finishInner(RangeSet.empty); }\n    /**\n    @internal\n    */\n    finishInner(next) {\n        if (this.from.length)\n            this.finishChunk(false);\n        if (this.chunks.length == 0)\n            return next;\n        let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n        this.from = null; // Make sure further `add` calls produce errors\n        return result;\n    }\n}\nfunction findSharedChunks(a, b, textDiff) {\n    let inA = new Map();\n    for (let set of a)\n        for (let i = 0; i < set.chunk.length; i++)\n            if (set.chunk[i].maxPoint <= 0)\n                inA.set(set.chunk[i], set.chunkPos[i]);\n    let shared = new Set();\n    for (let set of b)\n        for (let i = 0; i < set.chunk.length; i++) {\n            let known = inA.get(set.chunk[i]);\n            if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] &&\n                !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length)))\n                shared.add(set.chunk[i]);\n        }\n    return shared;\n}\nclass LayerCursor {\n    constructor(layer, skip, minPoint, rank = 0) {\n        this.layer = layer;\n        this.skip = skip;\n        this.minPoint = minPoint;\n        this.rank = rank;\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    get endSide() { return this.value ? this.value.endSide : 0; }\n    goto(pos, side = -1000000000 /* C.Far */) {\n        this.chunkIndex = this.rangeIndex = 0;\n        this.gotoInner(pos, side, false);\n        return this;\n    }\n    gotoInner(pos, side, forward) {\n        while (this.chunkIndex < this.layer.chunk.length) {\n            let next = this.layer.chunk[this.chunkIndex];\n            if (!(this.skip && this.skip.has(next) ||\n                this.layer.chunkEnd(this.chunkIndex) < pos ||\n                next.maxPoint < this.minPoint))\n                break;\n            this.chunkIndex++;\n            forward = false;\n        }\n        if (this.chunkIndex < this.layer.chunk.length) {\n            let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);\n            if (!forward || this.rangeIndex < rangeIndex)\n                this.setRangeIndex(rangeIndex);\n        }\n        this.next();\n    }\n    forward(pos, side) {\n        if ((this.to - pos || this.endSide - side) < 0)\n            this.gotoInner(pos, side, true);\n    }\n    next() {\n        for (;;) {\n            if (this.chunkIndex == this.layer.chunk.length) {\n                this.from = this.to = 1000000000 /* C.Far */;\n                this.value = null;\n                break;\n            }\n            else {\n                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];\n                let from = chunkPos + chunk.from[this.rangeIndex];\n                this.from = from;\n                this.to = chunkPos + chunk.to[this.rangeIndex];\n                this.value = chunk.value[this.rangeIndex];\n                this.setRangeIndex(this.rangeIndex + 1);\n                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)\n                    break;\n            }\n        }\n    }\n    setRangeIndex(index) {\n        if (index == this.layer.chunk[this.chunkIndex].value.length) {\n            this.chunkIndex++;\n            if (this.skip) {\n                while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))\n                    this.chunkIndex++;\n            }\n            this.rangeIndex = 0;\n        }\n        else {\n            this.rangeIndex = index;\n        }\n    }\n    nextChunk() {\n        this.chunkIndex++;\n        this.rangeIndex = 0;\n        this.next();\n    }\n    compare(other) {\n        return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank ||\n            this.to - other.to || this.endSide - other.endSide;\n    }\n}\nclass HeapCursor {\n    constructor(heap) {\n        this.heap = heap;\n    }\n    static from(sets, skip = null, minPoint = -1) {\n        let heap = [];\n        for (let i = 0; i < sets.length; i++) {\n            for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {\n                if (cur.maxPoint >= minPoint)\n                    heap.push(new LayerCursor(cur, skip, minPoint, i));\n            }\n        }\n        return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    goto(pos, side = -1000000000 /* C.Far */) {\n        for (let cur of this.heap)\n            cur.goto(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        for (let cur of this.heap)\n            cur.forward(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        if ((this.to - pos || this.value.endSide - side) < 0)\n            this.next();\n    }\n    next() {\n        if (this.heap.length == 0) {\n            this.from = this.to = 1000000000 /* C.Far */;\n            this.value = null;\n            this.rank = -1;\n        }\n        else {\n            let top = this.heap[0];\n            this.from = top.from;\n            this.to = top.to;\n            this.value = top.value;\n            this.rank = top.rank;\n            if (top.value)\n                top.next();\n            heapBubble(this.heap, 0);\n        }\n    }\n}\nfunction heapBubble(heap, index) {\n    for (let cur = heap[index];;) {\n        let childIndex = (index << 1) + 1;\n        if (childIndex >= heap.length)\n            break;\n        let child = heap[childIndex];\n        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n            child = heap[childIndex + 1];\n            childIndex++;\n        }\n        if (cur.compare(child) < 0)\n            break;\n        heap[childIndex] = cur;\n        heap[index] = child;\n        index = childIndex;\n    }\n}\nclass SpanCursor {\n    constructor(sets, skip, minPoint) {\n        this.minPoint = minPoint;\n        this.active = [];\n        this.activeTo = [];\n        this.activeRank = [];\n        this.minActive = -1;\n        // A currently active point range, if any\n        this.point = null;\n        this.pointFrom = 0;\n        this.pointRank = 0;\n        this.to = -1000000000 /* C.Far */;\n        this.endSide = 0;\n        // The amount of open active ranges at the start of the iterator.\n        // Not including points.\n        this.openStart = -1;\n        this.cursor = HeapCursor.from(sets, skip, minPoint);\n    }\n    goto(pos, side = -1000000000 /* C.Far */) {\n        this.cursor.goto(pos, side);\n        this.active.length = this.activeTo.length = this.activeRank.length = 0;\n        this.minActive = -1;\n        this.to = pos;\n        this.endSide = side;\n        this.openStart = -1;\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)\n            this.removeActive(this.minActive);\n        this.cursor.forward(pos, side);\n    }\n    removeActive(index) {\n        remove(this.active, index);\n        remove(this.activeTo, index);\n        remove(this.activeRank, index);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    addActive(trackOpen) {\n        let i = 0, { value, to, rank } = this.cursor;\n        // Organize active marks by rank first, then by size\n        while (i < this.activeRank.length && (rank - this.activeRank[i] || to - this.activeTo[i]) > 0)\n            i++;\n        insert(this.active, i, value);\n        insert(this.activeTo, i, to);\n        insert(this.activeRank, i, rank);\n        if (trackOpen)\n            insert(trackOpen, i, this.cursor.from);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    // After calling this, if `this.point` != null, the next range is a\n    // point. Otherwise, it's a regular range, covered by `this.active`.\n    next() {\n        let from = this.to, wasPoint = this.point;\n        this.point = null;\n        let trackOpen = this.openStart < 0 ? [] : null;\n        for (;;) {\n            let a = this.minActive;\n            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n                if (this.activeTo[a] > from) {\n                    this.to = this.activeTo[a];\n                    this.endSide = this.active[a].endSide;\n                    break;\n                }\n                this.removeActive(a);\n                if (trackOpen)\n                    remove(trackOpen, a);\n            }\n            else if (!this.cursor.value) {\n                this.to = this.endSide = 1000000000 /* C.Far */;\n                break;\n            }\n            else if (this.cursor.from > from) {\n                this.to = this.cursor.from;\n                this.endSide = this.cursor.startSide;\n                break;\n            }\n            else {\n                let nextVal = this.cursor.value;\n                if (!nextVal.point) { // Opening a range\n                    this.addActive(trackOpen);\n                    this.cursor.next();\n                }\n                else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {\n                    // Ignore any non-empty points that end precisely at the end of the prev point\n                    this.cursor.next();\n                }\n                else { // New point\n                    this.point = nextVal;\n                    this.pointFrom = this.cursor.from;\n                    this.pointRank = this.cursor.rank;\n                    this.to = this.cursor.to;\n                    this.endSide = nextVal.endSide;\n                    this.cursor.next();\n                    this.forward(this.to, this.endSide);\n                    break;\n                }\n            }\n        }\n        if (trackOpen) {\n            this.openStart = 0;\n            for (let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--)\n                this.openStart++;\n        }\n    }\n    activeForPoint(to) {\n        if (!this.active.length)\n            return this.active;\n        let active = [];\n        for (let i = this.active.length - 1; i >= 0; i--) {\n            if (this.activeRank[i] < this.pointRank)\n                break;\n            if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)\n                active.push(this.active[i]);\n        }\n        return active.reverse();\n    }\n    openEnd(to) {\n        let open = 0;\n        for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)\n            open++;\n        return open;\n    }\n}\nfunction compare(a, startA, b, startB, length, comparator) {\n    a.goto(startA);\n    b.goto(startB);\n    let endB = startB + length;\n    let pos = startB, dPos = startB - startA;\n    for (;;) {\n        let dEnd = (a.to + dPos) - b.to, diff = dEnd || a.endSide - b.endSide;\n        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);\n        if (a.point || b.point) {\n            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) &&\n                sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to))))\n                comparator.comparePoint(pos, clipEnd, a.point, b.point);\n        }\n        else {\n            if (clipEnd > pos && !sameValues(a.active, b.active))\n                comparator.compareRange(pos, clipEnd, a.active, b.active);\n        }\n        if (end > endB)\n            break;\n        if ((dEnd || a.openEnd != b.openEnd) && comparator.boundChange)\n            comparator.boundChange(end);\n        pos = end;\n        if (diff <= 0)\n            a.next();\n        if (diff >= 0)\n            b.next();\n    }\n}\nfunction sameValues(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] != b[i] && !a[i].eq(b[i]))\n            return false;\n    return true;\n}\nfunction remove(array, index) {\n    for (let i = index, e = array.length - 1; i < e; i++)\n        array[i] = array[i + 1];\n    array.pop();\n}\nfunction insert(array, index, value) {\n    for (let i = array.length - 1; i >= index; i--)\n        array[i + 1] = array[i];\n    array[index] = value;\n}\nfunction findMinIndex(value, array) {\n    let found = -1, foundPos = 1000000000 /* C.Far */;\n    for (let i = 0; i < array.length; i++)\n        if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n            found = i;\n            foundPos = array[i];\n        }\n    return found;\n}\n\n/**\nCount the column position at the given offset into the string,\ntaking extending characters and tab size into account.\n*/\nfunction countColumn(string, tabSize, to = string.length) {\n    let n = 0;\n    for (let i = 0; i < to && i < string.length;) {\n        if (string.charCodeAt(i) == 9) {\n            n += tabSize - (n % tabSize);\n            i++;\n        }\n        else {\n            n++;\n            i = findClusterBreak(string, i);\n        }\n    }\n    return n;\n}\n/**\nFind the offset that corresponds to the given column position in a\nstring, taking extending characters and tab size into account. By\ndefault, the string length is returned when it is too short to\nreach the column. Pass `strict` true to make it return -1 in that\nsituation.\n*/\nfunction findColumn(string, col, tabSize, strict) {\n    for (let i = 0, n = 0;;) {\n        if (n >= col)\n            return i;\n        if (i == string.length)\n            break;\n        n += string.charCodeAt(i) == 9 ? tabSize - (n % tabSize) : 1;\n        i = findClusterBreak(string, i);\n    }\n    return strict === true ? -1 : string.length;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bjb2RlbWlycm9yK3N0YXRlQDYuNS4yL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9zdGF0ZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRjs7QUFFcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEtBQUssd0JBQXdCLFlBQVk7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsR0FBRyxLQUFLLFdBQVc7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLHFCQUFxQjtBQUNyQjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG1DQUFtQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1Q0FBdUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywwQkFBMEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUNBQXVDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw4QkFBOEI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUJBQXlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0RUFBa0I7QUFDN0I7QUFDQSw0QkFBNEI7QUFDNUIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHlCQUF5QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEtBQUssMENBQTBDLEtBQUs7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzQ0FBc0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFCQUFxQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLFlBQVksYUFBYSxPQUFPO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBLGlFQUFpRSxNQUFNLEtBQUssSUFBSSxvQkFBb0IsT0FBTztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx5QkFBeUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxxQkFBcUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHVDQUF1QztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsSUFBSTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFdBQVcsSUFBSSxPQUFPO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFDQUFxQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxXQUFXLDhDQUE4QztBQUN2RyxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0lBQW9JLE9BQU87QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUVBQWlFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywwQ0FBMEM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDLHNDQUFzQyx5QkFBeUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxtQkFBbUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QyxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQywrQkFBK0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsaUNBQWlDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa1giLCJzb3VyY2VzIjpbIi9Vc2Vycy96ZWh1aXB1L215LWRhc2hib2FyZC1hcHAvbm9kZV9tb2R1bGVzLy5wbnBtL0Bjb2RlbWlycm9yK3N0YXRlQDYuNS4yL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9zdGF0ZS9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZpbmRDbHVzdGVyQnJlYWsgYXMgZmluZENsdXN0ZXJCcmVhayQxIH0gZnJvbSAnQG1hcmlqbi9maW5kLWNsdXN0ZXItYnJlYWsnO1xuXG4vKipcblRoZSBkYXRhIHN0cnVjdHVyZSBmb3IgZG9jdW1lbnRzLiBAbm9uYWJzdHJhY3RcbiovXG5jbGFzcyBUZXh0IHtcbiAgICAvKipcbiAgICBHZXQgdGhlIGxpbmUgZGVzY3JpcHRpb24gYXJvdW5kIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGxpbmVBdChwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA8IDAgfHwgcG9zID4gdGhpcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBwb3NpdGlvbiAke3Bvc30gaW4gZG9jdW1lbnQgb2YgbGVuZ3RoICR7dGhpcy5sZW5ndGh9YCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVJbm5lcihwb3MsIGZhbHNlLCAxLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBkZXNjcmlwdGlvbiBmb3IgdGhlIGdpdmVuICgxLWJhc2VkKSBsaW5lIG51bWJlci5cbiAgICAqL1xuICAgIGxpbmUobikge1xuICAgICAgICBpZiAobiA8IDEgfHwgbiA+IHRoaXMubGluZXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBsaW5lIG51bWJlciAke259IGluICR7dGhpcy5saW5lc30tbGluZSBkb2N1bWVudGApO1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lSW5uZXIobiwgdHJ1ZSwgMSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgYSByYW5nZSBvZiB0aGUgdGV4dCB3aXRoIHRoZSBnaXZlbiBjb250ZW50LlxuICAgICovXG4gICAgcmVwbGFjZShmcm9tLCB0bywgdGV4dCkge1xuICAgICAgICBbZnJvbSwgdG9dID0gY2xpcCh0aGlzLCBmcm9tLCB0byk7XG4gICAgICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLmRlY29tcG9zZSgwLCBmcm9tLCBwYXJ0cywgMiAvKiBPcGVuLlRvICovKTtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoKVxuICAgICAgICAgICAgdGV4dC5kZWNvbXBvc2UoMCwgdGV4dC5sZW5ndGgsIHBhcnRzLCAxIC8qIE9wZW4uRnJvbSAqLyB8IDIgLyogT3Blbi5UbyAqLyk7XG4gICAgICAgIHRoaXMuZGVjb21wb3NlKHRvLCB0aGlzLmxlbmd0aCwgcGFydHMsIDEgLyogT3Blbi5Gcm9tICovKTtcbiAgICAgICAgcmV0dXJuIFRleHROb2RlLmZyb20ocGFydHMsIHRoaXMubGVuZ3RoIC0gKHRvIC0gZnJvbSkgKyB0ZXh0Lmxlbmd0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEFwcGVuZCBhbm90aGVyIGRvY3VtZW50IHRvIHRoaXMgb25lLlxuICAgICovXG4gICAgYXBwZW5kKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UodGhpcy5sZW5ndGgsIHRoaXMubGVuZ3RoLCBvdGhlcik7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHJpZXZlIHRoZSB0ZXh0IGJldHdlZW4gdGhlIGdpdmVuIHBvaW50cy5cbiAgICAqL1xuICAgIHNsaWNlKGZyb20sIHRvID0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgW2Zyb20sIHRvXSA9IGNsaXAodGhpcywgZnJvbSwgdG8pO1xuICAgICAgICBsZXQgcGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5kZWNvbXBvc2UoZnJvbSwgdG8sIHBhcnRzLCAwKTtcbiAgICAgICAgcmV0dXJuIFRleHROb2RlLmZyb20ocGFydHMsIHRvIC0gZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGlzIHRleHQgaXMgZXF1YWwgdG8gYW5vdGhlciBpbnN0YW5jZS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlciA9PSB0aGlzKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChvdGhlci5sZW5ndGggIT0gdGhpcy5sZW5ndGggfHwgb3RoZXIubGluZXMgIT0gdGhpcy5saW5lcylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zY2FuSWRlbnRpY2FsKG90aGVyLCAxKSwgZW5kID0gdGhpcy5sZW5ndGggLSB0aGlzLnNjYW5JZGVudGljYWwob3RoZXIsIC0xKTtcbiAgICAgICAgbGV0IGEgPSBuZXcgUmF3VGV4dEN1cnNvcih0aGlzKSwgYiA9IG5ldyBSYXdUZXh0Q3Vyc29yKG90aGVyKTtcbiAgICAgICAgZm9yIChsZXQgc2tpcCA9IHN0YXJ0LCBwb3MgPSBzdGFydDs7KSB7XG4gICAgICAgICAgICBhLm5leHQoc2tpcCk7XG4gICAgICAgICAgICBiLm5leHQoc2tpcCk7XG4gICAgICAgICAgICBza2lwID0gMDtcbiAgICAgICAgICAgIGlmIChhLmxpbmVCcmVhayAhPSBiLmxpbmVCcmVhayB8fCBhLmRvbmUgIT0gYi5kb25lIHx8IGEudmFsdWUgIT0gYi52YWx1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBwb3MgKz0gYS52YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoYS5kb25lIHx8IHBvcyA+PSBlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSB0ZXh0LiBXaGVuIGBkaXJgIGlzIGAtMWAsIGl0ZXJhdGlvbiBoYXBwZW5zXG4gICAgZnJvbSBlbmQgdG8gc3RhcnQuIFRoaXMgd2lsbCByZXR1cm4gbGluZXMgYW5kIHRoZSBicmVha3MgYmV0d2VlblxuICAgIHRoZW0gYXMgc2VwYXJhdGUgc3RyaW5ncy5cbiAgICAqL1xuICAgIGl0ZXIoZGlyID0gMSkgeyByZXR1cm4gbmV3IFJhd1RleHRDdXJzb3IodGhpcywgZGlyKTsgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciBhIHJhbmdlIG9mIHRoZSB0ZXh0LiBXaGVuIGBmcm9tYCA+IGB0b2AsIHRoZVxuICAgIGl0ZXJhdG9yIHdpbGwgcnVuIGluIHJldmVyc2UuXG4gICAgKi9cbiAgICBpdGVyUmFuZ2UoZnJvbSwgdG8gPSB0aGlzLmxlbmd0aCkgeyByZXR1cm4gbmV3IFBhcnRpYWxUZXh0Q3Vyc29yKHRoaXMsIGZyb20sIHRvKTsgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIGN1cnNvciB0aGF0IGl0ZXJhdGVzIG92ZXIgdGhlIGdpdmVuIHJhbmdlIG9mIGxpbmVzLFxuICAgIF93aXRob3V0XyByZXR1cm5pbmcgdGhlIGxpbmUgYnJlYWtzIGJldHdlZW4sIGFuZCB5aWVsZGluZyBlbXB0eVxuICAgIHN0cmluZ3MgZm9yIGVtcHR5IGxpbmVzLlxuICAgIFxuICAgIFdoZW4gYGZyb21gIGFuZCBgdG9gIGFyZSBnaXZlbiwgdGhleSBzaG91bGQgYmUgMS1iYXNlZCBsaW5lIG51bWJlcnMuXG4gICAgKi9cbiAgICBpdGVyTGluZXMoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGlubmVyO1xuICAgICAgICBpZiAoZnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpbm5lciA9IHRoaXMuaXRlcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICAgICAgdG8gPSB0aGlzLmxpbmVzICsgMTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMubGluZShmcm9tKS5mcm9tO1xuICAgICAgICAgICAgaW5uZXIgPSB0aGlzLml0ZXJSYW5nZShzdGFydCwgTWF0aC5tYXgoc3RhcnQsIHRvID09IHRoaXMubGluZXMgKyAxID8gdGhpcy5sZW5ndGggOiB0byA8PSAxID8gMCA6IHRoaXMubGluZSh0byAtIDEpLnRvKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lQ3Vyc29yKGlubmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIHRoZSBkb2N1bWVudCBhcyBhIHN0cmluZywgdXNpbmcgbmV3bGluZSBjaGFyYWN0ZXJzIHRvXG4gICAgc2VwYXJhdGUgbGluZXMuXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMuc2xpY2VTdHJpbmcoMCk7IH1cbiAgICAvKipcbiAgICBDb252ZXJ0IHRoZSBkb2N1bWVudCB0byBhbiBhcnJheSBvZiBsaW5lcyAod2hpY2ggY2FuIGJlXG4gICAgZGVzZXJpYWxpemVkIGFnYWluIHZpYSBbYFRleHQub2ZgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRleHReb2YpKS5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IGxpbmVzID0gW107XG4gICAgICAgIHRoaXMuZmxhdHRlbihsaW5lcyk7XG4gICAgICAgIHJldHVybiBsaW5lcztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGBUZXh0YCBpbnN0YW5jZSBmb3IgdGhlIGdpdmVuIGFycmF5IG9mIGxpbmVzLlxuICAgICovXG4gICAgc3RhdGljIG9mKHRleHQpIHtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkEgZG9jdW1lbnQgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBsaW5lXCIpO1xuICAgICAgICBpZiAodGV4dC5sZW5ndGggPT0gMSAmJiAhdGV4dFswXSlcbiAgICAgICAgICAgIHJldHVybiBUZXh0LmVtcHR5O1xuICAgICAgICByZXR1cm4gdGV4dC5sZW5ndGggPD0gMzIgLyogVHJlZS5CcmFuY2ggKi8gPyBuZXcgVGV4dExlYWYodGV4dCkgOiBUZXh0Tm9kZS5mcm9tKFRleHRMZWFmLnNwbGl0KHRleHQsIFtdKSk7XG4gICAgfVxufVxuLy8gTGVhdmVzIHN0b3JlIGFuIGFycmF5IG9mIGxpbmUgc3RyaW5ncy4gVGhlcmUgYXJlIGFsd2F5cyBsaW5lIGJyZWFrc1xuLy8gYmV0d2VlbiB0aGVzZSBzdHJpbmdzLiBMZWF2ZXMgYXJlIGxpbWl0ZWQgaW4gc2l6ZSBhbmQgaGF2ZSB0byBiZVxuLy8gY29udGFpbmVkIGluIFRleHROb2RlIGluc3RhbmNlcyBmb3IgYmlnZ2VyIGRvY3VtZW50cy5cbmNsYXNzIFRleHRMZWFmIGV4dGVuZHMgVGV4dCB7XG4gICAgY29uc3RydWN0b3IodGV4dCwgbGVuZ3RoID0gdGV4dExlbmd0aCh0ZXh0KSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB9XG4gICAgZ2V0IGxpbmVzKCkgeyByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aDsgfVxuICAgIGdldCBjaGlsZHJlbigpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBsaW5lSW5uZXIodGFyZ2V0LCBpc0xpbmUsIGxpbmUsIG9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0cmluZyA9IHRoaXMudGV4dFtpXSwgZW5kID0gb2Zmc2V0ICsgc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICgoaXNMaW5lID8gbGluZSA6IGVuZCkgPj0gdGFyZ2V0KVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTGluZShvZmZzZXQsIGVuZCwgbGluZSwgc3RyaW5nKTtcbiAgICAgICAgICAgIG9mZnNldCA9IGVuZCArIDE7XG4gICAgICAgICAgICBsaW5lKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVjb21wb3NlKGZyb20sIHRvLCB0YXJnZXQsIG9wZW4pIHtcbiAgICAgICAgbGV0IHRleHQgPSBmcm9tIDw9IDAgJiYgdG8gPj0gdGhpcy5sZW5ndGggPyB0aGlzXG4gICAgICAgICAgICA6IG5ldyBUZXh0TGVhZihzbGljZVRleHQodGhpcy50ZXh0LCBmcm9tLCB0byksIE1hdGgubWluKHRvLCB0aGlzLmxlbmd0aCkgLSBNYXRoLm1heCgwLCBmcm9tKSk7XG4gICAgICAgIGlmIChvcGVuICYgMSAvKiBPcGVuLkZyb20gKi8pIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gdGFyZ2V0LnBvcCgpO1xuICAgICAgICAgICAgbGV0IGpvaW5lZCA9IGFwcGVuZFRleHQodGV4dC50ZXh0LCBwcmV2LnRleHQuc2xpY2UoKSwgMCwgdGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKGpvaW5lZC5sZW5ndGggPD0gMzIgLyogVHJlZS5CcmFuY2ggKi8pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVGV4dExlYWYoam9pbmVkLCBwcmV2Lmxlbmd0aCArIHRleHQubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbWlkID0gam9pbmVkLmxlbmd0aCA+PiAxO1xuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUZXh0TGVhZihqb2luZWQuc2xpY2UoMCwgbWlkKSksIG5ldyBUZXh0TGVhZihqb2luZWQuc2xpY2UobWlkKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2godGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShmcm9tLCB0bywgdGV4dCkge1xuICAgICAgICBpZiAoISh0ZXh0IGluc3RhbmNlb2YgVGV4dExlYWYpKVxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnJlcGxhY2UoZnJvbSwgdG8sIHRleHQpO1xuICAgICAgICBbZnJvbSwgdG9dID0gY2xpcCh0aGlzLCBmcm9tLCB0byk7XG4gICAgICAgIGxldCBsaW5lcyA9IGFwcGVuZFRleHQodGhpcy50ZXh0LCBhcHBlbmRUZXh0KHRleHQudGV4dCwgc2xpY2VUZXh0KHRoaXMudGV4dCwgMCwgZnJvbSkpLCB0byk7XG4gICAgICAgIGxldCBuZXdMZW4gPSB0aGlzLmxlbmd0aCArIHRleHQubGVuZ3RoIC0gKHRvIC0gZnJvbSk7XG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPD0gMzIgLyogVHJlZS5CcmFuY2ggKi8pXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRMZWFmKGxpbmVzLCBuZXdMZW4pO1xuICAgICAgICByZXR1cm4gVGV4dE5vZGUuZnJvbShUZXh0TGVhZi5zcGxpdChsaW5lcywgW10pLCBuZXdMZW4pO1xuICAgIH1cbiAgICBzbGljZVN0cmluZyhmcm9tLCB0byA9IHRoaXMubGVuZ3RoLCBsaW5lU2VwID0gXCJcXG5cIikge1xuICAgICAgICBbZnJvbSwgdG9dID0gY2xpcCh0aGlzLCBmcm9tLCB0byk7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMDsgcG9zIDw9IHRvICYmIGkgPCB0aGlzLnRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gdGhpcy50ZXh0W2ldLCBlbmQgPSBwb3MgKyBsaW5lLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwb3MgPiBmcm9tICYmIGkpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmVTZXA7XG4gICAgICAgICAgICBpZiAoZnJvbSA8IGVuZCAmJiB0byA+IHBvcylcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbGluZS5zbGljZShNYXRoLm1heCgwLCBmcm9tIC0gcG9zKSwgdG8gLSBwb3MpO1xuICAgICAgICAgICAgcG9zID0gZW5kICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmbGF0dGVuKHRhcmdldCkge1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRoaXMudGV4dClcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKGxpbmUpO1xuICAgIH1cbiAgICBzY2FuSWRlbnRpY2FsKCkgeyByZXR1cm4gMDsgfVxuICAgIHN0YXRpYyBzcGxpdCh0ZXh0LCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IHBhcnQgPSBbXSwgbGVuID0gLTE7XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGV4dCkge1xuICAgICAgICAgICAgcGFydC5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgbGVuICs9IGxpbmUubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PSAzMiAvKiBUcmVlLkJyYW5jaCAqLykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUZXh0TGVhZihwYXJ0LCBsZW4pKTtcbiAgICAgICAgICAgICAgICBwYXJ0ID0gW107XG4gICAgICAgICAgICAgICAgbGVuID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbiA+IC0xKVxuICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRleHRMZWFmKHBhcnQsIGxlbikpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbn1cbi8vIE5vZGVzIHByb3ZpZGUgdGhlIHRyZWUgc3RydWN0dXJlIG9mIHRoZSBgVGV4dGAgdHlwZS4gVGhleSBzdG9yZSBhXG4vLyBudW1iZXIgb2Ygb3RoZXIgbm9kZXMgb3IgbGVhdmVzLCB0YWtpbmcgY2FyZSB0byBiYWxhbmNlIHRoZW1zZWx2ZXNcbi8vIG9uIGNoYW5nZXMuIFRoZXJlIGFyZSBpbXBsaWVkIGxpbmUgYnJlYWtzIF9iZXR3ZWVuXyB0aGUgY2hpbGRyZW4gb2Zcbi8vIGEgbm9kZSAoYnV0IG5vdCBiZWZvcmUgdGhlIGZpcnN0IG9yIGFmdGVyIHRoZSBsYXN0IGNoaWxkKS5cbmNsYXNzIFRleHROb2RlIGV4dGVuZHMgVGV4dCB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW4sIGxlbmd0aCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLmxpbmVzID0gMDtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICB0aGlzLmxpbmVzICs9IGNoaWxkLmxpbmVzO1xuICAgIH1cbiAgICBsaW5lSW5uZXIodGFyZ2V0LCBpc0xpbmUsIGxpbmUsIG9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gb2Zmc2V0ICsgY2hpbGQubGVuZ3RoLCBlbmRMaW5lID0gbGluZSArIGNoaWxkLmxpbmVzIC0gMTtcbiAgICAgICAgICAgIGlmICgoaXNMaW5lID8gZW5kTGluZSA6IGVuZCkgPj0gdGFyZ2V0KVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5saW5lSW5uZXIodGFyZ2V0LCBpc0xpbmUsIGxpbmUsIG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQgKyAxO1xuICAgICAgICAgICAgbGluZSA9IGVuZExpbmUgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlY29tcG9zZShmcm9tLCB0bywgdGFyZ2V0LCBvcGVuKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBwb3MgPD0gdG8gJiYgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChmcm9tIDw9IGVuZCAmJiB0byA+PSBwb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRPcGVuID0gb3BlbiAmICgocG9zIDw9IGZyb20gPyAxIC8qIE9wZW4uRnJvbSAqLyA6IDApIHwgKGVuZCA+PSB0byA/IDIgLyogT3Blbi5UbyAqLyA6IDApKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zID49IGZyb20gJiYgZW5kIDw9IHRvICYmICFjaGlsZE9wZW4pXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRlY29tcG9zZShmcm9tIC0gcG9zLCB0byAtIHBvcywgdGFyZ2V0LCBjaGlsZE9wZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gZW5kICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGZyb20sIHRvLCB0ZXh0KSB7XG4gICAgICAgIFtmcm9tLCB0b10gPSBjbGlwKHRoaXMsIGZyb20sIHRvKTtcbiAgICAgICAgaWYgKHRleHQubGluZXMgPCB0aGlzLmxpbmVzKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gcG9zICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogaWYgdGhlIGNoYW5nZSBvbmx5IGFmZmVjdHMgb25lIGNoaWxkIGFuZCB0aGVcbiAgICAgICAgICAgICAgICAvLyBjaGlsZCdzIHNpemUgcmVtYWlucyBpbiB0aGUgYWNjZXB0YWJsZSByYW5nZSwgb25seSB1cGRhdGVcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGNoaWxkXG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPj0gcG9zICYmIHRvIDw9IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdXBkYXRlZCA9IGNoaWxkLnJlcGxhY2UoZnJvbSAtIHBvcywgdG8gLSBwb3MsIHRleHQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG90YWxMaW5lcyA9IHRoaXMubGluZXMgLSBjaGlsZC5saW5lcyArIHVwZGF0ZWQubGluZXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVkLmxpbmVzIDwgKHRvdGFsTGluZXMgPj4gKDUgLyogVHJlZS5CcmFuY2hTaGlmdCAqLyAtIDEpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5saW5lcyA+ICh0b3RhbExpbmVzID4+ICg1IC8qIFRyZWUuQnJhbmNoU2hpZnQgKi8gKyAxKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb3B5ID0gdGhpcy5jaGlsZHJlbi5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weVtpXSA9IHVwZGF0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRleHROb2RlKGNvcHksIHRoaXMubGVuZ3RoIC0gKHRvIC0gZnJvbSkgKyB0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnJlcGxhY2UocG9zLCBlbmQsIHVwZGF0ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3MgPSBlbmQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIucmVwbGFjZShmcm9tLCB0bywgdGV4dCk7XG4gICAgfVxuICAgIHNsaWNlU3RyaW5nKGZyb20sIHRvID0gdGhpcy5sZW5ndGgsIGxpbmVTZXAgPSBcIlxcblwiKSB7XG4gICAgICAgIFtmcm9tLCB0b10gPSBjbGlwKHRoaXMsIGZyb20sIHRvKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGggJiYgcG9zIDw9IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwb3MgPiBmcm9tICYmIGkpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmVTZXA7XG4gICAgICAgICAgICBpZiAoZnJvbSA8IGVuZCAmJiB0byA+IHBvcylcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gY2hpbGQuc2xpY2VTdHJpbmcoZnJvbSAtIHBvcywgdG8gLSBwb3MsIGxpbmVTZXApO1xuICAgICAgICAgICAgcG9zID0gZW5kICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmbGF0dGVuKHRhcmdldCkge1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKVxuICAgICAgICAgICAgY2hpbGQuZmxhdHRlbih0YXJnZXQpO1xuICAgIH1cbiAgICBzY2FuSWRlbnRpY2FsKG90aGVyLCBkaXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBUZXh0Tm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgICAgIGxldCBbaUEsIGlCLCBlQSwgZUJdID0gZGlyID4gMCA/IFswLCAwLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCwgb3RoZXIuY2hpbGRyZW4ubGVuZ3RoXVxuICAgICAgICAgICAgOiBbdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxLCBvdGhlci5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgLTFdO1xuICAgICAgICBmb3IgKDs7IGlBICs9IGRpciwgaUIgKz0gZGlyKSB7XG4gICAgICAgICAgICBpZiAoaUEgPT0gZUEgfHwgaUIgPT0gZUIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgICAgIGxldCBjaEEgPSB0aGlzLmNoaWxkcmVuW2lBXSwgY2hCID0gb3RoZXIuY2hpbGRyZW5baUJdO1xuICAgICAgICAgICAgaWYgKGNoQSAhPSBjaEIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aCArIGNoQS5zY2FuSWRlbnRpY2FsKGNoQiwgZGlyKTtcbiAgICAgICAgICAgIGxlbmd0aCArPSBjaEEubGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZnJvbShjaGlsZHJlbiwgbGVuZ3RoID0gY2hpbGRyZW4ucmVkdWNlKChsLCBjaCkgPT4gbCArIGNoLmxlbmd0aCArIDEsIC0xKSkge1xuICAgICAgICBsZXQgbGluZXMgPSAwO1xuICAgICAgICBmb3IgKGxldCBjaCBvZiBjaGlsZHJlbilcbiAgICAgICAgICAgIGxpbmVzICs9IGNoLmxpbmVzO1xuICAgICAgICBpZiAobGluZXMgPCAzMiAvKiBUcmVlLkJyYW5jaCAqLykge1xuICAgICAgICAgICAgbGV0IGZsYXQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGNoIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGNoLmZsYXR0ZW4oZmxhdCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRMZWFmKGZsYXQsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNodW5rID0gTWF0aC5tYXgoMzIgLyogVHJlZS5CcmFuY2ggKi8sIGxpbmVzID4+IDUgLyogVHJlZS5CcmFuY2hTaGlmdCAqLyksIG1heENodW5rID0gY2h1bmsgPDwgMSwgbWluQ2h1bmsgPSBjaHVuayA+PiAxO1xuICAgICAgICBsZXQgY2h1bmtlZCA9IFtdLCBjdXJyZW50TGluZXMgPSAwLCBjdXJyZW50TGVuID0gLTEsIGN1cnJlbnRDaHVuayA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBhZGQoY2hpbGQpIHtcbiAgICAgICAgICAgIGxldCBsYXN0O1xuICAgICAgICAgICAgaWYgKGNoaWxkLmxpbmVzID4gbWF4Q2h1bmsgJiYgY2hpbGQgaW5zdGFuY2VvZiBUZXh0Tm9kZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG5vZGUgb2YgY2hpbGQuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgICAgIGFkZChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLmxpbmVzID4gbWluQ2h1bmsgJiYgKGN1cnJlbnRMaW5lcyA+IG1pbkNodW5rIHx8ICFjdXJyZW50TGluZXMpKSB7XG4gICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICBjaHVua2VkLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUZXh0TGVhZiAmJiBjdXJyZW50TGluZXMgJiZcbiAgICAgICAgICAgICAgICAobGFzdCA9IGN1cnJlbnRDaHVua1tjdXJyZW50Q2h1bmsubGVuZ3RoIC0gMV0pIGluc3RhbmNlb2YgVGV4dExlYWYgJiZcbiAgICAgICAgICAgICAgICBjaGlsZC5saW5lcyArIGxhc3QubGluZXMgPD0gMzIgLyogVHJlZS5CcmFuY2ggKi8pIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TGluZXMgKz0gY2hpbGQubGluZXM7XG4gICAgICAgICAgICAgICAgY3VycmVudExlbiArPSBjaGlsZC5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDaHVua1tjdXJyZW50Q2h1bmsubGVuZ3RoIC0gMV0gPSBuZXcgVGV4dExlYWYobGFzdC50ZXh0LmNvbmNhdChjaGlsZC50ZXh0KSwgbGFzdC5sZW5ndGggKyAxICsgY2hpbGQubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TGluZXMgKyBjaGlsZC5saW5lcyA+IGNodW5rKVxuICAgICAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lcyArPSBjaGlsZC5saW5lcztcbiAgICAgICAgICAgICAgICBjdXJyZW50TGVuICs9IGNoaWxkLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgY3VycmVudENodW5rLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRMaW5lcyA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNodW5rZWQucHVzaChjdXJyZW50Q2h1bmsubGVuZ3RoID09IDEgPyBjdXJyZW50Q2h1bmtbMF0gOiBUZXh0Tm9kZS5mcm9tKGN1cnJlbnRDaHVuaywgY3VycmVudExlbikpO1xuICAgICAgICAgICAgY3VycmVudExlbiA9IC0xO1xuICAgICAgICAgICAgY3VycmVudExpbmVzID0gY3VycmVudENodW5rLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICBhZGQoY2hpbGQpO1xuICAgICAgICBmbHVzaCgpO1xuICAgICAgICByZXR1cm4gY2h1bmtlZC5sZW5ndGggPT0gMSA/IGNodW5rZWRbMF0gOiBuZXcgVGV4dE5vZGUoY2h1bmtlZCwgbGVuZ3RoKTtcbiAgICB9XG59XG5UZXh0LmVtcHR5ID0gLypAX19QVVJFX18qL25ldyBUZXh0TGVhZihbXCJcIl0sIDApO1xuZnVuY3Rpb24gdGV4dExlbmd0aCh0ZXh0KSB7XG4gICAgbGV0IGxlbmd0aCA9IC0xO1xuICAgIGZvciAobGV0IGxpbmUgb2YgdGV4dClcbiAgICAgICAgbGVuZ3RoICs9IGxpbmUubGVuZ3RoICsgMTtcbiAgICByZXR1cm4gbGVuZ3RoO1xufVxuZnVuY3Rpb24gYXBwZW5kVGV4dCh0ZXh0LCB0YXJnZXQsIGZyb20gPSAwLCB0byA9IDFlOSkge1xuICAgIGZvciAobGV0IHBvcyA9IDAsIGkgPSAwLCBmaXJzdCA9IHRydWU7IGkgPCB0ZXh0Lmxlbmd0aCAmJiBwb3MgPD0gdG87IGkrKykge1xuICAgICAgICBsZXQgbGluZSA9IHRleHRbaV0sIGVuZCA9IHBvcyArIGxpbmUubGVuZ3RoO1xuICAgICAgICBpZiAoZW5kID49IGZyb20pIHtcbiAgICAgICAgICAgIGlmIChlbmQgPiB0bylcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgwLCB0byAtIHBvcyk7XG4gICAgICAgICAgICBpZiAocG9zIDwgZnJvbSlcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZShmcm9tIC0gcG9zKTtcbiAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICAgIHRhcmdldFt0YXJnZXQubGVuZ3RoIC0gMV0gKz0gbGluZTtcbiAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBzbGljZVRleHQodGV4dCwgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gYXBwZW5kVGV4dCh0ZXh0LCBbXCJcIl0sIGZyb20sIHRvKTtcbn1cbmNsYXNzIFJhd1RleHRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIGRpciA9IDEpIHtcbiAgICAgICAgdGhpcy5kaXIgPSBkaXI7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxpbmVCcmVhayA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFt0ZXh0XTtcbiAgICAgICAgdGhpcy5vZmZzZXRzID0gW2RpciA+IDAgPyAxIDogKHRleHQgaW5zdGFuY2VvZiBUZXh0TGVhZiA/IHRleHQudGV4dC5sZW5ndGggOiB0ZXh0LmNoaWxkcmVuLmxlbmd0aCkgPDwgMV07XG4gICAgfVxuICAgIG5leHRJbm5lcihza2lwLCBkaXIpIHtcbiAgICAgICAgdGhpcy5kb25lID0gdGhpcy5saW5lQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLm5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy5ub2Rlc1tsYXN0XSwgb2Zmc2V0VmFsdWUgPSB0aGlzLm9mZnNldHNbbGFzdF0sIG9mZnNldCA9IG9mZnNldFZhbHVlID4+IDE7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHRvcCBpbnN0YW5jZW9mIFRleHRMZWFmID8gdG9wLnRleHQubGVuZ3RoIDogdG9wLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gKGRpciA+IDAgPyBzaXplIDogMCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRpciA+IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0c1tsYXN0IC0gMV0rKztcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0cy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChvZmZzZXRWYWx1ZSAmIDEpID09IChkaXIgPiAwID8gMCA6IDEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3RdICs9IGRpcjtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZUJyZWFrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBza2lwLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b3AgaW5zdGFuY2VvZiBUZXh0TGVhZikge1xuICAgICAgICAgICAgICAgIC8vIE1vdmUgdG8gdGhlIG5leHQgc3RyaW5nXG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0b3AudGV4dFtvZmZzZXQgKyAoZGlyIDwgMCA/IC0xIDogMCldO1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0c1tsYXN0XSArPSBkaXI7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQubGVuZ3RoID4gTWF0aC5tYXgoMCwgc2tpcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHNraXAgPT0gMCA/IG5leHQgOiBkaXIgPiAwID8gbmV4dC5zbGljZShza2lwKSA6IG5leHQuc2xpY2UoMCwgbmV4dC5sZW5ndGggLSBza2lwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNraXAgLT0gbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRvcC5jaGlsZHJlbltvZmZzZXQgKyAoZGlyIDwgMCA/IC0xIDogMCldO1xuICAgICAgICAgICAgICAgIGlmIChza2lwID4gbmV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2tpcCAtPSBuZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3RdICs9IGRpcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXIgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3RdLS07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzLnB1c2goZGlyID4gMCA/IDEgOiAobmV4dCBpbnN0YW5jZW9mIFRleHRMZWFmID8gbmV4dC50ZXh0Lmxlbmd0aCA6IG5leHQuY2hpbGRyZW4ubGVuZ3RoKSA8PCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dChza2lwID0gMCkge1xuICAgICAgICBpZiAoc2tpcCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMubmV4dElubmVyKC1za2lwLCAoLXRoaXMuZGlyKSk7XG4gICAgICAgICAgICBza2lwID0gdGhpcy52YWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dElubmVyKHNraXAsIHRoaXMuZGlyKTtcbiAgICB9XG59XG5jbGFzcyBQYXJ0aWFsVGV4dEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gbmV3IFJhd1RleHRDdXJzb3IodGV4dCwgc3RhcnQgPiBlbmQgPyAtMSA6IDEpO1xuICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0ID4gZW5kID8gdGV4dC5sZW5ndGggOiAwO1xuICAgICAgICB0aGlzLmZyb20gPSBNYXRoLm1pbihzdGFydCwgZW5kKTtcbiAgICAgICAgdGhpcy50byA9IE1hdGgubWF4KHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICBuZXh0SW5uZXIoc2tpcCwgZGlyKSB7XG4gICAgICAgIGlmIChkaXIgPCAwID8gdGhpcy5wb3MgPD0gdGhpcy5mcm9tIDogdGhpcy5wb3MgPj0gdGhpcy50bykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgc2tpcCArPSBNYXRoLm1heCgwLCBkaXIgPCAwID8gdGhpcy5wb3MgLSB0aGlzLnRvIDogdGhpcy5mcm9tIC0gdGhpcy5wb3MpO1xuICAgICAgICBsZXQgbGltaXQgPSBkaXIgPCAwID8gdGhpcy5wb3MgLSB0aGlzLmZyb20gOiB0aGlzLnRvIC0gdGhpcy5wb3M7XG4gICAgICAgIGlmIChza2lwID4gbGltaXQpXG4gICAgICAgICAgICBza2lwID0gbGltaXQ7XG4gICAgICAgIGxpbWl0IC09IHNraXA7XG4gICAgICAgIGxldCB7IHZhbHVlIH0gPSB0aGlzLmN1cnNvci5uZXh0KHNraXApO1xuICAgICAgICB0aGlzLnBvcyArPSAodmFsdWUubGVuZ3RoICsgc2tpcCkgKiBkaXI7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZS5sZW5ndGggPD0gbGltaXQgPyB2YWx1ZSA6IGRpciA8IDAgPyB2YWx1ZS5zbGljZSh2YWx1ZS5sZW5ndGggLSBsaW1pdCkgOiB2YWx1ZS5zbGljZSgwLCBsaW1pdCk7XG4gICAgICAgIHRoaXMuZG9uZSA9ICF0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbmV4dChza2lwID0gMCkge1xuICAgICAgICBpZiAoc2tpcCA8IDApXG4gICAgICAgICAgICBza2lwID0gTWF0aC5tYXgoc2tpcCwgdGhpcy5mcm9tIC0gdGhpcy5wb3MpO1xuICAgICAgICBlbHNlIGlmIChza2lwID4gMClcbiAgICAgICAgICAgIHNraXAgPSBNYXRoLm1pbihza2lwLCB0aGlzLnRvIC0gdGhpcy5wb3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0SW5uZXIoc2tpcCwgdGhpcy5jdXJzb3IuZGlyKTtcbiAgICB9XG4gICAgZ2V0IGxpbmVCcmVhaygpIHsgcmV0dXJuIHRoaXMuY3Vyc29yLmxpbmVCcmVhayAmJiB0aGlzLnZhbHVlICE9IFwiXCI7IH1cbn1cbmNsYXNzIExpbmVDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGlubmVyKSB7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lcjtcbiAgICAgICAgdGhpcy5hZnRlckJyZWFrID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgIH1cbiAgICBuZXh0KHNraXAgPSAwKSB7XG4gICAgICAgIGxldCB7IGRvbmUsIGxpbmVCcmVhaywgdmFsdWUgfSA9IHRoaXMuaW5uZXIubmV4dChza2lwKTtcbiAgICAgICAgaWYgKGRvbmUgJiYgdGhpcy5hZnRlckJyZWFrKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJCcmVhayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsaW5lQnJlYWspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFmdGVyQnJlYWspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWZ0ZXJCcmVhayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmFmdGVyQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IGxpbmVCcmVhaygpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5pZiAodHlwZW9mIFN5bWJvbCAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgVGV4dC5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaXRlcigpOyB9O1xuICAgIFJhd1RleHRDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBQYXJ0aWFsVGV4dEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9XG4gICAgICAgIExpbmVDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xufVxuLyoqXG5UaGlzIHR5cGUgZGVzY3JpYmVzIGEgbGluZSBpbiB0aGUgZG9jdW1lbnQuIEl0IGlzIGNyZWF0ZWRcbm9uLWRlbWFuZCB3aGVuIGxpbmVzIGFyZSBbcXVlcmllZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UZXh0LmxpbmVBdCkuXG4qL1xuY2xhc3MgTGluZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gb2YgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUgKF9iZWZvcmVfIHRoZSBsaW5lIGJyZWFrLFxuICAgIG9yIGF0IHRoZSBlbmQgb2YgZG9jdW1lbnQgZm9yIHRoZSBsYXN0IGxpbmUpLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoaXMgbGluZSdzIGxpbmUgbnVtYmVyICgxLWJhc2VkKS5cbiAgICAqL1xuICAgIG51bWJlciwgXG4gICAgLyoqXG4gICAgVGhlIGxpbmUncyBjb250ZW50LlxuICAgICovXG4gICAgdGV4dCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubnVtYmVyID0gbnVtYmVyO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbGVuZ3RoIG9mIHRoZSBsaW5lIChub3QgaW5jbHVkaW5nIGFueSBsaW5lIGJyZWFrIGFmdGVyIGl0KS5cbiAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnRvIC0gdGhpcy5mcm9tOyB9XG59XG5mdW5jdGlvbiBjbGlwKHRleHQsIGZyb20sIHRvKSB7XG4gICAgZnJvbSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRleHQubGVuZ3RoLCBmcm9tKSk7XG4gICAgcmV0dXJuIFtmcm9tLCBNYXRoLm1heChmcm9tLCBNYXRoLm1pbih0ZXh0Lmxlbmd0aCwgdG8pKV07XG59XG5cbi8qKlxuUmV0dXJucyBhIG5leHQgZ3JhcGhlbWUgY2x1c3RlciBicmVhayBfYWZ0ZXJfIChub3QgZXF1YWwgdG8pXG5gcG9zYCwgaWYgYGZvcndhcmRgIGlzIHRydWUsIG9yIGJlZm9yZSBvdGhlcndpc2UuIFJldHVybnMgYHBvc2Bcbml0c2VsZiBpZiBubyBmdXJ0aGVyIGNsdXN0ZXIgYnJlYWsgaXMgYXZhaWxhYmxlIGluIHRoZSBzdHJpbmcuXG5Nb3ZlcyBhY3Jvc3Mgc3Vycm9nYXRlIHBhaXJzLCBleHRlbmRpbmcgY2hhcmFjdGVycyAod2hlblxuYGluY2x1ZGVFeHRlbmRpbmdgIGlzIHRydWUpLCBjaGFyYWN0ZXJzIGpvaW5lZCB3aXRoIHplcm8td2lkdGhcbmpvaW5lcnMsIGFuZCBmbGFnIGVtb2ppLlxuKi9cbmZ1bmN0aW9uIGZpbmRDbHVzdGVyQnJlYWsoc3RyLCBwb3MsIGZvcndhcmQgPSB0cnVlLCBpbmNsdWRlRXh0ZW5kaW5nID0gdHJ1ZSkge1xuICAgIHJldHVybiBmaW5kQ2x1c3RlckJyZWFrJDEoc3RyLCBwb3MsIGZvcndhcmQsIGluY2x1ZGVFeHRlbmRpbmcpO1xufVxuZnVuY3Rpb24gc3Vycm9nYXRlTG93KGNoKSB7IHJldHVybiBjaCA+PSAweERDMDAgJiYgY2ggPCAweEUwMDA7IH1cbmZ1bmN0aW9uIHN1cnJvZ2F0ZUhpZ2goY2gpIHsgcmV0dXJuIGNoID49IDB4RDgwMCAmJiBjaCA8IDB4REMwMDsgfVxuLyoqXG5GaW5kIHRoZSBjb2RlIHBvaW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBpbiBhIHN0cmluZyAobGlrZSB0aGVcbltgY29kZVBvaW50QXRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvY29kZVBvaW50QXQpXG5zdHJpbmcgbWV0aG9kKS5cbiovXG5mdW5jdGlvbiBjb2RlUG9pbnRBdChzdHIsIHBvcykge1xuICAgIGxldCBjb2RlMCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKCFzdXJyb2dhdGVIaWdoKGNvZGUwKSB8fCBwb3MgKyAxID09IHN0ci5sZW5ndGgpXG4gICAgICAgIHJldHVybiBjb2RlMDtcbiAgICBsZXQgY29kZTEgPSBzdHIuY2hhckNvZGVBdChwb3MgKyAxKTtcbiAgICBpZiAoIXN1cnJvZ2F0ZUxvdyhjb2RlMSkpXG4gICAgICAgIHJldHVybiBjb2RlMDtcbiAgICByZXR1cm4gKChjb2RlMCAtIDB4ZDgwMCkgPDwgMTApICsgKGNvZGUxIC0gMHhkYzAwKSArIDB4MTAwMDA7XG59XG4vKipcbkdpdmVuIGEgVW5pY29kZSBjb2RlcG9pbnQsIHJldHVybiB0aGUgSmF2YVNjcmlwdCBzdHJpbmcgdGhhdFxucmVzcHJlc2VudHMgaXQgKGxpa2VcbltgU3RyaW5nLmZyb21Db2RlUG9pbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZnJvbUNvZGVQb2ludCkpLlxuKi9cbmZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoY29kZSkge1xuICAgIGlmIChjb2RlIDw9IDB4ZmZmZilcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgY29kZSAtPSAweDEwMDAwO1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKChjb2RlID4+IDEwKSArIDB4ZDgwMCwgKGNvZGUgJiAxMDIzKSArIDB4ZGMwMCk7XG59XG4vKipcblRoZSBhbW91bnQgb2YgcG9zaXRpb25zIGEgY2hhcmFjdGVyIHRha2VzIHVwIGluIGEgSmF2YVNjcmlwdCBzdHJpbmcuXG4qL1xuZnVuY3Rpb24gY29kZVBvaW50U2l6ZShjb2RlKSB7IHJldHVybiBjb2RlIDwgMHgxMDAwMCA/IDEgOiAyOyB9XG5cbmNvbnN0IERlZmF1bHRTcGxpdCA9IC9cXHJcXG4/fFxcbi87XG4vKipcbkRpc3Rpbmd1aXNoZXMgZGlmZmVyZW50IHdheXMgaW4gd2hpY2ggcG9zaXRpb25zIGNhbiBiZSBtYXBwZWQuXG4qL1xudmFyIE1hcE1vZGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChNYXBNb2RlKSB7XG4gICAgLyoqXG4gICAgTWFwIGEgcG9zaXRpb24gdG8gYSB2YWxpZCBuZXcgcG9zaXRpb24sIGV2ZW4gd2hlbiBpdHMgY29udGV4dFxuICAgIHdhcyBkZWxldGVkLlxuICAgICovXG4gICAgTWFwTW9kZVtNYXBNb2RlW1wiU2ltcGxlXCJdID0gMF0gPSBcIlNpbXBsZVwiO1xuICAgIC8qKlxuICAgIFJldHVybiBudWxsIGlmIGRlbGV0aW9uIGhhcHBlbnMgYWNyb3NzIHRoZSBwb3NpdGlvbi5cbiAgICAqL1xuICAgIE1hcE1vZGVbTWFwTW9kZVtcIlRyYWNrRGVsXCJdID0gMV0gPSBcIlRyYWNrRGVsXCI7XG4gICAgLyoqXG4gICAgUmV0dXJuIG51bGwgaWYgdGhlIGNoYXJhY3RlciBfYmVmb3JlXyB0aGUgcG9zaXRpb24gaXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIE1hcE1vZGVbTWFwTW9kZVtcIlRyYWNrQmVmb3JlXCJdID0gMl0gPSBcIlRyYWNrQmVmb3JlXCI7XG4gICAgLyoqXG4gICAgUmV0dXJuIG51bGwgaWYgdGhlIGNoYXJhY3RlciBfYWZ0ZXJfIHRoZSBwb3NpdGlvbiBpcyBkZWxldGVkLlxuICAgICovXG4gICAgTWFwTW9kZVtNYXBNb2RlW1wiVHJhY2tBZnRlclwiXSA9IDNdID0gXCJUcmFja0FmdGVyXCI7XG5yZXR1cm4gTWFwTW9kZX0pKE1hcE1vZGUgfHwgKE1hcE1vZGUgPSB7fSkpO1xuLyoqXG5BIGNoYW5nZSBkZXNjcmlwdGlvbiBpcyBhIHZhcmlhbnQgb2YgW2NoYW5nZSBzZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0KVxudGhhdCBkb2Vzbid0IHN0b3JlIHRoZSBpbnNlcnRlZCB0ZXh0LiBBcyBzdWNoLCBpdCBjYW4ndCBiZVxuYXBwbGllZCwgYnV0IGlzIGNoZWFwZXIgdG8gc3RvcmUgYW5kIG1hbmlwdWxhdGUuXG4qL1xuY2xhc3MgQ2hhbmdlRGVzYyB7XG4gICAgLy8gU2VjdGlvbnMgYXJlIGVuY29kZWQgYXMgcGFpcnMgb2YgaW50ZWdlcnMuIFRoZSBmaXJzdCBpcyB0aGVcbiAgICAvLyBsZW5ndGggaW4gdGhlIGN1cnJlbnQgZG9jdW1lbnQsIGFuZCB0aGUgc2Vjb25kIGlzIC0xIGZvclxuICAgIC8vIHVuYWZmZWN0ZWQgc2VjdGlvbnMsIGFuZCB0aGUgbGVuZ3RoIG9mIHRoZSByZXBsYWNlbWVudCBjb250ZW50XG4gICAgLy8gb3RoZXJ3aXNlLiBTbyBhbiBpbnNlcnRpb24gd291bGQgYmUgKDAsIG4+MCksIGEgZGVsZXRpb24gKG4+MCxcbiAgICAvLyAwKSwgYW5kIGEgcmVwbGFjZW1lbnQgdHdvIHBvc2l0aXZlIG51bWJlcnMuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNlY3Rpb25zKSB7XG4gICAgICAgIHRoaXMuc2VjdGlvbnMgPSBzZWN0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGxlbmd0aCBvZiB0aGUgZG9jdW1lbnQgYmVmb3JlIHRoZSBjaGFuZ2UuXG4gICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuc2VjdGlvbnNbaV07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBsZW5ndGggb2YgdGhlIGRvY3VtZW50IGFmdGVyIHRoZSBjaGFuZ2UuXG4gICAgKi9cbiAgICBnZXQgbmV3TGVuZ3RoKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgaW5zID0gdGhpcy5zZWN0aW9uc1tpICsgMV07XG4gICAgICAgICAgICByZXN1bHQgKz0gaW5zIDwgMCA/IHRoaXMuc2VjdGlvbnNbaV0gOiBpbnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgRmFsc2Ugd2hlbiB0aGVyZSBhcmUgYWN0dWFsIGNoYW5nZXMgaW4gdGhpcyBzZXQuXG4gICAgKi9cbiAgICBnZXQgZW1wdHkoKSB7IHJldHVybiB0aGlzLnNlY3Rpb25zLmxlbmd0aCA9PSAwIHx8IHRoaXMuc2VjdGlvbnMubGVuZ3RoID09IDIgJiYgdGhpcy5zZWN0aW9uc1sxXSA8IDA7IH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHVuY2hhbmdlZCBwYXJ0cyBsZWZ0IGJ5IHRoZXNlIGNoYW5nZXMuIGBwb3NBYFxuICAgIHByb3ZpZGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcmFuZ2UgaW4gdGhlIG9sZCBkb2N1bWVudCwgYHBvc0JgXG4gICAgdGhlIG5ldyBwb3NpdGlvbiBpbiB0aGUgY2hhbmdlZCBkb2N1bWVudC5cbiAgICAqL1xuICAgIGl0ZXJHYXBzKGYpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvc0EgPSAwLCBwb3NCID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgaWYgKGlucyA8IDApIHtcbiAgICAgICAgICAgICAgICBmKHBvc0EsIHBvc0IsIGxlbik7XG4gICAgICAgICAgICAgICAgcG9zQiArPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb3NCICs9IGlucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc0EgKz0gbGVuO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgcmFuZ2VzIGNoYW5nZWQgYnkgdGhlc2UgY2hhbmdlcy4gKFNlZVxuICAgIFtgQ2hhbmdlU2V0Lml0ZXJDaGFuZ2VzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VTZXQuaXRlckNoYW5nZXMpIGZvciBhXG4gICAgdmFyaWFudCB0aGF0IGFsc28gcHJvdmlkZXMgeW91IHdpdGggdGhlIGluc2VydGVkIHRleHQuKVxuICAgIGBmcm9tQWAvYHRvQWAgcHJvdmlkZXMgdGhlIGV4dGVudCBvZiB0aGUgY2hhbmdlIGluIHRoZSBzdGFydGluZ1xuICAgIGRvY3VtZW50LCBgZnJvbUJgL2B0b0JgIHRoZSBleHRlbnQgb2YgdGhlIHJlcGxhY2VtZW50IGluIHRoZVxuICAgIGNoYW5nZWQgZG9jdW1lbnQuXG4gICAgXG4gICAgV2hlbiBgaW5kaXZpZHVhbGAgaXMgdHJ1ZSwgYWRqYWNlbnQgY2hhbmdlcyAod2hpY2ggYXJlIGtlcHRcbiAgICBzZXBhcmF0ZSBmb3IgW3Bvc2l0aW9uIG1hcHBpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlRGVzYy5tYXBQb3MpKSBhcmVcbiAgICByZXBvcnRlZCBzZXBhcmF0ZWx5LlxuICAgICovXG4gICAgaXRlckNoYW5nZWRSYW5nZXMoZiwgaW5kaXZpZHVhbCA9IGZhbHNlKSB7XG4gICAgICAgIGl0ZXJDaGFuZ2VzKHRoaXMsIGYsIGluZGl2aWR1YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBkZXNjcmlwdGlvbiBvZiB0aGUgaW52ZXJ0ZWQgZm9ybSBvZiB0aGVzZSBjaGFuZ2VzLlxuICAgICovXG4gICAgZ2V0IGludmVydGVkRGVzYygpIHtcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK107XG4gICAgICAgICAgICBpZiAoaW5zIDwgMClcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKGxlbiwgaW5zKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKGlucywgbGVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENoYW5nZURlc2Moc2VjdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wdXRlIHRoZSBjb21iaW5lZCBlZmZlY3Qgb2YgYXBwbHlpbmcgYW5vdGhlciBzZXQgb2YgY2hhbmdlc1xuICAgIGFmdGVyIHRoaXMgb25lLiBUaGUgbGVuZ3RoIG9mIHRoZSBkb2N1bWVudCBhZnRlciB0aGlzIHNldCBzaG91bGRcbiAgICBtYXRjaCB0aGUgbGVuZ3RoIGJlZm9yZSBgb3RoZXJgLlxuICAgICovXG4gICAgY29tcG9zZURlc2Mob3RoZXIpIHsgcmV0dXJuIHRoaXMuZW1wdHkgPyBvdGhlciA6IG90aGVyLmVtcHR5ID8gdGhpcyA6IGNvbXBvc2VTZXRzKHRoaXMsIG90aGVyKTsgfVxuICAgIC8qKlxuICAgIE1hcCB0aGlzIGRlc2NyaXB0aW9uLCB3aGljaCBzaG91bGQgc3RhcnQgd2l0aCB0aGUgc2FtZSBkb2N1bWVudFxuICAgIGFzIGBvdGhlcmAsIG92ZXIgYW5vdGhlciBzZXQgb2YgY2hhbmdlcywgc28gdGhhdCBpdCBjYW4gYmVcbiAgICBhcHBsaWVkIGFmdGVyIGl0LiBXaGVuIGBiZWZvcmVgIGlzIHRydWUsIG1hcCBhcyBpZiB0aGUgY2hhbmdlc1xuICAgIGluIGB0aGlzYCBoYXBwZW5lZCBiZWZvcmUgdGhlIG9uZXMgaW4gYG90aGVyYC5cbiAgICAqL1xuICAgIG1hcERlc2Mob3RoZXIsIGJlZm9yZSA9IGZhbHNlKSB7IHJldHVybiBvdGhlci5lbXB0eSA/IHRoaXMgOiBtYXBTZXQodGhpcywgb3RoZXIsIGJlZm9yZSk7IH1cbiAgICBtYXBQb3MocG9zLCBhc3NvYyA9IC0xLCBtb2RlID0gTWFwTW9kZS5TaW1wbGUpIHtcbiAgICAgICAgbGV0IHBvc0EgPSAwLCBwb3NCID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgZW5kQSA9IHBvc0EgKyBsZW47XG4gICAgICAgICAgICBpZiAoaW5zIDwgMCkge1xuICAgICAgICAgICAgICAgIGlmIChlbmRBID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zQiArIChwb3MgLSBwb3NBKTtcbiAgICAgICAgICAgICAgICBwb3NCICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChtb2RlICE9IE1hcE1vZGUuU2ltcGxlICYmIGVuZEEgPj0gcG9zICYmXG4gICAgICAgICAgICAgICAgICAgIChtb2RlID09IE1hcE1vZGUuVHJhY2tEZWwgJiYgcG9zQSA8IHBvcyAmJiBlbmRBID4gcG9zIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID09IE1hcE1vZGUuVHJhY2tCZWZvcmUgJiYgcG9zQSA8IHBvcyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9PSBNYXBNb2RlLlRyYWNrQWZ0ZXIgJiYgZW5kQSA+IHBvcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChlbmRBID4gcG9zIHx8IGVuZEEgPT0gcG9zICYmIGFzc29jIDwgMCAmJiAhbGVuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zID09IHBvc0EgfHwgYXNzb2MgPCAwID8gcG9zQiA6IHBvc0IgKyBpbnM7XG4gICAgICAgICAgICAgICAgcG9zQiArPSBpbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3NBID0gZW5kQTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID4gcG9zQSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBQb3NpdGlvbiAke3Bvc30gaXMgb3V0IG9mIHJhbmdlIGZvciBjaGFuZ2VzZXQgb2YgbGVuZ3RoICR7cG9zQX1gKTtcbiAgICAgICAgcmV0dXJuIHBvc0I7XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIHdoZXRoZXIgdGhlc2UgY2hhbmdlcyB0b3VjaCBhIGdpdmVuIHJhbmdlLiBXaGVuIG9uZSBvZiB0aGVcbiAgICBjaGFuZ2VzIGVudGlyZWx5IGNvdmVycyB0aGUgcmFuZ2UsIHRoZSBzdHJpbmcgYFwiY292ZXJcImAgaXNcbiAgICByZXR1cm5lZC5cbiAgICAqL1xuICAgIHRvdWNoZXNSYW5nZShmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aCAmJiBwb3MgPD0gdG87KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK10sIGVuZCA9IHBvcyArIGxlbjtcbiAgICAgICAgICAgIGlmIChpbnMgPj0gMCAmJiBwb3MgPD0gdG8gJiYgZW5kID49IGZyb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcyA8IGZyb20gJiYgZW5kID4gdG8gPyBcImNvdmVyXCIgOiB0cnVlO1xuICAgICAgICAgICAgcG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK107XG4gICAgICAgICAgICByZXN1bHQgKz0gKHJlc3VsdCA/IFwiIFwiIDogXCJcIikgKyBsZW4gKyAoaW5zID49IDAgPyBcIjpcIiArIGlucyA6IFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFNlcmlhbGl6ZSB0aGlzIGNoYW5nZSBkZXNjIHRvIGEgSlNPTi1yZXByZXNlbnRhYmxlIHZhbHVlLlxuICAgICovXG4gICAgdG9KU09OKCkgeyByZXR1cm4gdGhpcy5zZWN0aW9uczsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNoYW5nZSBkZXNjIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24gKGFzIHByb2R1Y2VkXG4gICAgYnkgW2B0b0pTT05gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZURlc2MudG9KU09OKS5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uKSB8fCBqc29uLmxlbmd0aCAlIDIgfHwganNvbi5zb21lKGEgPT4gdHlwZW9mIGEgIT0gXCJudW1iZXJcIikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBDaGFuZ2VEZXNjXCIpO1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZURlc2MoanNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShzZWN0aW9ucykgeyByZXR1cm4gbmV3IENoYW5nZURlc2Moc2VjdGlvbnMpOyB9XG59XG4vKipcbkEgY2hhbmdlIHNldCByZXByZXNlbnRzIGEgZ3JvdXAgb2YgbW9kaWZpY2F0aW9ucyB0byBhIGRvY3VtZW50LiBJdFxuc3RvcmVzIHRoZSBkb2N1bWVudCBsZW5ndGgsIGFuZCBjYW4gb25seSBiZSBhcHBsaWVkIHRvIGRvY3VtZW50c1xud2l0aCBleGFjdGx5IHRoYXQgbGVuZ3RoLlxuKi9cbmNsYXNzIENoYW5nZVNldCBleHRlbmRzIENoYW5nZURlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHNlY3Rpb25zLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGluc2VydGVkKSB7XG4gICAgICAgIHN1cGVyKHNlY3Rpb25zKTtcbiAgICAgICAgdGhpcy5pbnNlcnRlZCA9IGluc2VydGVkO1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBseSB0aGUgY2hhbmdlcyB0byBhIGRvY3VtZW50LCByZXR1cm5pbmcgdGhlIG1vZGlmaWVkXG4gICAgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoICE9IGRvYy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkFwcGx5aW5nIGNoYW5nZSBzZXQgdG8gYSBkb2N1bWVudCB3aXRoIHRoZSB3cm9uZyBsZW5ndGhcIik7XG4gICAgICAgIGl0ZXJDaGFuZ2VzKHRoaXMsIChmcm9tQSwgdG9BLCBmcm9tQiwgX3RvQiwgdGV4dCkgPT4gZG9jID0gZG9jLnJlcGxhY2UoZnJvbUIsIGZyb21CICsgKHRvQSAtIGZyb21BKSwgdGV4dCksIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGRvYztcbiAgICB9XG4gICAgbWFwRGVzYyhvdGhlciwgYmVmb3JlID0gZmFsc2UpIHsgcmV0dXJuIG1hcFNldCh0aGlzLCBvdGhlciwgYmVmb3JlLCB0cnVlKTsgfVxuICAgIC8qKlxuICAgIEdpdmVuIHRoZSBkb2N1bWVudCBhcyBpdCBleGlzdGVkIF9iZWZvcmVfIHRoZSBjaGFuZ2VzLCByZXR1cm4gYVxuICAgIGNoYW5nZSBzZXQgdGhhdCByZXByZXNlbnRzIHRoZSBpbnZlcnNlIG9mIHRoaXMgc2V0LCB3aGljaCBjb3VsZFxuICAgIGJlIHVzZWQgdG8gZ28gZnJvbSB0aGUgZG9jdW1lbnQgY3JlYXRlZCBieSB0aGUgY2hhbmdlcyBiYWNrIHRvXG4gICAgdGhlIGRvY3VtZW50IGFzIGl0IGV4aXN0ZWQgYmVmb3JlIHRoZSBjaGFuZ2VzLlxuICAgICovXG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSB0aGlzLnNlY3Rpb25zLnNsaWNlKCksIGluc2VydGVkID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgc2VjdGlvbnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSBzZWN0aW9uc1tpXSwgaW5zID0gc2VjdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgaWYgKGlucyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnNbaV0gPSBpbnM7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnNbaSArIDFdID0gbGVuO1xuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IGkgPj4gMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5zZXJ0ZWQubGVuZ3RoIDwgaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkLnB1c2goVGV4dC5lbXB0eSk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWQucHVzaChsZW4gPyBkb2Muc2xpY2UocG9zLCBwb3MgKyBsZW4pIDogVGV4dC5lbXB0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgKz0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbWJpbmUgdHdvIHN1YnNlcXVlbnQgY2hhbmdlIHNldHMgaW50byBhIHNpbmdsZSBzZXQuIGBvdGhlcmBcbiAgICBtdXN0IHN0YXJ0IGluIHRoZSBkb2N1bWVudCBwcm9kdWNlZCBieSBgdGhpc2AuIElmIGB0aGlzYCBnb2VzXG4gICAgYGRvY0FgIOKGkiBgZG9jQmAgYW5kIGBvdGhlcmAgcmVwcmVzZW50cyBgZG9jQmAg4oaSIGBkb2NDYCwgdGhlXG4gICAgcmV0dXJuZWQgdmFsdWUgd2lsbCByZXByZXNlbnQgdGhlIGNoYW5nZSBgZG9jQWAg4oaSIGBkb2NDYC5cbiAgICAqL1xuICAgIGNvbXBvc2Uob3RoZXIpIHsgcmV0dXJuIHRoaXMuZW1wdHkgPyBvdGhlciA6IG90aGVyLmVtcHR5ID8gdGhpcyA6IGNvbXBvc2VTZXRzKHRoaXMsIG90aGVyLCB0cnVlKTsgfVxuICAgIC8qKlxuICAgIEdpdmVuIGFub3RoZXIgY2hhbmdlIHNldCBzdGFydGluZyBpbiB0aGUgc2FtZSBkb2N1bWVudCwgbWFwcyB0aGlzXG4gICAgY2hhbmdlIHNldCBvdmVyIHRoZSBvdGhlciwgcHJvZHVjaW5nIGEgbmV3IGNoYW5nZSBzZXQgdGhhdCBjYW4gYmVcbiAgICBhcHBsaWVkIHRvIHRoZSBkb2N1bWVudCBwcm9kdWNlZCBieSBhcHBseWluZyBgb3RoZXJgLiBXaGVuXG4gICAgYGJlZm9yZWAgaXMgYHRydWVgLCBvcmRlciBjaGFuZ2VzIGFzIGlmIGB0aGlzYCBjb21lcyBiZWZvcmVcbiAgICBgb3RoZXJgLCBvdGhlcndpc2UgKHRoZSBkZWZhdWx0KSB0cmVhdCBgb3RoZXJgIGFzIGNvbWluZyBmaXJzdC5cbiAgICBcbiAgICBHaXZlbiB0d28gY2hhbmdlcyBgQWAgYW5kIGBCYCwgYEEuY29tcG9zZShCLm1hcChBKSlgIGFuZFxuICAgIGBCLmNvbXBvc2UoQS5tYXAoQiwgdHJ1ZSkpYCB3aWxsIHByb2R1Y2UgdGhlIHNhbWUgZG9jdW1lbnQuIFRoaXNcbiAgICBwcm92aWRlcyBhIGJhc2ljIGZvcm0gb2YgW29wZXJhdGlvbmFsXG4gICAgdHJhbnNmb3JtYXRpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL09wZXJhdGlvbmFsX3RyYW5zZm9ybWF0aW9uKSxcbiAgICBhbmQgY2FuIGJlIHVzZWQgZm9yIGNvbGxhYm9yYXRpdmUgZWRpdGluZy5cbiAgICAqL1xuICAgIG1hcChvdGhlciwgYmVmb3JlID0gZmFsc2UpIHsgcmV0dXJuIG90aGVyLmVtcHR5ID8gdGhpcyA6IG1hcFNldCh0aGlzLCBvdGhlciwgYmVmb3JlLCB0cnVlKTsgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgY2hhbmdlZCByYW5nZXMgaW4gdGhlIGRvY3VtZW50LCBjYWxsaW5nIGBmYCBmb3JcbiAgICBlYWNoLCB3aXRoIHRoZSByYW5nZSBpbiB0aGUgb3JpZ2luYWwgZG9jdW1lbnQgKGBmcm9tQWAtYHRvQWApXG4gICAgYW5kIHRoZSByYW5nZSB0aGF0IHJlcGxhY2VzIGl0IGluIHRoZSBuZXcgZG9jdW1lbnRcbiAgICAoYGZyb21CYC1gdG9CYCkuXG4gICAgXG4gICAgV2hlbiBgaW5kaXZpZHVhbGAgaXMgdHJ1ZSwgYWRqYWNlbnQgY2hhbmdlcyBhcmUgcmVwb3J0ZWRcbiAgICBzZXBhcmF0ZWx5LlxuICAgICovXG4gICAgaXRlckNoYW5nZXMoZiwgaW5kaXZpZHVhbCA9IGZhbHNlKSB7XG4gICAgICAgIGl0ZXJDaGFuZ2VzKHRoaXMsIGYsIGluZGl2aWR1YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbY2hhbmdlIGRlc2NyaXB0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZURlc2MpIGZvciB0aGlzIGNoYW5nZVxuICAgIHNldC5cbiAgICAqL1xuICAgIGdldCBkZXNjKCkgeyByZXR1cm4gQ2hhbmdlRGVzYy5jcmVhdGUodGhpcy5zZWN0aW9ucyk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZpbHRlcihyYW5nZXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdFNlY3Rpb25zID0gW10sIHJlc3VsdEluc2VydGVkID0gW10sIGZpbHRlcmVkU2VjdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IGl0ZXIgPSBuZXcgU2VjdGlvbkl0ZXIodGhpcyk7XG4gICAgICAgIGRvbmU6IGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaSA9PSByYW5nZXMubGVuZ3RoID8gMWU5IDogcmFuZ2VzW2krK107XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgbmV4dCB8fCBwb3MgPT0gbmV4dCAmJiBpdGVyLmxlbiA9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXIuZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgZG9uZTtcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gTWF0aC5taW4oaXRlci5sZW4sIG5leHQgLSBwb3MpO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oZmlsdGVyZWRTZWN0aW9ucywgbGVuLCAtMSk7XG4gICAgICAgICAgICAgICAgbGV0IGlucyA9IGl0ZXIuaW5zID09IC0xID8gLTEgOiBpdGVyLm9mZiA9PSAwID8gaXRlci5pbnMgOiAwO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24ocmVzdWx0U2VjdGlvbnMsIGxlbiwgaW5zKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zID4gMClcbiAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KHJlc3VsdEluc2VydGVkLCByZXN1bHRTZWN0aW9ucywgaXRlci50ZXh0KTtcbiAgICAgICAgICAgICAgICBpdGVyLmZvcndhcmQobGVuKTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGVuZCA9IHJhbmdlc1tpKytdO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVyLmRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGRvbmU7XG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IE1hdGgubWluKGl0ZXIubGVuLCBlbmQgLSBwb3MpO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24ocmVzdWx0U2VjdGlvbnMsIGxlbiwgLTEpO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oZmlsdGVyZWRTZWN0aW9ucywgbGVuLCBpdGVyLmlucyA9PSAtMSA/IC0xIDogaXRlci5vZmYgPT0gMCA/IGl0ZXIuaW5zIDogMCk7XG4gICAgICAgICAgICAgICAgaXRlci5mb3J3YXJkKGxlbik7XG4gICAgICAgICAgICAgICAgcG9zICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBuZXcgQ2hhbmdlU2V0KHJlc3VsdFNlY3Rpb25zLCByZXN1bHRJbnNlcnRlZCksXG4gICAgICAgICAgICBmaWx0ZXJlZDogQ2hhbmdlRGVzYy5jcmVhdGUoZmlsdGVyZWRTZWN0aW9ucykgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2VyaWFsaXplIHRoaXMgY2hhbmdlIHNldCB0byBhIEpTT04tcmVwcmVzZW50YWJsZSB2YWx1ZS5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaV0sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgaWYgKGlucyA8IDApXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChsZW4pO1xuICAgICAgICAgICAgZWxzZSBpZiAoaW5zID09IDApXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChbbGVuXSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChbbGVuXS5jb25jYXQodGhpcy5pbnNlcnRlZFtpID4+IDFdLnRvSlNPTigpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjaGFuZ2Ugc2V0IGZvciB0aGUgZ2l2ZW4gY2hhbmdlcywgZm9yIGEgZG9jdW1lbnQgb2YgdGhlXG4gICAgZ2l2ZW4gbGVuZ3RoLCB1c2luZyBgbGluZVNlcGAgYXMgbGluZSBzZXBhcmF0b3IuXG4gICAgKi9cbiAgICBzdGF0aWMgb2YoY2hhbmdlcywgbGVuZ3RoLCBsaW5lU2VwKSB7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdLCBpbnNlcnRlZCA9IFtdLCBwb3MgPSAwO1xuICAgICAgICBsZXQgdG90YWwgPSBudWxsO1xuICAgICAgICBmdW5jdGlvbiBmbHVzaChmb3JjZSA9IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAoIWZvcmNlICYmICFzZWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHBvcyA8IGxlbmd0aClcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW5ndGggLSBwb3MsIC0xKTtcbiAgICAgICAgICAgIGxldCBzZXQgPSBuZXcgQ2hhbmdlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCk7XG4gICAgICAgICAgICB0b3RhbCA9IHRvdGFsID8gdG90YWwuY29tcG9zZShzZXQubWFwKHRvdGFsKSkgOiBzZXQ7XG4gICAgICAgICAgICBzZWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgaW5zZXJ0ZWQgPSBbXTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcHJvY2VzcyhzcGVjKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzcGVjKSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHN1YiBvZiBzcGVjKVxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKHN1Yik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzcGVjIGluc3RhbmNlb2YgQ2hhbmdlU2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwZWMubGVuZ3RoICE9IGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE1pc21hdGNoZWQgY2hhbmdlIHNldCBsZW5ndGggKGdvdCAke3NwZWMubGVuZ3RofSwgZXhwZWN0ZWQgJHtsZW5ndGh9KWApO1xuICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgdG90YWwgPSB0b3RhbCA/IHRvdGFsLmNvbXBvc2Uoc3BlYy5tYXAodG90YWwpKSA6IHNwZWM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBmcm9tLCB0byA9IGZyb20sIGluc2VydCB9ID0gc3BlYztcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+IHRvIHx8IGZyb20gPCAwIHx8IHRvID4gbGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBjaGFuZ2UgcmFuZ2UgJHtmcm9tfSB0byAke3RvfSAoaW4gZG9jIG9mIGxlbmd0aCAke2xlbmd0aH0pYCk7XG4gICAgICAgICAgICAgICAgbGV0IGluc1RleHQgPSAhaW5zZXJ0ID8gVGV4dC5lbXB0eSA6IHR5cGVvZiBpbnNlcnQgPT0gXCJzdHJpbmdcIiA/IFRleHQub2YoaW5zZXJ0LnNwbGl0KGxpbmVTZXAgfHwgRGVmYXVsdFNwbGl0KSkgOiBpbnNlcnQ7XG4gICAgICAgICAgICAgICAgbGV0IGluc0xlbiA9IGluc1RleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID09IHRvICYmIGluc0xlbiA9PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPCBwb3MpXG4gICAgICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGZyb20gLSBwb3MsIC0xKTtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCB0byAtIGZyb20sIGluc0xlbik7XG4gICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydGVkLCBzZWN0aW9ucywgaW5zVGV4dCk7XG4gICAgICAgICAgICAgICAgcG9zID0gdG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2VzcyhjaGFuZ2VzKTtcbiAgICAgICAgZmx1c2goIXRvdGFsKTtcbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZW1wdHkgY2hhbmdlc2V0IG9mIHRoZSBnaXZlbiBsZW5ndGguXG4gICAgKi9cbiAgICBzdGF0aWMgZW1wdHkobGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlU2V0KGxlbmd0aCA/IFtsZW5ndGgsIC0xXSA6IFtdLCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNoYW5nZXNldCBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uIChhcyBwcm9kdWNlZCBieVxuICAgIFtgdG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VTZXQudG9KU09OKS5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIG9mIENoYW5nZVNldFwiKTtcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gW10sIGluc2VydGVkID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwganNvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHBhcnQgPSBqc29uW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHBhcnQsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHBhcnQpIHx8IHR5cGVvZiBwYXJ0WzBdICE9IFwibnVtYmVyXCIgfHwgcGFydC5zb21lKChlLCBpKSA9PiBpICYmIHR5cGVvZiBlICE9IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gb2YgQ2hhbmdlU2V0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFydC5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2gocGFydFswXSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5zZXJ0ZWQubGVuZ3RoIDwgaSlcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWQucHVzaChUZXh0LmVtcHR5KTtcbiAgICAgICAgICAgICAgICBpbnNlcnRlZFtpXSA9IFRleHQub2YocGFydC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChwYXJ0WzBdLCBpbnNlcnRlZFtpXS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VTZXQoc2VjdGlvbnMsIGluc2VydGVkKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW4sIGlucywgZm9yY2VKb2luID0gZmFsc2UpIHtcbiAgICBpZiAobGVuID09IDAgJiYgaW5zIDw9IDApXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgbGFzdCA9IHNlY3Rpb25zLmxlbmd0aCAtIDI7XG4gICAgaWYgKGxhc3QgPj0gMCAmJiBpbnMgPD0gMCAmJiBpbnMgPT0gc2VjdGlvbnNbbGFzdCArIDFdKVxuICAgICAgICBzZWN0aW9uc1tsYXN0XSArPSBsZW47XG4gICAgZWxzZSBpZiAobGFzdCA+PSAwICYmIGxlbiA9PSAwICYmIHNlY3Rpb25zW2xhc3RdID09IDApXG4gICAgICAgIHNlY3Rpb25zW2xhc3QgKyAxXSArPSBpbnM7XG4gICAgZWxzZSBpZiAoZm9yY2VKb2luKSB7XG4gICAgICAgIHNlY3Rpb25zW2xhc3RdICs9IGxlbjtcbiAgICAgICAgc2VjdGlvbnNbbGFzdCArIDFdICs9IGlucztcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICBzZWN0aW9ucy5wdXNoKGxlbiwgaW5zKTtcbn1cbmZ1bmN0aW9uIGFkZEluc2VydCh2YWx1ZXMsIHNlY3Rpb25zLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBpbmRleCA9IChzZWN0aW9ucy5sZW5ndGggLSAyKSA+PiAxO1xuICAgIGlmIChpbmRleCA8IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXSA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV0uYXBwZW5kKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdoaWxlICh2YWx1ZXMubGVuZ3RoIDwgaW5kZXgpXG4gICAgICAgICAgICB2YWx1ZXMucHVzaChUZXh0LmVtcHR5KTtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGl0ZXJDaGFuZ2VzKGRlc2MsIGYsIGluZGl2aWR1YWwpIHtcbiAgICBsZXQgaW5zZXJ0ZWQgPSBkZXNjLmluc2VydGVkO1xuICAgIGZvciAobGV0IHBvc0EgPSAwLCBwb3NCID0gMCwgaSA9IDA7IGkgPCBkZXNjLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgbGV0IGxlbiA9IGRlc2Muc2VjdGlvbnNbaSsrXSwgaW5zID0gZGVzYy5zZWN0aW9uc1tpKytdO1xuICAgICAgICBpZiAoaW5zIDwgMCkge1xuICAgICAgICAgICAgcG9zQSArPSBsZW47XG4gICAgICAgICAgICBwb3NCICs9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBlbmRBID0gcG9zQSwgZW5kQiA9IHBvc0IsIHRleHQgPSBUZXh0LmVtcHR5O1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGVuZEEgKz0gbGVuO1xuICAgICAgICAgICAgICAgIGVuZEIgKz0gaW5zO1xuICAgICAgICAgICAgICAgIGlmIChpbnMgJiYgaW5zZXJ0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LmFwcGVuZChpbnNlcnRlZFsoaSAtIDIpID4+IDFdKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kaXZpZHVhbCB8fCBpID09IGRlc2Muc2VjdGlvbnMubGVuZ3RoIHx8IGRlc2Muc2VjdGlvbnNbaSArIDFdIDwgMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgbGVuID0gZGVzYy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgICAgIGlucyA9IGRlc2Muc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGYocG9zQSwgZW5kQSwgcG9zQiwgZW5kQiwgdGV4dCk7XG4gICAgICAgICAgICBwb3NBID0gZW5kQTtcbiAgICAgICAgICAgIHBvc0IgPSBlbmRCO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbWFwU2V0KHNldEEsIHNldEIsIGJlZm9yZSwgbWtTZXQgPSBmYWxzZSkge1xuICAgIC8vIFByb2R1Y2UgYSBjb3B5IG9mIHNldEEgdGhhdCBhcHBsaWVzIHRvIHRoZSBkb2N1bWVudCBhZnRlciBzZXRCXG4gICAgLy8gaGFzIGJlZW4gYXBwbGllZCAoYXNzdW1pbmcgYm90aCBzdGFydCBhdCB0aGUgc2FtZSBkb2N1bWVudCkuXG4gICAgbGV0IHNlY3Rpb25zID0gW10sIGluc2VydCA9IG1rU2V0ID8gW10gOiBudWxsO1xuICAgIGxldCBhID0gbmV3IFNlY3Rpb25JdGVyKHNldEEpLCBiID0gbmV3IFNlY3Rpb25JdGVyKHNldEIpO1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBib3RoIHNldHMgaW4gcGFyYWxsZWwuIGluc2VydGVkIHRyYWNrcywgZm9yIGNoYW5nZXNcbiAgICAvLyBpbiBBIHRoYXQgaGF2ZSB0byBiZSBwcm9jZXNzZWQgcGllY2UtYnktcGllY2UsIHdoZXRoZXIgdGhlaXJcbiAgICAvLyBjb250ZW50IGhhcyBiZWVuIGluc2VydGVkIGFscmVhZHksIGFuZCByZWZlcnMgdG8gdGhlIHNlY3Rpb25cbiAgICAvLyBpbmRleC5cbiAgICBmb3IgKGxldCBpbnNlcnRlZCA9IC0xOzspIHtcbiAgICAgICAgaWYgKGEuZG9uZSAmJiBiLmxlbiB8fCBiLmRvbmUgJiYgYS5sZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgY2hhbmdlIHNldCBsZW5ndGhzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuaW5zID09IC0xICYmIGIuaW5zID09IC0xKSB7XG4gICAgICAgICAgICAvLyBNb3ZlIGFjcm9zcyByYW5nZXMgc2tpcHBlZCBieSBib3RoIHNldHMuXG4gICAgICAgICAgICBsZXQgbGVuID0gTWF0aC5taW4oYS5sZW4sIGIubGVuKTtcbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGxlbiwgLTEpO1xuICAgICAgICAgICAgYS5mb3J3YXJkKGxlbik7XG4gICAgICAgICAgICBiLmZvcndhcmQobGVuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiLmlucyA+PSAwICYmIChhLmlucyA8IDAgfHwgaW5zZXJ0ZWQgPT0gYS5pIHx8IGEub2ZmID09IDAgJiYgKGIubGVuIDwgYS5sZW4gfHwgYi5sZW4gPT0gYS5sZW4gJiYgIWJlZm9yZSkpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgY2hhbmdlIGluIEIgdGhhdCBjb21lcyBiZWZvcmUgdGhlIG5leHQgY2hhbmdlIGluXG4gICAgICAgICAgICAvLyBBIChvcmRlcmVkIGJ5IHN0YXJ0IHBvcywgdGhlbiBsZW4sIHRoZW4gYmVmb3JlIGZsYWcpLCBza2lwXG4gICAgICAgICAgICAvLyB0aGF0IChhbmQgcHJvY2VzcyBhbnkgY2hhbmdlcyBpbiBBIGl0IGNvdmVycykuXG4gICAgICAgICAgICBsZXQgbGVuID0gYi5sZW47XG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBiLmlucywgLTEpO1xuICAgICAgICAgICAgd2hpbGUgKGxlbikge1xuICAgICAgICAgICAgICAgIGxldCBwaWVjZSA9IE1hdGgubWluKGEubGVuLCBsZW4pO1xuICAgICAgICAgICAgICAgIGlmIChhLmlucyA+PSAwICYmIGluc2VydGVkIDwgYS5pICYmIGEubGVuIDw9IHBpZWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIDAsIGEuaW5zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc2VydClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBhLnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRlZCA9IGEuaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYS5mb3J3YXJkKHBpZWNlKTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gcGllY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmlucyA+PSAwKSB7XG4gICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSBwYXJ0IG9mIGEgY2hhbmdlIGluIEEgdXAgdG8gdGhlIHN0YXJ0IG9mIHRoZSBuZXh0XG4gICAgICAgICAgICAvLyBub24tZGVsZXRpb24gY2hhbmdlIGluIEIgKGlmIG92ZXJsYXBwaW5nKS5cbiAgICAgICAgICAgIGxldCBsZW4gPSAwLCBsZWZ0ID0gYS5sZW47XG4gICAgICAgICAgICB3aGlsZSAobGVmdCkge1xuICAgICAgICAgICAgICAgIGlmIChiLmlucyA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGllY2UgPSBNYXRoLm1pbihsZWZ0LCBiLmxlbik7XG4gICAgICAgICAgICAgICAgICAgIGxlbiArPSBwaWVjZTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAtPSBwaWVjZTtcbiAgICAgICAgICAgICAgICAgICAgYi5mb3J3YXJkKHBpZWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYi5pbnMgPT0gMCAmJiBiLmxlbiA8IGxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAtPSBiLmxlbjtcbiAgICAgICAgICAgICAgICAgICAgYi5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW4sIGluc2VydGVkIDwgYS5pID8gYS5pbnMgOiAwKTtcbiAgICAgICAgICAgIGlmIChpbnNlcnQgJiYgaW5zZXJ0ZWQgPCBhLmkpXG4gICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGEudGV4dCk7XG4gICAgICAgICAgICBpbnNlcnRlZCA9IGEuaTtcbiAgICAgICAgICAgIGEuZm9yd2FyZChhLmxlbiAtIGxlZnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuZG9uZSAmJiBiLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNlcnQgPyBDaGFuZ2VTZXQuY3JlYXRlU2V0KHNlY3Rpb25zLCBpbnNlcnQpIDogQ2hhbmdlRGVzYy5jcmVhdGUoc2VjdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBjaGFuZ2Ugc2V0IGxlbmd0aHNcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb21wb3NlU2V0cyhzZXRBLCBzZXRCLCBta1NldCA9IGZhbHNlKSB7XG4gICAgbGV0IHNlY3Rpb25zID0gW107XG4gICAgbGV0IGluc2VydCA9IG1rU2V0ID8gW10gOiBudWxsO1xuICAgIGxldCBhID0gbmV3IFNlY3Rpb25JdGVyKHNldEEpLCBiID0gbmV3IFNlY3Rpb25JdGVyKHNldEIpO1xuICAgIGZvciAobGV0IG9wZW4gPSBmYWxzZTs7KSB7XG4gICAgICAgIGlmIChhLmRvbmUgJiYgYi5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0ID8gQ2hhbmdlU2V0LmNyZWF0ZVNldChzZWN0aW9ucywgaW5zZXJ0KSA6IENoYW5nZURlc2MuY3JlYXRlKHNlY3Rpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmlucyA9PSAwKSB7IC8vIERlbGV0aW9uIGluIEFcbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGEubGVuLCAwLCBvcGVuKTtcbiAgICAgICAgICAgIGEubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIubGVuID09IDAgJiYgIWIuZG9uZSkgeyAvLyBJbnNlcnRpb24gaW4gQlxuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgMCwgYi5pbnMsIG9wZW4pO1xuICAgICAgICAgICAgaWYgKGluc2VydClcbiAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYi50ZXh0KTtcbiAgICAgICAgICAgIGIubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuZG9uZSB8fCBiLmRvbmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgY2hhbmdlIHNldCBsZW5ndGhzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGxlbiA9IE1hdGgubWluKGEubGVuMiwgYi5sZW4pLCBzZWN0aW9uTGVuID0gc2VjdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGEuaW5zID09IC0xKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluc0IgPSBiLmlucyA9PSAtMSA/IC0xIDogYi5vZmYgPyAwIDogYi5pbnM7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuLCBpbnNCLCBvcGVuKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0ICYmIGluc0IpXG4gICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBiLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYi5pbnMgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBhLm9mZiA/IDAgOiBhLmxlbiwgbGVuLCBvcGVuKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0KVxuICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYS50ZXh0Qml0KGxlbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgYS5vZmYgPyAwIDogYS5sZW4sIGIub2ZmID8gMCA6IGIuaW5zLCBvcGVuKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0ICYmICFiLm9mZilcbiAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGIudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcGVuID0gKGEuaW5zID4gbGVuIHx8IGIuaW5zID49IDAgJiYgYi5sZW4gPiBsZW4pICYmIChvcGVuIHx8IHNlY3Rpb25zLmxlbmd0aCA+IHNlY3Rpb25MZW4pO1xuICAgICAgICAgICAgYS5mb3J3YXJkMihsZW4pO1xuICAgICAgICAgICAgYi5mb3J3YXJkKGxlbik7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBTZWN0aW9uSXRlciB7XG4gICAgY29uc3RydWN0b3Ioc2V0KSB7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgbGV0IHsgc2VjdGlvbnMgfSA9IHRoaXMuc2V0O1xuICAgICAgICBpZiAodGhpcy5pIDwgc2VjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmxlbiA9IHNlY3Rpb25zW3RoaXMuaSsrXTtcbiAgICAgICAgICAgIHRoaXMuaW5zID0gc2VjdGlvbnNbdGhpcy5pKytdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sZW4gPSAwO1xuICAgICAgICAgICAgdGhpcy5pbnMgPSAtMjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9mZiA9IDA7XG4gICAgfVxuICAgIGdldCBkb25lKCkgeyByZXR1cm4gdGhpcy5pbnMgPT0gLTI7IH1cbiAgICBnZXQgbGVuMigpIHsgcmV0dXJuIHRoaXMuaW5zIDwgMCA/IHRoaXMubGVuIDogdGhpcy5pbnM7IH1cbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgICAgbGV0IHsgaW5zZXJ0ZWQgfSA9IHRoaXMuc2V0LCBpbmRleCA9ICh0aGlzLmkgLSAyKSA+PiAxO1xuICAgICAgICByZXR1cm4gaW5kZXggPj0gaW5zZXJ0ZWQubGVuZ3RoID8gVGV4dC5lbXB0eSA6IGluc2VydGVkW2luZGV4XTtcbiAgICB9XG4gICAgdGV4dEJpdChsZW4pIHtcbiAgICAgICAgbGV0IHsgaW5zZXJ0ZWQgfSA9IHRoaXMuc2V0LCBpbmRleCA9ICh0aGlzLmkgLSAyKSA+PiAxO1xuICAgICAgICByZXR1cm4gaW5kZXggPj0gaW5zZXJ0ZWQubGVuZ3RoICYmICFsZW4gPyBUZXh0LmVtcHR5XG4gICAgICAgICAgICA6IGluc2VydGVkW2luZGV4XS5zbGljZSh0aGlzLm9mZiwgbGVuID09IG51bGwgPyB1bmRlZmluZWQgOiB0aGlzLm9mZiArIGxlbik7XG4gICAgfVxuICAgIGZvcndhcmQobGVuKSB7XG4gICAgICAgIGlmIChsZW4gPT0gdGhpcy5sZW4pXG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxlbiAtPSBsZW47XG4gICAgICAgICAgICB0aGlzLm9mZiArPSBsZW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yd2FyZDIobGVuKSB7XG4gICAgICAgIGlmICh0aGlzLmlucyA9PSAtMSlcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZChsZW4pO1xuICAgICAgICBlbHNlIGlmIChsZW4gPT0gdGhpcy5pbnMpXG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlucyAtPSBsZW47XG4gICAgICAgICAgICB0aGlzLm9mZiArPSBsZW47XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuQSBzaW5nbGUgc2VsZWN0aW9uIHJhbmdlLiBXaGVuXG5bYGFsbG93TXVsdGlwbGVTZWxlY3Rpb25zYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5hbGxvd011bHRpcGxlU2VsZWN0aW9ucylcbmlzIGVuYWJsZWQsIGEgW3NlbGVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTZWxlY3Rpb24pIG1heSBob2xkXG5tdWx0aXBsZSByYW5nZXMuIEJ5IGRlZmF1bHQsIHNlbGVjdGlvbnMgaG9sZCBleGFjdGx5IG9uZSByYW5nZS5cbiovXG5jbGFzcyBTZWxlY3Rpb25SYW5nZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGxvd2VyIGJvdW5kYXJ5IG9mIHRoZSByYW5nZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSB1cHBlciBib3VuZGFyeSBvZiB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgZmxhZ3MpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBhbmNob3Igb2YgdGhlIHJhbmdl4oCUdGhlIHNpZGUgdGhhdCBkb2Vzbid0IG1vdmUgd2hlbiB5b3VcbiAgICBleHRlbmQgaXQuXG4gICAgKi9cbiAgICBnZXQgYW5jaG9yKCkgeyByZXR1cm4gdGhpcy5mbGFncyAmIDMyIC8qIFJhbmdlRmxhZy5JbnZlcnRlZCAqLyA/IHRoaXMudG8gOiB0aGlzLmZyb207IH1cbiAgICAvKipcbiAgICBUaGUgaGVhZCBvZiB0aGUgcmFuZ2UsIHdoaWNoIGlzIG1vdmVkIHdoZW4gdGhlIHJhbmdlIGlzXG4gICAgW2V4dGVuZGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvblJhbmdlLmV4dGVuZCkuXG4gICAgKi9cbiAgICBnZXQgaGVhZCgpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgJiAzMiAvKiBSYW5nZUZsYWcuSW52ZXJ0ZWQgKi8gPyB0aGlzLmZyb20gOiB0aGlzLnRvOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIGBhbmNob3JgIGFuZCBgaGVhZGAgYXJlIGF0IHRoZSBzYW1lIHBvc2l0aW9uLlxuICAgICovXG4gICAgZ2V0IGVtcHR5KCkgeyByZXR1cm4gdGhpcy5mcm9tID09IHRoaXMudG87IH1cbiAgICAvKipcbiAgICBJZiB0aGlzIGlzIGEgY3Vyc29yIHRoYXQgaXMgZXhwbGljaXRseSBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAgY2hhcmFjdGVyIG9uIG9uZSBvZiBpdHMgc2lkZXMsIHRoaXMgcmV0dXJucyB0aGUgc2lkZS4gLTEgbWVhbnNcbiAgICB0aGUgY2hhcmFjdGVyIGJlZm9yZSBpdHMgcG9zaXRpb24sIDEgdGhlIGNoYXJhY3RlciBhZnRlciwgYW5kIDBcbiAgICBtZWFucyBubyBhc3NvY2lhdGlvbi5cbiAgICAqL1xuICAgIGdldCBhc3NvYygpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgJiA4IC8qIFJhbmdlRmxhZy5Bc3NvY0JlZm9yZSAqLyA/IC0xIDogdGhpcy5mbGFncyAmIDE2IC8qIFJhbmdlRmxhZy5Bc3NvY0FmdGVyICovID8gMSA6IDA7IH1cbiAgICAvKipcbiAgICBUaGUgYmlkaXJlY3Rpb25hbCB0ZXh0IGxldmVsIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGN1cnNvciwgaWZcbiAgICBhbnkuXG4gICAgKi9cbiAgICBnZXQgYmlkaUxldmVsKCkge1xuICAgICAgICBsZXQgbGV2ZWwgPSB0aGlzLmZsYWdzICYgNyAvKiBSYW5nZUZsYWcuQmlkaUxldmVsTWFzayAqLztcbiAgICAgICAgcmV0dXJuIGxldmVsID09IDcgPyBudWxsIDogbGV2ZWw7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBnb2FsIGNvbHVtbiAoc3RvcmVkIHZlcnRpY2FsIG9mZnNldCkgYXNzb2NpYXRlZCB3aXRoIGFcbiAgICBjdXJzb3IuIFRoaXMgaXMgdXNlZCB0byBwcmVzZXJ2ZSB0aGUgdmVydGljYWwgcG9zaXRpb24gd2hlblxuICAgIFttb3ZpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3Lm1vdmVWZXJ0aWNhbGx5KSBhY3Jvc3NcbiAgICBsaW5lcyBvZiBkaWZmZXJlbnQgbGVuZ3RoLlxuICAgICovXG4gICAgZ2V0IGdvYWxDb2x1bW4oKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZmxhZ3MgPj4gNiAvKiBSYW5nZUZsYWcuR29hbENvbHVtbk9mZnNldCAqLztcbiAgICAgICAgcmV0dXJuIHZhbHVlID09IDE2Nzc3MjE1IC8qIFJhbmdlRmxhZy5Ob0dvYWxDb2x1bW4gKi8gPyB1bmRlZmluZWQgOiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIHRoaXMgcmFuZ2UgdGhyb3VnaCBhIGNoYW5nZSwgcHJvZHVjaW5nIGEgdmFsaWQgcmFuZ2UgaW4gdGhlXG4gICAgdXBkYXRlZCBkb2N1bWVudC5cbiAgICAqL1xuICAgIG1hcChjaGFuZ2UsIGFzc29jID0gLTEpIHtcbiAgICAgICAgbGV0IGZyb20sIHRvO1xuICAgICAgICBpZiAodGhpcy5lbXB0eSkge1xuICAgICAgICAgICAgZnJvbSA9IHRvID0gY2hhbmdlLm1hcFBvcyh0aGlzLmZyb20sIGFzc29jKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyb20gPSBjaGFuZ2UubWFwUG9zKHRoaXMuZnJvbSwgMSk7XG4gICAgICAgICAgICB0byA9IGNoYW5nZS5tYXBQb3ModGhpcy50bywgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcm9tID09IHRoaXMuZnJvbSAmJiB0byA9PSB0aGlzLnRvID8gdGhpcyA6IG5ldyBTZWxlY3Rpb25SYW5nZShmcm9tLCB0bywgdGhpcy5mbGFncyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEV4dGVuZCB0aGlzIHJhbmdlIHRvIGNvdmVyIGF0IGxlYXN0IGBmcm9tYCB0byBgdG9gLlxuICAgICovXG4gICAgZXh0ZW5kKGZyb20sIHRvID0gZnJvbSkge1xuICAgICAgICBpZiAoZnJvbSA8PSB0aGlzLmFuY2hvciAmJiB0byA+PSB0aGlzLmFuY2hvcilcbiAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICBsZXQgaGVhZCA9IE1hdGguYWJzKGZyb20gLSB0aGlzLmFuY2hvcikgPiBNYXRoLmFicyh0byAtIHRoaXMuYW5jaG9yKSA/IGZyb20gOiB0bztcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZSh0aGlzLmFuY2hvciwgaGVhZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyByYW5nZSB0byBhbm90aGVyIHJhbmdlLlxuICAgICovXG4gICAgZXEob3RoZXIsIGluY2x1ZGVBc3NvYyA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuY2hvciA9PSBvdGhlci5hbmNob3IgJiYgdGhpcy5oZWFkID09IG90aGVyLmhlYWQgJiZcbiAgICAgICAgICAgICghaW5jbHVkZUFzc29jIHx8ICF0aGlzLmVtcHR5IHx8IHRoaXMuYXNzb2MgPT0gb3RoZXIuYXNzb2MpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSBKU09OLXNlcmlhbGl6YWJsZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSByYW5nZS5cbiAgICAqL1xuICAgIHRvSlNPTigpIHsgcmV0dXJuIHsgYW5jaG9yOiB0aGlzLmFuY2hvciwgaGVhZDogdGhpcy5oZWFkIH07IH1cbiAgICAvKipcbiAgICBDb252ZXJ0IGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIHJhbmdlIHRvIGEgYFNlbGVjdGlvblJhbmdlYFxuICAgIGluc3RhbmNlLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uIHx8IHR5cGVvZiBqc29uLmFuY2hvciAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmhlYWQgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIGZvciBTZWxlY3Rpb25SYW5nZVwiKTtcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShqc29uLmFuY2hvciwganNvbi5oZWFkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGZyb20sIHRvLCBmbGFncykge1xuICAgICAgICByZXR1cm4gbmV3IFNlbGVjdGlvblJhbmdlKGZyb20sIHRvLCBmbGFncyk7XG4gICAgfVxufVxuLyoqXG5BbiBlZGl0b3Igc2VsZWN0aW9uIGhvbGRzIG9uZSBvciBtb3JlIHNlbGVjdGlvbiByYW5nZXMuXG4qL1xuY2xhc3MgRWRpdG9yU2VsZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcmFuZ2VzIGluIHRoZSBzZWxlY3Rpb24sIHNvcnRlZCBieSBwb3NpdGlvbi4gUmFuZ2VzIGNhbm5vdFxuICAgIG92ZXJsYXAgKGJ1dCB0aGV5IG1heSB0b3VjaCwgaWYgdGhleSBhcmVuJ3QgZW1wdHkpLlxuICAgICovXG4gICAgcmFuZ2VzLCBcbiAgICAvKipcbiAgICBUaGUgaW5kZXggb2YgdGhlIF9tYWluXyByYW5nZSBpbiB0aGUgc2VsZWN0aW9uICh3aGljaCBpc1xuICAgIHVzdWFsbHkgdGhlIHJhbmdlIHRoYXQgd2FzIGFkZGVkIGxhc3QpLlxuICAgICovXG4gICAgbWFpbkluZGV4KSB7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLm1haW5JbmRleCA9IG1haW5JbmRleDtcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIGEgc2VsZWN0aW9uIHRocm91Z2ggYSBjaGFuZ2UuIFVzZWQgdG8gYWRqdXN0IHRoZSBzZWxlY3Rpb25cbiAgICBwb3NpdGlvbiBmb3IgY2hhbmdlcy5cbiAgICAqL1xuICAgIG1hcChjaGFuZ2UsIGFzc29jID0gLTEpIHtcbiAgICAgICAgaWYgKGNoYW5nZS5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZSh0aGlzLnJhbmdlcy5tYXAociA9PiByLm1hcChjaGFuZ2UsIGFzc29jKSksIHRoaXMubWFpbkluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIHNlbGVjdGlvbiB0byBhbm90aGVyIHNlbGVjdGlvbi4gQnkgZGVmYXVsdCwgcmFuZ2VzXG4gICAgYXJlIGNvbXBhcmVkIG9ubHkgYnkgcG9zaXRpb24uIFdoZW4gYGluY2x1ZGVBc3NvY2AgaXMgdHJ1ZSxcbiAgICBjdXJzb3IgcmFuZ2VzIG11c3QgYWxzbyBoYXZlIHRoZSBzYW1lXG4gICAgW2Bhc3NvY2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU2VsZWN0aW9uUmFuZ2UuYXNzb2MpIHZhbHVlLlxuICAgICovXG4gICAgZXEob3RoZXIsIGluY2x1ZGVBc3NvYyA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlcy5sZW5ndGggIT0gb3RoZXIucmFuZ2VzLmxlbmd0aCB8fFxuICAgICAgICAgICAgdGhpcy5tYWluSW5kZXggIT0gb3RoZXIubWFpbkluZGV4KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnJhbmdlc1tpXS5lcShvdGhlci5yYW5nZXNbaV0sIGluY2x1ZGVBc3NvYykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBwcmltYXJ5IHNlbGVjdGlvbiByYW5nZS4gVXN1YWxseSwgeW91IHNob3VsZCBtYWtlIHN1cmVcbiAgICB5b3VyIGNvZGUgYXBwbGllcyB0byBfYWxsXyByYW5nZXMsIGJ5IHVzaW5nIG1ldGhvZHMgbGlrZVxuICAgIFtgY2hhbmdlQnlSYW5nZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhbmdlQnlSYW5nZSkuXG4gICAgKi9cbiAgICBnZXQgbWFpbigpIHsgcmV0dXJuIHRoaXMucmFuZ2VzW3RoaXMubWFpbkluZGV4XTsgfVxuICAgIC8qKlxuICAgIE1ha2Ugc3VyZSB0aGUgc2VsZWN0aW9uIG9ubHkgaGFzIG9uZSByYW5nZS4gUmV0dXJucyBhIHNlbGVjdGlvblxuICAgIGhvbGRpbmcgb25seSB0aGUgbWFpbiByYW5nZSBmcm9tIHRoaXMgc2VsZWN0aW9uLlxuICAgICovXG4gICAgYXNTaW5nbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlcy5sZW5ndGggPT0gMSA/IHRoaXMgOiBuZXcgRWRpdG9yU2VsZWN0aW9uKFt0aGlzLm1haW5dLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRXh0ZW5kIHRoaXMgc2VsZWN0aW9uIHdpdGggYW4gZXh0cmEgcmFuZ2UuXG4gICAgKi9cbiAgICBhZGRSYW5nZShyYW5nZSwgbWFpbiA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoW3JhbmdlXS5jb25jYXQodGhpcy5yYW5nZXMpLCBtYWluID8gMCA6IHRoaXMubWFpbkluZGV4ICsgMSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgYSBnaXZlbiByYW5nZSB3aXRoIGFub3RoZXIgcmFuZ2UsIGFuZCB0aGVuIG5vcm1hbGl6ZSB0aGVcbiAgICBzZWxlY3Rpb24gdG8gbWVyZ2UgYW5kIHNvcnQgcmFuZ2VzIGlmIG5lY2Vzc2FyeS5cbiAgICAqL1xuICAgIHJlcGxhY2VSYW5nZShyYW5nZSwgd2hpY2ggPSB0aGlzLm1haW5JbmRleCkge1xuICAgICAgICBsZXQgcmFuZ2VzID0gdGhpcy5yYW5nZXMuc2xpY2UoKTtcbiAgICAgICAgcmFuZ2VzW3doaWNoXSA9IHJhbmdlO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIHRoaXMubWFpbkluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29udmVydCB0aGlzIHNlbGVjdGlvbiB0byBhbiBvYmplY3QgdGhhdCBjYW4gYmUgc2VyaWFsaXplZCB0b1xuICAgIEpTT04uXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlczogdGhpcy5yYW5nZXMubWFwKHIgPT4gci50b0pTT04oKSksIG1haW46IHRoaXMubWFpbkluZGV4IH07XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNlbGVjdGlvbiBmcm9tIGEgSlNPTiByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghanNvbiB8fCAhQXJyYXkuaXNBcnJheShqc29uLnJhbmdlcykgfHwgdHlwZW9mIGpzb24ubWFpbiAhPSBcIm51bWJlclwiIHx8IGpzb24ubWFpbiA+PSBqc29uLnJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgRWRpdG9yU2VsZWN0aW9uXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEVkaXRvclNlbGVjdGlvbihqc29uLnJhbmdlcy5tYXAoKHIpID0+IFNlbGVjdGlvblJhbmdlLmZyb21KU09OKHIpKSwganNvbi5tYWluKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2VsZWN0aW9uIGhvbGRpbmcgYSBzaW5nbGUgcmFuZ2UuXG4gICAgKi9cbiAgICBzdGF0aWMgc2luZ2xlKGFuY2hvciwgaGVhZCA9IGFuY2hvcikge1xuICAgICAgICByZXR1cm4gbmV3IEVkaXRvclNlbGVjdGlvbihbRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGFuY2hvciwgaGVhZCldLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgU29ydCBhbmQgbWVyZ2UgdGhlIGdpdmVuIHNldCBvZiByYW5nZXMsIGNyZWF0aW5nIGEgdmFsaWRcbiAgICBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKHJhbmdlcywgbWFpbkluZGV4ID0gMCkge1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBIHNlbGVjdGlvbiBuZWVkcyBhdCBsZWFzdCBvbmUgcmFuZ2VcIik7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgICAgICBpZiAocmFuZ2UuZW1wdHkgPyByYW5nZS5mcm9tIDw9IHBvcyA6IHJhbmdlLmZyb20gPCBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5ub3JtYWxpemVkKHJhbmdlcy5zbGljZSgpLCBtYWluSW5kZXgpO1xuICAgICAgICAgICAgcG9zID0gcmFuZ2UudG87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTZWxlY3Rpb24ocmFuZ2VzLCBtYWluSW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjdXJzb3Igc2VsZWN0aW9uIHJhbmdlIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi4gWW91IGNhblxuICAgIHNhZmVseSBpZ25vcmUgdGhlIG9wdGlvbmFsIGFyZ3VtZW50cyBpbiBtb3N0IHNpdHVhdGlvbnMuXG4gICAgKi9cbiAgICBzdGF0aWMgY3Vyc29yKHBvcywgYXNzb2MgPSAwLCBiaWRpTGV2ZWwsIGdvYWxDb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIFNlbGVjdGlvblJhbmdlLmNyZWF0ZShwb3MsIHBvcywgKGFzc29jID09IDAgPyAwIDogYXNzb2MgPCAwID8gOCAvKiBSYW5nZUZsYWcuQXNzb2NCZWZvcmUgKi8gOiAxNiAvKiBSYW5nZUZsYWcuQXNzb2NBZnRlciAqLykgfFxuICAgICAgICAgICAgKGJpZGlMZXZlbCA9PSBudWxsID8gNyA6IE1hdGgubWluKDYsIGJpZGlMZXZlbCkpIHxcbiAgICAgICAgICAgICgoZ29hbENvbHVtbiAhPT0gbnVsbCAmJiBnb2FsQ29sdW1uICE9PSB2b2lkIDAgPyBnb2FsQ29sdW1uIDogMTY3NzcyMTUgLyogUmFuZ2VGbGFnLk5vR29hbENvbHVtbiAqLykgPDwgNiAvKiBSYW5nZUZsYWcuR29hbENvbHVtbk9mZnNldCAqLykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZWxlY3Rpb24gcmFuZ2UuXG4gICAgKi9cbiAgICBzdGF0aWMgcmFuZ2UoYW5jaG9yLCBoZWFkLCBnb2FsQ29sdW1uLCBiaWRpTGV2ZWwpIHtcbiAgICAgICAgbGV0IGZsYWdzID0gKChnb2FsQ29sdW1uICE9PSBudWxsICYmIGdvYWxDb2x1bW4gIT09IHZvaWQgMCA/IGdvYWxDb2x1bW4gOiAxNjc3NzIxNSAvKiBSYW5nZUZsYWcuTm9Hb2FsQ29sdW1uICovKSA8PCA2IC8qIFJhbmdlRmxhZy5Hb2FsQ29sdW1uT2Zmc2V0ICovKSB8XG4gICAgICAgICAgICAoYmlkaUxldmVsID09IG51bGwgPyA3IDogTWF0aC5taW4oNiwgYmlkaUxldmVsKSk7XG4gICAgICAgIHJldHVybiBoZWFkIDwgYW5jaG9yID8gU2VsZWN0aW9uUmFuZ2UuY3JlYXRlKGhlYWQsIGFuY2hvciwgMzIgLyogUmFuZ2VGbGFnLkludmVydGVkICovIHwgMTYgLyogUmFuZ2VGbGFnLkFzc29jQWZ0ZXIgKi8gfCBmbGFncylcbiAgICAgICAgICAgIDogU2VsZWN0aW9uUmFuZ2UuY3JlYXRlKGFuY2hvciwgaGVhZCwgKGhlYWQgPiBhbmNob3IgPyA4IC8qIFJhbmdlRmxhZy5Bc3NvY0JlZm9yZSAqLyA6IDApIHwgZmxhZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBub3JtYWxpemVkKHJhbmdlcywgbWFpbkluZGV4ID0gMCkge1xuICAgICAgICBsZXQgbWFpbiA9IHJhbmdlc1ttYWluSW5kZXhdO1xuICAgICAgICByYW5nZXMuc29ydCgoYSwgYikgPT4gYS5mcm9tIC0gYi5mcm9tKTtcbiAgICAgICAgbWFpbkluZGV4ID0gcmFuZ2VzLmluZGV4T2YobWFpbik7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSByYW5nZXNbaV0sIHByZXYgPSByYW5nZXNbaSAtIDFdO1xuICAgICAgICAgICAgaWYgKHJhbmdlLmVtcHR5ID8gcmFuZ2UuZnJvbSA8PSBwcmV2LnRvIDogcmFuZ2UuZnJvbSA8IHByZXYudG8pIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHByZXYuZnJvbSwgdG8gPSBNYXRoLm1heChyYW5nZS50bywgcHJldi50byk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPD0gbWFpbkluZGV4KVxuICAgICAgICAgICAgICAgICAgICBtYWluSW5kZXgtLTtcbiAgICAgICAgICAgICAgICByYW5nZXMuc3BsaWNlKC0taSwgMiwgcmFuZ2UuYW5jaG9yID4gcmFuZ2UuaGVhZCA/IEVkaXRvclNlbGVjdGlvbi5yYW5nZSh0bywgZnJvbSkgOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVkaXRvclNlbGVjdGlvbihyYW5nZXMsIG1haW5JbmRleCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tTZWxlY3Rpb24oc2VsZWN0aW9uLCBkb2NMZW5ndGgpIHtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBzZWxlY3Rpb24ucmFuZ2VzKVxuICAgICAgICBpZiAocmFuZ2UudG8gPiBkb2NMZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlNlbGVjdGlvbiBwb2ludHMgb3V0c2lkZSBvZiBkb2N1bWVudFwiKTtcbn1cblxubGV0IG5leHRJRCA9IDA7XG4vKipcbkEgZmFjZXQgaXMgYSBsYWJlbGVkIHZhbHVlIHRoYXQgaXMgYXNzb2NpYXRlZCB3aXRoIGFuIGVkaXRvclxuc3RhdGUuIEl0IHRha2VzIGlucHV0cyBmcm9tIGFueSBudW1iZXIgb2YgZXh0ZW5zaW9ucywgYW5kIGNvbWJpbmVzXG50aG9zZSBpbnRvIGEgc2luZ2xlIG91dHB1dCB2YWx1ZS5cblxuRXhhbXBsZXMgb2YgdXNlcyBvZiBmYWNldHMgYXJlIHRoZSBbdGFiXG5zaXplXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRhYlNpemUpLCBbZWRpdG9yXG5hdHRyaWJ1dGVzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15lZGl0b3JBdHRyaWJ1dGVzKSwgYW5kIFt1cGRhdGVcbmxpc3RlbmVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdedXBkYXRlTGlzdGVuZXIpLlxuXG5Ob3RlIHRoYXQgYEZhY2V0YCBpbnN0YW5jZXMgY2FuIGJlIHVzZWQgYW55d2hlcmUgd2hlcmVcbltgRmFjZXRSZWFkZXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkZhY2V0UmVhZGVyKSBpcyBleHBlY3RlZC5cbiovXG5jbGFzcyBGYWNldCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21iaW5lLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXBhcmVJbnB1dCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXJlLCBpc1N0YXRpYywgZW5hYmxlcykge1xuICAgICAgICB0aGlzLmNvbWJpbmUgPSBjb21iaW5lO1xuICAgICAgICB0aGlzLmNvbXBhcmVJbnB1dCA9IGNvbXBhcmVJbnB1dDtcbiAgICAgICAgdGhpcy5jb21wYXJlID0gY29tcGFyZTtcbiAgICAgICAgdGhpcy5pc1N0YXRpYyA9IGlzU3RhdGljO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBuZXh0SUQrKztcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gY29tYmluZShbXSk7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHR5cGVvZiBlbmFibGVzID09IFwiZnVuY3Rpb25cIiA/IGVuYWJsZXModGhpcykgOiBlbmFibGVzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGEgZmFjZXQgcmVhZGVyIGZvciB0aGlzIGZhY2V0LCB3aGljaCBjYW4gYmUgdXNlZCB0b1xuICAgIFtyZWFkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmZhY2V0KSBpdCBidXQgbm90IHRvIGRlZmluZSB2YWx1ZXMgZm9yIGl0LlxuICAgICovXG4gICAgZ2V0IHJlYWRlcigpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBuZXcgZmFjZXQuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgRmFjZXQoY29uZmlnLmNvbWJpbmUgfHwgKChhKSA9PiBhKSwgY29uZmlnLmNvbXBhcmVJbnB1dCB8fCAoKGEsIGIpID0+IGEgPT09IGIpLCBjb25maWcuY29tcGFyZSB8fCAoIWNvbmZpZy5jb21iaW5lID8gc2FtZUFycmF5IDogKGEsIGIpID0+IGEgPT09IGIpLCAhIWNvbmZpZy5zdGF0aWMsIGNvbmZpZy5lbmFibGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBhZGRzIHRoZSBnaXZlbiB2YWx1ZSB0byB0aGlzIGZhY2V0LlxuICAgICovXG4gICAgb2YodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWNldFByb3ZpZGVyKFtdLCB0aGlzLCAwIC8qIFByb3ZpZGVyLlN0YXRpYyAqLywgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgY29tcHV0ZXMgYSB2YWx1ZSBmb3IgdGhlIGZhY2V0IGZyb20gYVxuICAgIHN0YXRlLiBZb3UgbXVzdCB0YWtlIGNhcmUgdG8gZGVjbGFyZSB0aGUgcGFydHMgb2YgdGhlIHN0YXRlIHRoYXRcbiAgICB0aGlzIHZhbHVlIGRlcGVuZHMgb24sIHNpbmNlIHlvdXIgZnVuY3Rpb24gaXMgb25seSBjYWxsZWQgYWdhaW5cbiAgICBmb3IgYSBuZXcgc3RhdGUgd2hlbiBvbmUgb2YgdGhvc2UgcGFydHMgY2hhbmdlZC5cbiAgICBcbiAgICBJbiBjYXNlcyB3aGVyZSB5b3VyIHZhbHVlIGRlcGVuZHMgb25seSBvbiBhIHNpbmdsZSBmaWVsZCwgeW91J2xsXG4gICAgd2FudCB0byB1c2UgdGhlIFtgZnJvbWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRmFjZXQuZnJvbSkgbWV0aG9kIGluc3RlYWQuXG4gICAgKi9cbiAgICBjb21wdXRlKGRlcHMsIGdldCkge1xuICAgICAgICBpZiAodGhpcy5pc1N0YXRpYylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbXB1dGUgYSBzdGF0aWMgZmFjZXRcIik7XG4gICAgICAgIHJldHVybiBuZXcgRmFjZXRQcm92aWRlcihkZXBzLCB0aGlzLCAxIC8qIFByb3ZpZGVyLlNpbmdsZSAqLywgZ2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGNvbXB1dGVzIHplcm8gb3IgbW9yZSB2YWx1ZXMgZm9yIHRoaXNcbiAgICBmYWNldCBmcm9tIGEgc3RhdGUuXG4gICAgKi9cbiAgICBjb21wdXRlTihkZXBzLCBnZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTdGF0aWMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBjb21wdXRlIGEgc3RhdGljIGZhY2V0XCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZhY2V0UHJvdmlkZXIoZGVwcywgdGhpcywgMiAvKiBQcm92aWRlci5NdWx0aSAqLywgZ2V0KTtcbiAgICB9XG4gICAgZnJvbShmaWVsZCwgZ2V0KSB7XG4gICAgICAgIGlmICghZ2V0KVxuICAgICAgICAgICAgZ2V0ID0geCA9PiB4O1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlKFtmaWVsZF0sIHN0YXRlID0+IGdldChzdGF0ZS5maWVsZChmaWVsZCkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzYW1lQXJyYXkoYSwgYikge1xuICAgIHJldHVybiBhID09IGIgfHwgYS5sZW5ndGggPT0gYi5sZW5ndGggJiYgYS5ldmVyeSgoZSwgaSkgPT4gZSA9PT0gYltpXSk7XG59XG5jbGFzcyBGYWNldFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihkZXBlbmRlbmNpZXMsIGZhY2V0LCB0eXBlLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcztcbiAgICAgICAgdGhpcy5mYWNldCA9IGZhY2V0O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaWQgPSBuZXh0SUQrKztcbiAgICB9XG4gICAgZHluYW1pY1Nsb3QoYWRkcmVzc2VzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGdldHRlciA9IHRoaXMudmFsdWU7XG4gICAgICAgIGxldCBjb21wYXJlID0gdGhpcy5mYWNldC5jb21wYXJlSW5wdXQ7XG4gICAgICAgIGxldCBpZCA9IHRoaXMuaWQsIGlkeCA9IGFkZHJlc3Nlc1tpZF0gPj4gMSwgbXVsdGkgPSB0aGlzLnR5cGUgPT0gMiAvKiBQcm92aWRlci5NdWx0aSAqLztcbiAgICAgICAgbGV0IGRlcERvYyA9IGZhbHNlLCBkZXBTZWwgPSBmYWxzZSwgZGVwQWRkcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZGVwIG9mIHRoaXMuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICBpZiAoZGVwID09IFwiZG9jXCIpXG4gICAgICAgICAgICAgICAgZGVwRG9jID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGRlcCA9PSBcInNlbGVjdGlvblwiKVxuICAgICAgICAgICAgICAgIGRlcFNlbCA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmICgoKChfYSA9IGFkZHJlc3Nlc1tkZXAuaWRdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxKSAmIDEpID09IDApXG4gICAgICAgICAgICAgICAgZGVwQWRkcnMucHVzaChhZGRyZXNzZXNbZGVwLmlkXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0ZShzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gZ2V0dGVyKHN0YXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlKHN0YXRlLCB0cikge1xuICAgICAgICAgICAgICAgIGlmICgoZGVwRG9jICYmIHRyLmRvY0NoYW5nZWQpIHx8IChkZXBTZWwgJiYgKHRyLmRvY0NoYW5nZWQgfHwgdHIuc2VsZWN0aW9uKSkgfHwgZW5zdXJlQWxsKHN0YXRlLCBkZXBBZGRycykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1ZhbCA9IGdldHRlcihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aSA/ICFjb21wYXJlQXJyYXkobmV3VmFsLCBzdGF0ZS52YWx1ZXNbaWR4XSwgY29tcGFyZSkgOiAhY29tcGFyZShuZXdWYWwsIHN0YXRlLnZhbHVlc1tpZHhdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBuZXdWYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVjb25maWd1cmU6IChzdGF0ZSwgb2xkU3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbmV3VmFsLCBvbGRBZGRyID0gb2xkU3RhdGUuY29uZmlnLmFkZHJlc3NbaWRdO1xuICAgICAgICAgICAgICAgIGlmIChvbGRBZGRyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9sZFZhbCA9IGdldEFkZHIob2xkU3RhdGUsIG9sZEFkZHIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXBlbmRlbmNpZXMuZXZlcnkoZGVwID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXAgaW5zdGFuY2VvZiBGYWNldCA/IG9sZFN0YXRlLmZhY2V0KGRlcCkgPT09IHN0YXRlLmZhY2V0KGRlcCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcCBpbnN0YW5jZW9mIFN0YXRlRmllbGQgPyBvbGRTdGF0ZS5maWVsZChkZXAsIGZhbHNlKSA9PSBzdGF0ZS5maWVsZChkZXAsIGZhbHNlKSA6IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pIHx8IChtdWx0aSA/IGNvbXBhcmVBcnJheShuZXdWYWwgPSBnZXR0ZXIoc3RhdGUpLCBvbGRWYWwsIGNvbXBhcmUpIDogY29tcGFyZShuZXdWYWwgPSBnZXR0ZXIoc3RhdGUpLCBvbGRWYWwpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBvbGRWYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsID0gZ2V0dGVyKHN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBuZXdWYWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBhcmVBcnJheShhLCBiLCBjb21wYXJlKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoIWNvbXBhcmUoYVtpXSwgYltpXSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBlbnN1cmVBbGwoc3RhdGUsIGFkZHJzKSB7XG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBhZGRyIG9mIGFkZHJzKVxuICAgICAgICBpZiAoZW5zdXJlQWRkcihzdGF0ZSwgYWRkcikgJiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLylcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgIHJldHVybiBjaGFuZ2VkO1xufVxuZnVuY3Rpb24gZHluYW1pY0ZhY2V0U2xvdChhZGRyZXNzZXMsIGZhY2V0LCBwcm92aWRlcnMpIHtcbiAgICBsZXQgcHJvdmlkZXJBZGRycyA9IHByb3ZpZGVycy5tYXAocCA9PiBhZGRyZXNzZXNbcC5pZF0pO1xuICAgIGxldCBwcm92aWRlclR5cGVzID0gcHJvdmlkZXJzLm1hcChwID0+IHAudHlwZSk7XG4gICAgbGV0IGR5bmFtaWMgPSBwcm92aWRlckFkZHJzLmZpbHRlcihwID0+ICEocCAmIDEpKTtcbiAgICBsZXQgaWR4ID0gYWRkcmVzc2VzW2ZhY2V0LmlkXSA+PiAxO1xuICAgIGZ1bmN0aW9uIGdldChzdGF0ZSkge1xuICAgICAgICBsZXQgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvdmlkZXJBZGRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gZ2V0QWRkcihzdGF0ZSwgcHJvdmlkZXJBZGRyc1tpXSk7XG4gICAgICAgICAgICBpZiAocHJvdmlkZXJUeXBlc1tpXSA9PSAyIC8qIFByb3ZpZGVyLk11bHRpICovKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHZhbCBvZiB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhY2V0LmNvbWJpbmUodmFsdWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3JlYXRlKHN0YXRlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBhZGRyIG9mIHByb3ZpZGVyQWRkcnMpXG4gICAgICAgICAgICAgICAgZW5zdXJlQWRkcihzdGF0ZSwgYWRkcik7XG4gICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IGdldChzdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZShzdGF0ZSwgdHIpIHtcbiAgICAgICAgICAgIGlmICghZW5zdXJlQWxsKHN0YXRlLCBkeW5hbWljKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGdldChzdGF0ZSk7XG4gICAgICAgICAgICBpZiAoZmFjZXQuY29tcGFyZSh2YWx1ZSwgc3RhdGUudmFsdWVzW2lkeF0pKVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgfSxcbiAgICAgICAgcmVjb25maWd1cmUoc3RhdGUsIG9sZFN0YXRlKSB7XG4gICAgICAgICAgICBsZXQgZGVwQ2hhbmdlZCA9IGVuc3VyZUFsbChzdGF0ZSwgcHJvdmlkZXJBZGRycyk7XG4gICAgICAgICAgICBsZXQgb2xkUHJvdmlkZXJzID0gb2xkU3RhdGUuY29uZmlnLmZhY2V0c1tmYWNldC5pZF0sIG9sZFZhbHVlID0gb2xkU3RhdGUuZmFjZXQoZmFjZXQpO1xuICAgICAgICAgICAgaWYgKG9sZFByb3ZpZGVycyAmJiAhZGVwQ2hhbmdlZCAmJiBzYW1lQXJyYXkocHJvdmlkZXJzLCBvbGRQcm92aWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBvbGRWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGdldChzdGF0ZSk7XG4gICAgICAgICAgICBpZiAoZmFjZXQuY29tcGFyZSh2YWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBvbGRWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgIH1cbiAgICB9O1xufVxuY29uc3QgaW5pdEZpZWxkID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IHN0YXRpYzogdHJ1ZSB9KTtcbi8qKlxuRmllbGRzIGNhbiBzdG9yZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGluIGFuIGVkaXRvciBzdGF0ZSwgYW5kXG5rZWVwIGl0IGluIHN5bmMgd2l0aCB0aGUgcmVzdCBvZiB0aGUgc3RhdGUuXG4qL1xuY2xhc3MgU3RhdGVGaWVsZCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpZCwgY3JlYXRlRiwgdXBkYXRlRiwgY29tcGFyZUYsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3BlYykge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuY3JlYXRlRiA9IGNyZWF0ZUY7XG4gICAgICAgIHRoaXMudXBkYXRlRiA9IHVwZGF0ZUY7XG4gICAgICAgIHRoaXMuY29tcGFyZUYgPSBjb21wYXJlRjtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb3ZpZGVzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBzdGF0ZSBmaWVsZC5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoY29uZmlnKSB7XG4gICAgICAgIGxldCBmaWVsZCA9IG5ldyBTdGF0ZUZpZWxkKG5leHRJRCsrLCBjb25maWcuY3JlYXRlLCBjb25maWcudXBkYXRlLCBjb25maWcuY29tcGFyZSB8fCAoKGEsIGIpID0+IGEgPT09IGIpLCBjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLnByb3ZpZGUpXG4gICAgICAgICAgICBmaWVsZC5wcm92aWRlcyA9IGNvbmZpZy5wcm92aWRlKGZpZWxkKTtcbiAgICAgICAgcmV0dXJuIGZpZWxkO1xuICAgIH1cbiAgICBjcmVhdGUoc3RhdGUpIHtcbiAgICAgICAgbGV0IGluaXQgPSBzdGF0ZS5mYWNldChpbml0RmllbGQpLmZpbmQoaSA9PiBpLmZpZWxkID09IHRoaXMpO1xuICAgICAgICByZXR1cm4gKChpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQuY3JlYXRlKSB8fCB0aGlzLmNyZWF0ZUYpKHN0YXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzbG90KGFkZHJlc3Nlcykge1xuICAgICAgICBsZXQgaWR4ID0gYWRkcmVzc2VzW3RoaXMuaWRdID4+IDE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGU6IChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gdGhpcy5jcmVhdGUoc3RhdGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGU6IChzdGF0ZSwgdHIpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgb2xkVmFsID0gc3RhdGUudmFsdWVzW2lkeF07XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy51cGRhdGVGKG9sZFZhbCwgdHIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhcmVGKG9sZFZhbCwgdmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWNvbmZpZ3VyZTogKHN0YXRlLCBvbGRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBpbml0ID0gc3RhdGUuZmFjZXQoaW5pdEZpZWxkKSwgb2xkSW5pdCA9IG9sZFN0YXRlLmZhY2V0KGluaXRGaWVsZCksIHJlSW5pdDtcbiAgICAgICAgICAgICAgICBpZiAoKHJlSW5pdCA9IGluaXQuZmluZChpID0+IGkuZmllbGQgPT0gdGhpcykpICYmIHJlSW5pdCAhPSBvbGRJbml0LmZpbmQoaSA9PiBpLmZpZWxkID09IHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gcmVJbml0LmNyZWF0ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9sZFN0YXRlLmNvbmZpZy5hZGRyZXNzW3RoaXMuaWRdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBvbGRTdGF0ZS5maWVsZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gdGhpcy5jcmVhdGUoc3RhdGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIHRoaXMgZmllbGQgYW5kIG92ZXJyaWRlcyB0aGVcbiAgICB3YXkgaXQgaXMgaW5pdGlhbGl6ZWQuIENhbiBiZSB1c2VmdWwgd2hlbiB5b3UgbmVlZCB0byBwcm92aWRlIGFcbiAgICBub24tZGVmYXVsdCBzdGFydGluZyB2YWx1ZSBmb3IgdGhlIGZpZWxkLlxuICAgICovXG4gICAgaW5pdChjcmVhdGUpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLCBpbml0RmllbGQub2YoeyBmaWVsZDogdGhpcywgY3JlYXRlIH0pXTtcbiAgICB9XG4gICAgLyoqXG4gICAgU3RhdGUgZmllbGQgaW5zdGFuY2VzIGNhbiBiZSB1c2VkIGFzXG4gICAgW2BFeHRlbnNpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkV4dGVuc2lvbikgdmFsdWVzIHRvIGVuYWJsZSB0aGUgZmllbGQgaW4gYVxuICAgIGdpdmVuIHN0YXRlLlxuICAgICovXG4gICAgZ2V0IGV4dGVuc2lvbigpIHsgcmV0dXJuIHRoaXM7IH1cbn1cbmNvbnN0IFByZWNfID0geyBsb3dlc3Q6IDQsIGxvdzogMywgZGVmYXVsdDogMiwgaGlnaDogMSwgaGlnaGVzdDogMCB9O1xuZnVuY3Rpb24gcHJlYyh2YWx1ZSkge1xuICAgIHJldHVybiAoZXh0KSA9PiBuZXcgUHJlY0V4dGVuc2lvbihleHQsIHZhbHVlKTtcbn1cbi8qKlxuQnkgZGVmYXVsdCBleHRlbnNpb25zIGFyZSByZWdpc3RlcmVkIGluIHRoZSBvcmRlciB0aGV5IGFyZSBmb3VuZFxuaW4gdGhlIGZsYXR0ZW5lZCBmb3JtIG9mIG5lc3RlZCBhcnJheSB0aGF0IHdhcyBwcm92aWRlZC5cbkluZGl2aWR1YWwgZXh0ZW5zaW9uIHZhbHVlcyBjYW4gYmUgYXNzaWduZWQgYSBwcmVjZWRlbmNlIHRvXG5vdmVycmlkZSB0aGlzLiBFeHRlbnNpb25zIHRoYXQgZG8gbm90IGhhdmUgYSBwcmVjZWRlbmNlIHNldCBnZXRcbnRoZSBwcmVjZWRlbmNlIG9mIHRoZSBuZWFyZXN0IHBhcmVudCB3aXRoIGEgcHJlY2VkZW5jZSwgb3JcbltgZGVmYXVsdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUHJlYy5kZWZhdWx0KSBpZiB0aGVyZSBpcyBubyBzdWNoIHBhcmVudC4gVGhlXG5maW5hbCBvcmRlcmluZyBvZiBleHRlbnNpb25zIGlzIGRldGVybWluZWQgYnkgZmlyc3Qgc29ydGluZyBieVxucHJlY2VkZW5jZSBhbmQgdGhlbiBieSBvcmRlciB3aXRoaW4gZWFjaCBwcmVjZWRlbmNlLlxuKi9cbmNvbnN0IFByZWMgPSB7XG4gICAgLyoqXG4gICAgVGhlIGhpZ2hlc3QgcHJlY2VkZW5jZSBsZXZlbCwgZm9yIGV4dGVuc2lvbnMgdGhhdCBzaG91bGQgZW5kIHVwXG4gICAgbmVhciB0aGUgc3RhcnQgb2YgdGhlIHByZWNlZGVuY2Ugb3JkZXJpbmcuXG4gICAgKi9cbiAgICBoaWdoZXN0OiAvKkBfX1BVUkVfXyovcHJlYyhQcmVjXy5oaWdoZXN0KSxcbiAgICAvKipcbiAgICBBIGhpZ2hlci10aGFuLWRlZmF1bHQgcHJlY2VkZW5jZSwgZm9yIGV4dGVuc2lvbnMgdGhhdCBzaG91bGRcbiAgICBjb21lIGJlZm9yZSB0aG9zZSB3aXRoIGRlZmF1bHQgcHJlY2VkZW5jZS5cbiAgICAqL1xuICAgIGhpZ2g6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmhpZ2gpLFxuICAgIC8qKlxuICAgIFRoZSBkZWZhdWx0IHByZWNlZGVuY2UsIHdoaWNoIGlzIGFsc28gdXNlZCBmb3IgZXh0ZW5zaW9uc1xuICAgIHdpdGhvdXQgYW4gZXhwbGljaXQgcHJlY2VkZW5jZS5cbiAgICAqL1xuICAgIGRlZmF1bHQ6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmRlZmF1bHQpLFxuICAgIC8qKlxuICAgIEEgbG93ZXItdGhhbi1kZWZhdWx0IHByZWNlZGVuY2UuXG4gICAgKi9cbiAgICBsb3c6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmxvdyksXG4gICAgLyoqXG4gICAgVGhlIGxvd2VzdCBwcmVjZWRlbmNlIGxldmVsLiBNZWFudCBmb3IgdGhpbmdzIHRoYXQgc2hvdWxkIGVuZCB1cFxuICAgIG5lYXIgdGhlIGVuZCBvZiB0aGUgZXh0ZW5zaW9uIG9yZGVyLlxuICAgICovXG4gICAgbG93ZXN0OiAvKkBfX1BVUkVfXyovcHJlYyhQcmVjXy5sb3dlc3QpXG59O1xuY2xhc3MgUHJlY0V4dGVuc2lvbiB7XG4gICAgY29uc3RydWN0b3IoaW5uZXIsIHByZWMpIHtcbiAgICAgICAgdGhpcy5pbm5lciA9IGlubmVyO1xuICAgICAgICB0aGlzLnByZWMgPSBwcmVjO1xuICAgIH1cbn1cbi8qKlxuRXh0ZW5zaW9uIGNvbXBhcnRtZW50cyBjYW4gYmUgdXNlZCB0byBtYWtlIGEgY29uZmlndXJhdGlvblxuZHluYW1pYy4gQnkgW3dyYXBwaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNvbXBhcnRtZW50Lm9mKSBwYXJ0IG9mIHlvdXJcbmNvbmZpZ3VyYXRpb24gaW4gYSBjb21wYXJ0bWVudCwgeW91IGNhbiBsYXRlclxuW3JlcGxhY2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ29tcGFydG1lbnQucmVjb25maWd1cmUpIHRoYXQgcGFydCB0aHJvdWdoIGFcbnRyYW5zYWN0aW9uLlxuKi9cbmNsYXNzIENvbXBhcnRtZW50IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjb21wYXJ0bWVudCB0byBhZGQgdG8geW91ciBbc3RhdGVcbiAgICBjb25maWd1cmF0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlQ29uZmlnLmV4dGVuc2lvbnMpLlxuICAgICovXG4gICAgb2YoZXh0KSB7IHJldHVybiBuZXcgQ29tcGFydG1lbnRJbnN0YW5jZSh0aGlzLCBleHQpOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIFtlZmZlY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmVmZmVjdHMpIHRoYXRcbiAgICByZWNvbmZpZ3VyZXMgdGhpcyBjb21wYXJ0bWVudC5cbiAgICAqL1xuICAgIHJlY29uZmlndXJlKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIENvbXBhcnRtZW50LnJlY29uZmlndXJlLm9mKHsgY29tcGFydG1lbnQ6IHRoaXMsIGV4dGVuc2lvbjogY29udGVudCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjdXJyZW50IGNvbnRlbnQgb2YgdGhlIGNvbXBhcnRtZW50IGluIHRoZSBzdGF0ZSwgb3JcbiAgICBgdW5kZWZpbmVkYCBpZiBpdCBpc24ndCBwcmVzZW50LlxuICAgICovXG4gICAgZ2V0KHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5jb25maWcuY29tcGFydG1lbnRzLmdldCh0aGlzKTtcbiAgICB9XG59XG5jbGFzcyBDb21wYXJ0bWVudEluc3RhbmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wYXJ0bWVudCwgaW5uZXIpIHtcbiAgICAgICAgdGhpcy5jb21wYXJ0bWVudCA9IGNvbXBhcnRtZW50O1xuICAgICAgICB0aGlzLmlubmVyID0gaW5uZXI7XG4gICAgfVxufVxuY2xhc3MgQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoYmFzZSwgY29tcGFydG1lbnRzLCBkeW5hbWljU2xvdHMsIGFkZHJlc3MsIHN0YXRpY1ZhbHVlcywgZmFjZXRzKSB7XG4gICAgICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgICAgIHRoaXMuY29tcGFydG1lbnRzID0gY29tcGFydG1lbnRzO1xuICAgICAgICB0aGlzLmR5bmFtaWNTbG90cyA9IGR5bmFtaWNTbG90cztcbiAgICAgICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgICAgICAgdGhpcy5zdGF0aWNWYWx1ZXMgPSBzdGF0aWNWYWx1ZXM7XG4gICAgICAgIHRoaXMuZmFjZXRzID0gZmFjZXRzO1xuICAgICAgICB0aGlzLnN0YXR1c1RlbXBsYXRlID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnN0YXR1c1RlbXBsYXRlLmxlbmd0aCA8IGR5bmFtaWNTbG90cy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLnN0YXR1c1RlbXBsYXRlLnB1c2goMCAvKiBTbG90U3RhdHVzLlVucmVzb2x2ZWQgKi8pO1xuICAgIH1cbiAgICBzdGF0aWNGYWNldChmYWNldCkge1xuICAgICAgICBsZXQgYWRkciA9IHRoaXMuYWRkcmVzc1tmYWNldC5pZF07XG4gICAgICAgIHJldHVybiBhZGRyID09IG51bGwgPyBmYWNldC5kZWZhdWx0IDogdGhpcy5zdGF0aWNWYWx1ZXNbYWRkciA+PiAxXTtcbiAgICB9XG4gICAgc3RhdGljIHJlc29sdmUoYmFzZSwgY29tcGFydG1lbnRzLCBvbGRTdGF0ZSkge1xuICAgICAgICBsZXQgZmllbGRzID0gW107XG4gICAgICAgIGxldCBmYWNldHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBsZXQgbmV3Q29tcGFydG1lbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCBleHQgb2YgZmxhdHRlbihiYXNlLCBjb21wYXJ0bWVudHMsIG5ld0NvbXBhcnRtZW50cykpIHtcbiAgICAgICAgICAgIGlmIChleHQgaW5zdGFuY2VvZiBTdGF0ZUZpZWxkKVxuICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKGV4dCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgKGZhY2V0c1tleHQuZmFjZXQuaWRdIHx8IChmYWNldHNbZXh0LmZhY2V0LmlkXSA9IFtdKSkucHVzaChleHQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhZGRyZXNzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGV0IHN0YXRpY1ZhbHVlcyA9IFtdO1xuICAgICAgICBsZXQgZHluYW1pY1Nsb3RzID0gW107XG4gICAgICAgIGZvciAobGV0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICAgICAgYWRkcmVzc1tmaWVsZC5pZF0gPSBkeW5hbWljU2xvdHMubGVuZ3RoIDw8IDE7XG4gICAgICAgICAgICBkeW5hbWljU2xvdHMucHVzaChhID0+IGZpZWxkLnNsb3QoYSkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvbGRGYWNldHMgPSBvbGRTdGF0ZSA9PT0gbnVsbCB8fCBvbGRTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2xkU3RhdGUuY29uZmlnLmZhY2V0cztcbiAgICAgICAgZm9yIChsZXQgaWQgaW4gZmFjZXRzKSB7XG4gICAgICAgICAgICBsZXQgcHJvdmlkZXJzID0gZmFjZXRzW2lkXSwgZmFjZXQgPSBwcm92aWRlcnNbMF0uZmFjZXQ7XG4gICAgICAgICAgICBsZXQgb2xkUHJvdmlkZXJzID0gb2xkRmFjZXRzICYmIG9sZEZhY2V0c1tpZF0gfHwgW107XG4gICAgICAgICAgICBpZiAocHJvdmlkZXJzLmV2ZXJ5KHAgPT4gcC50eXBlID09IDAgLyogUHJvdmlkZXIuU3RhdGljICovKSkge1xuICAgICAgICAgICAgICAgIGFkZHJlc3NbZmFjZXQuaWRdID0gKHN0YXRpY1ZhbHVlcy5sZW5ndGggPDwgMSkgfCAxO1xuICAgICAgICAgICAgICAgIGlmIChzYW1lQXJyYXkob2xkUHJvdmlkZXJzLCBwcm92aWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY1ZhbHVlcy5wdXNoKG9sZFN0YXRlLmZhY2V0KGZhY2V0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBmYWNldC5jb21iaW5lKHByb3ZpZGVycy5tYXAocCA9PiBwLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY1ZhbHVlcy5wdXNoKG9sZFN0YXRlICYmIGZhY2V0LmNvbXBhcmUodmFsdWUsIG9sZFN0YXRlLmZhY2V0KGZhY2V0KSkgPyBvbGRTdGF0ZS5mYWNldChmYWNldCkgOiB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcCBvZiBwcm92aWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAudHlwZSA9PSAwIC8qIFByb3ZpZGVyLlN0YXRpYyAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1twLmlkXSA9IChzdGF0aWNWYWx1ZXMubGVuZ3RoIDw8IDEpIHwgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY1ZhbHVlcy5wdXNoKHAudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1twLmlkXSA9IGR5bmFtaWNTbG90cy5sZW5ndGggPDwgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKGEgPT4gcC5keW5hbWljU2xvdChhKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkcmVzc1tmYWNldC5pZF0gPSBkeW5hbWljU2xvdHMubGVuZ3RoIDw8IDE7XG4gICAgICAgICAgICAgICAgZHluYW1pY1Nsb3RzLnB1c2goYSA9PiBkeW5hbWljRmFjZXRTbG90KGEsIGZhY2V0LCBwcm92aWRlcnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZHluYW1pYyA9IGR5bmFtaWNTbG90cy5tYXAoZiA9PiBmKGFkZHJlc3MpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb25maWd1cmF0aW9uKGJhc2UsIG5ld0NvbXBhcnRtZW50cywgZHluYW1pYywgYWRkcmVzcywgc3RhdGljVmFsdWVzLCBmYWNldHMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZsYXR0ZW4oZXh0ZW5zaW9uLCBjb21wYXJ0bWVudHMsIG5ld0NvbXBhcnRtZW50cykge1xuICAgIGxldCByZXN1bHQgPSBbW10sIFtdLCBbXSwgW10sIFtdXTtcbiAgICBsZXQgc2VlbiA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBpbm5lcihleHQsIHByZWMpIHtcbiAgICAgICAgbGV0IGtub3duID0gc2Vlbi5nZXQoZXh0KTtcbiAgICAgICAgaWYgKGtub3duICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChrbm93biA8PSBwcmVjKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IHJlc3VsdFtrbm93bl0uaW5kZXhPZihleHQpO1xuICAgICAgICAgICAgaWYgKGZvdW5kID4gLTEpXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tub3duXS5zcGxpY2UoZm91bmQsIDEpO1xuICAgICAgICAgICAgaWYgKGV4dCBpbnN0YW5jZW9mIENvbXBhcnRtZW50SW5zdGFuY2UpXG4gICAgICAgICAgICAgICAgbmV3Q29tcGFydG1lbnRzLmRlbGV0ZShleHQuY29tcGFydG1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHNlZW4uc2V0KGV4dCwgcHJlYyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV4dCkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGUgb2YgZXh0KVxuICAgICAgICAgICAgICAgIGlubmVyKGUsIHByZWMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4dCBpbnN0YW5jZW9mIENvbXBhcnRtZW50SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGlmIChuZXdDb21wYXJ0bWVudHMuaGFzKGV4dC5jb21wYXJ0bWVudCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYER1cGxpY2F0ZSB1c2Ugb2YgY29tcGFydG1lbnQgaW4gZXh0ZW5zaW9uc2ApO1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBjb21wYXJ0bWVudHMuZ2V0KGV4dC5jb21wYXJ0bWVudCkgfHwgZXh0LmlubmVyO1xuICAgICAgICAgICAgbmV3Q29tcGFydG1lbnRzLnNldChleHQuY29tcGFydG1lbnQsIGNvbnRlbnQpO1xuICAgICAgICAgICAgaW5uZXIoY29udGVudCwgcHJlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXh0IGluc3RhbmNlb2YgUHJlY0V4dGVuc2lvbikge1xuICAgICAgICAgICAgaW5uZXIoZXh0LmlubmVyLCBleHQucHJlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXh0IGluc3RhbmNlb2YgU3RhdGVGaWVsZCkge1xuICAgICAgICAgICAgcmVzdWx0W3ByZWNdLnB1c2goZXh0KTtcbiAgICAgICAgICAgIGlmIChleHQucHJvdmlkZXMpXG4gICAgICAgICAgICAgICAgaW5uZXIoZXh0LnByb3ZpZGVzLCBwcmVjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHQgaW5zdGFuY2VvZiBGYWNldFByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXN1bHRbcHJlY10ucHVzaChleHQpO1xuICAgICAgICAgICAgaWYgKGV4dC5mYWNldC5leHRlbnNpb25zKVxuICAgICAgICAgICAgICAgIGlubmVyKGV4dC5mYWNldC5leHRlbnNpb25zLCBQcmVjXy5kZWZhdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gZXh0LmV4dGVuc2lvbjtcbiAgICAgICAgICAgIGlmICghY29udGVudClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBleHRlbnNpb24gdmFsdWUgaW4gZXh0ZW5zaW9uIHNldCAoJHtleHR9KS4gVGhpcyBzb21ldGltZXMgaGFwcGVucyBiZWNhdXNlIG11bHRpcGxlIGluc3RhbmNlcyBvZiBAY29kZW1pcnJvci9zdGF0ZSBhcmUgbG9hZGVkLCBicmVha2luZyBpbnN0YW5jZW9mIGNoZWNrcy5gKTtcbiAgICAgICAgICAgIGlubmVyKGNvbnRlbnQsIHByZWMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlubmVyKGV4dGVuc2lvbiwgUHJlY18uZGVmYXVsdCk7XG4gICAgcmV0dXJuIHJlc3VsdC5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUFkZHIoc3RhdGUsIGFkZHIpIHtcbiAgICBpZiAoYWRkciAmIDEpXG4gICAgICAgIHJldHVybiAyIC8qIFNsb3RTdGF0dXMuQ29tcHV0ZWQgKi87XG4gICAgbGV0IGlkeCA9IGFkZHIgPj4gMTtcbiAgICBsZXQgc3RhdHVzID0gc3RhdGUuc3RhdHVzW2lkeF07XG4gICAgaWYgKHN0YXR1cyA9PSA0IC8qIFNsb3RTdGF0dXMuQ29tcHV0aW5nICovKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDeWNsaWMgZGVwZW5kZW5jeSBiZXR3ZWVuIGZpZWxkcyBhbmQvb3IgZmFjZXRzXCIpO1xuICAgIGlmIChzdGF0dXMgJiAyIC8qIFNsb3RTdGF0dXMuQ29tcHV0ZWQgKi8pXG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgc3RhdGUuc3RhdHVzW2lkeF0gPSA0IC8qIFNsb3RTdGF0dXMuQ29tcHV0aW5nICovO1xuICAgIGxldCBjaGFuZ2VkID0gc3RhdGUuY29tcHV0ZVNsb3Qoc3RhdGUsIHN0YXRlLmNvbmZpZy5keW5hbWljU2xvdHNbaWR4XSk7XG4gICAgcmV0dXJuIHN0YXRlLnN0YXR1c1tpZHhdID0gMiAvKiBTbG90U3RhdHVzLkNvbXB1dGVkICovIHwgY2hhbmdlZDtcbn1cbmZ1bmN0aW9uIGdldEFkZHIoc3RhdGUsIGFkZHIpIHtcbiAgICByZXR1cm4gYWRkciAmIDEgPyBzdGF0ZS5jb25maWcuc3RhdGljVmFsdWVzW2FkZHIgPj4gMV0gOiBzdGF0ZS52YWx1ZXNbYWRkciA+PiAxXTtcbn1cblxuY29uc3QgbGFuZ3VhZ2VEYXRhID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUodiA9PiB2KSxcbiAgICBzdGF0aWM6IHRydWVcbn0pO1xuY29uc3QgbGluZVNlcGFyYXRvciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzWzBdIDogdW5kZWZpbmVkLFxuICAgIHN0YXRpYzogdHJ1ZVxufSk7XG5jb25zdCBjaGFuZ2VGaWx0ZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCB0cmFuc2FjdGlvbkZpbHRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHRyYW5zYWN0aW9uRXh0ZW5kZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCByZWFkT25seSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzWzBdIDogZmFsc2Vcbn0pO1xuXG4vKipcbkFubm90YXRpb25zIGFyZSB0YWdnZWQgdmFsdWVzIHRoYXQgYXJlIHVzZWQgdG8gYWRkIG1ldGFkYXRhIHRvXG50cmFuc2FjdGlvbnMgaW4gYW4gZXh0ZW5zaWJsZSB3YXkuIFRoZXkgc2hvdWxkIGJlIHVzZWQgdG8gbW9kZWxcbnRoaW5ncyB0aGF0IGVmZmVjdCB0aGUgZW50aXJlIHRyYW5zYWN0aW9uIChzdWNoIGFzIGl0cyBbdGltZVxuc3RhbXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25edGltZSkgb3IgaW5mb3JtYXRpb24gYWJvdXQgaXRzXG5bb3JpZ2luXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uXnVzZXJFdmVudCkpLiBGb3IgZWZmZWN0cyB0aGF0IGhhcHBlblxuX2Fsb25nc2lkZV8gdGhlIG90aGVyIGNoYW5nZXMgbWFkZSBieSB0aGUgdHJhbnNhY3Rpb24sIFtzdGF0ZVxuZWZmZWN0c10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdCkgYXJlIG1vcmUgYXBwcm9wcmlhdGUuXG4qL1xuY2xhc3MgQW5ub3RhdGlvbiB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgYW5ub3RhdGlvbiB0eXBlLlxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgVGhlIHZhbHVlIG9mIHRoaXMgYW5ub3RhdGlvbi5cbiAgICAqL1xuICAgIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgbmV3IHR5cGUgb2YgYW5ub3RhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoKSB7IHJldHVybiBuZXcgQW5ub3RhdGlvblR5cGUoKTsgfVxufVxuLyoqXG5NYXJrZXIgdGhhdCBpZGVudGlmaWVzIGEgdHlwZSBvZiBbYW5ub3RhdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Bbm5vdGF0aW9uKS5cbiovXG5jbGFzcyBBbm5vdGF0aW9uVHlwZSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgYW5ub3RhdGlvbi5cbiAgICAqL1xuICAgIG9mKHZhbHVlKSB7IHJldHVybiBuZXcgQW5ub3RhdGlvbih0aGlzLCB2YWx1ZSk7IH1cbn1cbi8qKlxuUmVwcmVzZW50YXRpb24gb2YgYSB0eXBlIG9mIHN0YXRlIGVmZmVjdC4gRGVmaW5lZCB3aXRoXG5bYFN0YXRlRWZmZWN0LmRlZmluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3ReZGVmaW5lKS5cbiovXG5jbGFzcyBTdGF0ZUVmZmVjdFR5cGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gVGhlIGBhbnlgIHR5cGVzIGluIHRoZXNlIGZ1bmN0aW9uIHR5cGVzIGFyZSB0aGVyZSB0byB3b3JrXG4gICAgLy8gYXJvdW5kIFR5cGVTY3JpcHQgaXNzdWUgIzM3NjMxLCB3aGVyZSB0aGUgdHlwZSBndWFyZCBvblxuICAgIC8vIGBTdGF0ZUVmZmVjdC5pc2AgbXlzdGVyaW91c2x5IHN0b3BzIHdvcmtpbmcgd2hlbiB0aGVzZSBwcm9wZXJseVxuICAgIC8vIGhhdmUgdHlwZSBgVmFsdWVgLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWFwKSB7XG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbc3RhdGUgZWZmZWN0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0KSBpbnN0YW5jZSBvZiB0aGlzXG4gICAgdHlwZS5cbiAgICAqL1xuICAgIG9mKHZhbHVlKSB7IHJldHVybiBuZXcgU3RhdGVFZmZlY3QodGhpcywgdmFsdWUpOyB9XG59XG4vKipcblN0YXRlIGVmZmVjdHMgY2FuIGJlIHVzZWQgdG8gcmVwcmVzZW50IGFkZGl0aW9uYWwgZWZmZWN0c1xuYXNzb2NpYXRlZCB3aXRoIGEgW3RyYW5zYWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLmVmZmVjdHMpLiBUaGV5XG5hcmUgb2Z0ZW4gdXNlZnVsIHRvIG1vZGVsIGNoYW5nZXMgdG8gY3VzdG9tIFtzdGF0ZVxuZmllbGRzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRmllbGQpLCB3aGVuIHRob3NlIGNoYW5nZXMgYXJlbid0IGltcGxpY2l0IGluXG5kb2N1bWVudCBvciBzZWxlY3Rpb24gY2hhbmdlcy5cbiovXG5jbGFzcyBTdGF0ZUVmZmVjdCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHR5cGUsIFxuICAgIC8qKlxuICAgIFRoZSB2YWx1ZSBvZiB0aGlzIGVmZmVjdC5cbiAgICAqL1xuICAgIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIHRoaXMgZWZmZWN0IHRocm91Z2ggYSBwb3NpdGlvbiBtYXBwaW5nLiBXaWxsIHJldHVyblxuICAgIGB1bmRlZmluZWRgIHdoZW4gdGhhdCBlbmRzIHVwIGRlbGV0aW5nIHRoZSBlZmZlY3QuXG4gICAgKi9cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgbWFwcGVkID0gdGhpcy50eXBlLm1hcCh0aGlzLnZhbHVlLCBtYXBwaW5nKTtcbiAgICAgICAgcmV0dXJuIG1hcHBlZCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogbWFwcGVkID09IHRoaXMudmFsdWUgPyB0aGlzIDogbmV3IFN0YXRlRWZmZWN0KHRoaXMudHlwZSwgbWFwcGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhpcyBlZmZlY3Qgb2JqZWN0IGlzIG9mIGEgZ2l2ZW5cbiAgICBbdHlwZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdFR5cGUpLlxuICAgICovXG4gICAgaXModHlwZSkgeyByZXR1cm4gdGhpcy50eXBlID09IHR5cGU7IH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBuZXcgZWZmZWN0IHR5cGUuIFRoZSB0eXBlIHBhcmFtZXRlciBpbmRpY2F0ZXMgdGhlIHR5cGVcbiAgICBvZiB2YWx1ZXMgdGhhdCBoaXMgZWZmZWN0IGhvbGRzLiBJdCBzaG91bGQgYmUgYSB0eXBlIHRoYXRcbiAgICBkb2Vzbid0IGluY2x1ZGUgYHVuZGVmaW5lZGAsIHNpbmNlIHRoYXQgaXMgdXNlZCBpblxuICAgIFttYXBwaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0Lm1hcCkgdG8gaW5kaWNhdGUgdGhhdCBhbiBlZmZlY3QgaXNcbiAgICByZW1vdmVkLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGF0ZUVmZmVjdFR5cGUoc3BlYy5tYXAgfHwgKHYgPT4gdikpO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgYW4gYXJyYXkgb2YgZWZmZWN0cyB0aHJvdWdoIGEgY2hhbmdlIHNldC5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXBFZmZlY3RzKGVmZmVjdHMsIG1hcHBpbmcpIHtcbiAgICAgICAgaWYgKCFlZmZlY3RzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBlZmZlY3RzO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBsZXQgbWFwcGVkID0gZWZmZWN0Lm1hcChtYXBwaW5nKTtcbiAgICAgICAgICAgIGlmIChtYXBwZWQpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobWFwcGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuVGhpcyBlZmZlY3QgY2FuIGJlIHVzZWQgdG8gcmVjb25maWd1cmUgdGhlIHJvb3QgZXh0ZW5zaW9ucyBvZlxudGhlIGVkaXRvci4gRG9pbmcgdGhpcyB3aWxsIGRpc2NhcmQgYW55IGV4dGVuc2lvbnNcblthcHBlbmRlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdF5hcHBlbmRDb25maWcpLCBidXQgZG9lcyBub3QgcmVzZXRcbnRoZSBjb250ZW50IG9mIFtyZWNvbmZpZ3VyZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ29tcGFydG1lbnQucmVjb25maWd1cmUpXG5jb21wYXJ0bWVudHMuXG4qL1xuU3RhdGVFZmZlY3QucmVjb25maWd1cmUgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG4vKipcbkFwcGVuZCBleHRlbnNpb25zIHRvIHRoZSB0b3AtbGV2ZWwgY29uZmlndXJhdGlvbiBvZiB0aGUgZWRpdG9yLlxuKi9cblN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbi8qKlxuQ2hhbmdlcyB0byB0aGUgZWRpdG9yIHN0YXRlIGFyZSBncm91cGVkIGludG8gdHJhbnNhY3Rpb25zLlxuVHlwaWNhbGx5LCBhIHVzZXIgYWN0aW9uIGNyZWF0ZXMgYSBzaW5nbGUgdHJhbnNhY3Rpb24sIHdoaWNoIG1heVxuY29udGFpbiBhbnkgbnVtYmVyIG9mIGRvY3VtZW50IGNoYW5nZXMsIG1heSBjaGFuZ2UgdGhlIHNlbGVjdGlvbixcbm9yIGhhdmUgb3RoZXIgZWZmZWN0cy4gQ3JlYXRlIGEgdHJhbnNhY3Rpb24gYnkgY2FsbGluZ1xuW2BFZGl0b3JTdGF0ZS51cGRhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnVwZGF0ZSksIG9yIGltbWVkaWF0ZWx5XG5kaXNwYXRjaCBvbmUgYnkgY2FsbGluZ1xuW2BFZGl0b3JWaWV3LmRpc3BhdGNoYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZGlzcGF0Y2gpLlxuKi9cbmNsYXNzIFRyYW5zYWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhdGUgZnJvbSB3aGljaCB0aGUgdHJhbnNhY3Rpb24gc3RhcnRzLlxuICAgICovXG4gICAgc3RhcnRTdGF0ZSwgXG4gICAgLyoqXG4gICAgVGhlIGRvY3VtZW50IGNoYW5nZXMgbWFkZSBieSB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgY2hhbmdlcywgXG4gICAgLyoqXG4gICAgVGhlIHNlbGVjdGlvbiBzZXQgYnkgdGhpcyB0cmFuc2FjdGlvbiwgb3IgdW5kZWZpbmVkIGlmIGl0XG4gICAgZG9lc24ndCBleHBsaWNpdGx5IHNldCBhIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIHNlbGVjdGlvbiwgXG4gICAgLyoqXG4gICAgVGhlIGVmZmVjdHMgYWRkZWQgdG8gdGhlIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgZWZmZWN0cywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhbm5vdGF0aW9ucywgXG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgc2VsZWN0aW9uIHNob3VsZCBiZSBzY3JvbGxlZCBpbnRvIHZpZXcgYWZ0ZXIgdGhpc1xuICAgIHRyYW5zYWN0aW9uIGlzIGRpc3BhdGNoZWQuXG4gICAgKi9cbiAgICBzY3JvbGxJbnRvVmlldykge1xuICAgICAgICB0aGlzLnN0YXJ0U3RhdGUgPSBzdGFydFN0YXRlO1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBjaGFuZ2VzO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5lZmZlY3RzID0gZWZmZWN0cztcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9ucyA9IGFubm90YXRpb25zO1xuICAgICAgICB0aGlzLnNjcm9sbEludG9WaWV3ID0gc2Nyb2xsSW50b1ZpZXc7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZG9jID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IG51bGw7XG4gICAgICAgIGlmIChzZWxlY3Rpb24pXG4gICAgICAgICAgICBjaGVja1NlbGVjdGlvbihzZWxlY3Rpb24sIGNoYW5nZXMubmV3TGVuZ3RoKTtcbiAgICAgICAgaWYgKCFhbm5vdGF0aW9ucy5zb21lKChhKSA9PiBhLnR5cGUgPT0gVHJhbnNhY3Rpb24udGltZSkpXG4gICAgICAgICAgICB0aGlzLmFubm90YXRpb25zID0gYW5ub3RhdGlvbnMuY29uY2F0KFRyYW5zYWN0aW9uLnRpbWUub2YoRGF0ZS5ub3coKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoc3RhcnRTdGF0ZSwgY2hhbmdlcywgc2VsZWN0aW9uLCBlZmZlY3RzLCBhbm5vdGF0aW9ucywgc2Nyb2xsSW50b1ZpZXcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbihzdGFydFN0YXRlLCBjaGFuZ2VzLCBzZWxlY3Rpb24sIGVmZmVjdHMsIGFubm90YXRpb25zLCBzY3JvbGxJbnRvVmlldyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBuZXcgZG9jdW1lbnQgcHJvZHVjZWQgYnkgdGhlIHRyYW5zYWN0aW9uLiBDb250cmFyeSB0b1xuICAgIFtgLnN0YXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5zdGF0ZSlgLmRvY2AsIGFjY2Vzc2luZyB0aGlzIHdvbid0XG4gICAgZm9yY2UgdGhlIGVudGlyZSBuZXcgc3RhdGUgdG8gYmUgY29tcHV0ZWQgcmlnaHQgYXdheSwgc28gaXQgaXNcbiAgICByZWNvbW1lbmRlZCB0aGF0IFt0cmFuc2FjdGlvblxuICAgIGZpbHRlcnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedHJhbnNhY3Rpb25GaWx0ZXIpIHVzZSB0aGlzIGdldHRlclxuICAgIHdoZW4gdGhleSBuZWVkIHRvIGxvb2sgYXQgdGhlIG5ldyBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBuZXdEb2MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kb2MgfHwgKHRoaXMuX2RvYyA9IHRoaXMuY2hhbmdlcy5hcHBseSh0aGlzLnN0YXJ0U3RhdGUuZG9jKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBuZXcgc2VsZWN0aW9uIHByb2R1Y2VkIGJ5IHRoZSB0cmFuc2FjdGlvbi4gSWZcbiAgICBbYHRoaXMuc2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5zZWxlY3Rpb24pIGlzIHVuZGVmaW5lZCxcbiAgICB0aGlzIHdpbGwgW21hcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTZWxlY3Rpb24ubWFwKSB0aGUgc3RhcnQgc3RhdGUnc1xuICAgIGN1cnJlbnQgc2VsZWN0aW9uIHRocm91Z2ggdGhlIGNoYW5nZXMgbWFkZSBieSB0aGUgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBnZXQgbmV3U2VsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24gfHwgdGhpcy5zdGFydFN0YXRlLnNlbGVjdGlvbi5tYXAodGhpcy5jaGFuZ2VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG5ldyBzdGF0ZSBjcmVhdGVkIGJ5IHRoZSB0cmFuc2FjdGlvbi4gQ29tcHV0ZWQgb24gZGVtYW5kXG4gICAgKGJ1dCByZXRhaW5lZCBmb3Igc3Vic2VxdWVudCBhY2Nlc3MpLCBzbyBpdCBpcyByZWNvbW1lbmRlZCBub3QgdG9cbiAgICBhY2Nlc3MgaXQgaW4gW3RyYW5zYWN0aW9uXG4gICAgZmlsdGVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50cmFuc2FjdGlvbkZpbHRlcikgd2hlbiBwb3NzaWJsZS5cbiAgICAqL1xuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zdGF0ZSlcbiAgICAgICAgICAgIHRoaXMuc3RhcnRTdGF0ZS5hcHBseVRyYW5zYWN0aW9uKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIGFubm90YXRpb24gdHlwZSwgaWYgYW55LlxuICAgICovXG4gICAgYW5ub3RhdGlvbih0eXBlKSB7XG4gICAgICAgIGZvciAobGV0IGFubiBvZiB0aGlzLmFubm90YXRpb25zKVxuICAgICAgICAgICAgaWYgKGFubi50eXBlID09IHR5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFubi52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRyYW5zYWN0aW9uIGNoYW5nZWQgdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IGRvY0NoYW5nZWQoKSB7IHJldHVybiAhdGhpcy5jaGFuZ2VzLmVtcHR5OyB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyB0cmFuc2FjdGlvbiByZWNvbmZpZ3VyZXMgdGhlIHN0YXRlXG4gICAgKHRocm91Z2ggYSBbY29uZmlndXJhdGlvbiBjb21wYXJ0bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Db21wYXJ0bWVudCkgb3JcbiAgICB3aXRoIGEgdG9wLWxldmVsIGNvbmZpZ3VyYXRpb25cbiAgICBbZWZmZWN0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0XnJlY29uZmlndXJlKS5cbiAgICAqL1xuICAgIGdldCByZWNvbmZpZ3VyZWQoKSB7IHJldHVybiB0aGlzLnN0YXJ0U3RhdGUuY29uZmlnICE9IHRoaXMuc3RhdGUuY29uZmlnOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBoYXMgYSBbdXNlclxuICAgIGV2ZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uXnVzZXJFdmVudCkgYW5ub3RhdGlvbiB0aGF0IGlzIGVxdWFsIHRvXG4gICAgb3IgbW9yZSBzcGVjaWZpYyB0aGFuIGBldmVudGAuIEZvciBleGFtcGxlLCBpZiB0aGUgdHJhbnNhY3Rpb25cbiAgICBoYXMgYFwic2VsZWN0LnBvaW50ZXJcImAgYXMgdXNlciBldmVudCwgYFwic2VsZWN0XCJgIGFuZFxuICAgIGBcInNlbGVjdC5wb2ludGVyXCJgIHdpbGwgbWF0Y2ggaXQuXG4gICAgKi9cbiAgICBpc1VzZXJFdmVudChldmVudCkge1xuICAgICAgICBsZXQgZSA9IHRoaXMuYW5ub3RhdGlvbihUcmFuc2FjdGlvbi51c2VyRXZlbnQpO1xuICAgICAgICByZXR1cm4gISEoZSAmJiAoZSA9PSBldmVudCB8fCBlLmxlbmd0aCA+IGV2ZW50Lmxlbmd0aCAmJiBlLnNsaWNlKDAsIGV2ZW50Lmxlbmd0aCkgPT0gZXZlbnQgJiYgZVtldmVudC5sZW5ndGhdID09IFwiLlwiKSk7XG4gICAgfVxufVxuLyoqXG5Bbm5vdGF0aW9uIHVzZWQgdG8gc3RvcmUgdHJhbnNhY3Rpb24gdGltZXN0YW1wcy4gQXV0b21hdGljYWxseVxuYWRkZWQgdG8gZXZlcnkgdHJhbnNhY3Rpb24sIGhvbGRpbmcgYERhdGUubm93KClgLlxuKi9cblRyYW5zYWN0aW9uLnRpbWUgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbi8qKlxuQW5ub3RhdGlvbiB1c2VkIHRvIGFzc29jaWF0ZSBhIHRyYW5zYWN0aW9uIHdpdGggYSB1c2VyIGludGVyZmFjZVxuZXZlbnQuIEhvbGRzIGEgc3RyaW5nIGlkZW50aWZ5aW5nIHRoZSBldmVudCwgdXNpbmcgYVxuZG90LXNlcGFyYXRlZCBmb3JtYXQgdG8gc3VwcG9ydCBhdHRhY2hpbmcgbW9yZSBzcGVjaWZpY1xuaW5mb3JtYXRpb24uIFRoZSBldmVudHMgdXNlZCBieSB0aGUgY29yZSBsaWJyYXJpZXMgYXJlOlxuXG4gLSBgXCJpbnB1dFwiYCB3aGVuIGNvbnRlbnQgaXMgZW50ZXJlZFxuICAgLSBgXCJpbnB1dC50eXBlXCJgIGZvciB0eXBlZCBpbnB1dFxuICAgICAtIGBcImlucHV0LnR5cGUuY29tcG9zZVwiYCBmb3IgY29tcG9zaXRpb25cbiAgIC0gYFwiaW5wdXQucGFzdGVcImAgZm9yIHBhc3RlZCBpbnB1dFxuICAgLSBgXCJpbnB1dC5kcm9wXCJgIHdoZW4gYWRkaW5nIGNvbnRlbnQgd2l0aCBkcmFnLWFuZC1kcm9wXG4gICAtIGBcImlucHV0LmNvbXBsZXRlXCJgIHdoZW4gYXV0b2NvbXBsZXRpbmdcbiAtIGBcImRlbGV0ZVwiYCB3aGVuIHRoZSB1c2VyIGRlbGV0ZXMgY29udGVudFxuICAgLSBgXCJkZWxldGUuc2VsZWN0aW9uXCJgIHdoZW4gZGVsZXRpbmcgdGhlIHNlbGVjdGlvblxuICAgLSBgXCJkZWxldGUuZm9yd2FyZFwiYCB3aGVuIGRlbGV0aW5nIGZvcndhcmQgZnJvbSB0aGUgc2VsZWN0aW9uXG4gICAtIGBcImRlbGV0ZS5iYWNrd2FyZFwiYCB3aGVuIGRlbGV0aW5nIGJhY2t3YXJkIGZyb20gdGhlIHNlbGVjdGlvblxuICAgLSBgXCJkZWxldGUuY3V0XCJgIHdoZW4gY3V0dGluZyB0byB0aGUgY2xpcGJvYXJkXG4gLSBgXCJtb3ZlXCJgIHdoZW4gY29udGVudCBpcyBtb3ZlZFxuICAgLSBgXCJtb3ZlLmRyb3BcImAgd2hlbiBjb250ZW50IGlzIG1vdmVkIHdpdGhpbiB0aGUgZWRpdG9yIHRocm91Z2ggZHJhZy1hbmQtZHJvcFxuIC0gYFwic2VsZWN0XCJgIHdoZW4gZXhwbGljaXRseSBjaGFuZ2luZyB0aGUgc2VsZWN0aW9uXG4gICAtIGBcInNlbGVjdC5wb2ludGVyXCJgIHdoZW4gc2VsZWN0aW5nIHdpdGggYSBtb3VzZSBvciBvdGhlciBwb2ludGluZyBkZXZpY2VcbiAtIGBcInVuZG9cImAgYW5kIGBcInJlZG9cImAgZm9yIGhpc3RvcnkgYWN0aW9uc1xuXG5Vc2UgW2Bpc1VzZXJFdmVudGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uaXNVc2VyRXZlbnQpIHRvIGNoZWNrXG53aGV0aGVyIHRoZSBhbm5vdGF0aW9uIG1hdGNoZXMgYSBnaXZlbiBldmVudC5cbiovXG5UcmFuc2FjdGlvbi51c2VyRXZlbnQgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbi8qKlxuQW5ub3RhdGlvbiBpbmRpY2F0aW5nIHdoZXRoZXIgYSB0cmFuc2FjdGlvbiBzaG91bGQgYmUgYWRkZWQgdG9cbnRoZSB1bmRvIGhpc3Rvcnkgb3Igbm90LlxuKi9cblRyYW5zYWN0aW9uLmFkZFRvSGlzdG9yeSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5Bbm5vdGF0aW9uIGluZGljYXRpbmcgKHdoZW4gcHJlc2VudCBhbmQgdHJ1ZSkgdGhhdCBhIHRyYW5zYWN0aW9uXG5yZXByZXNlbnRzIGEgY2hhbmdlIG1hZGUgYnkgc29tZSBvdGhlciBhY3Rvciwgbm90IHRoZSB1c2VyLiBUaGlzXG5pcyB1c2VkLCBmb3IgZXhhbXBsZSwgdG8gdGFnIG90aGVyIHBlb3BsZSdzIGNoYW5nZXMgaW5cbmNvbGxhYm9yYXRpdmUgZWRpdGluZy5cbiovXG5UcmFuc2FjdGlvbi5yZW1vdGUgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbmZ1bmN0aW9uIGpvaW5SYW5nZXMoYSwgYikge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpQSA9IDAsIGlCID0gMDs7KSB7XG4gICAgICAgIGxldCBmcm9tLCB0bztcbiAgICAgICAgaWYgKGlBIDwgYS5sZW5ndGggJiYgKGlCID09IGIubGVuZ3RoIHx8IGJbaUJdID49IGFbaUFdKSkge1xuICAgICAgICAgICAgZnJvbSA9IGFbaUErK107XG4gICAgICAgICAgICB0byA9IGFbaUErK107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaUIgPCBiLmxlbmd0aCkge1xuICAgICAgICAgICAgZnJvbSA9IGJbaUIrK107XG4gICAgICAgICAgICB0byA9IGJbaUIrK107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoIHx8IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPCBmcm9tKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJvbSwgdG8pO1xuICAgICAgICBlbHNlIGlmIChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdIDwgdG8pXG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gdG87XG4gICAgfVxufVxuZnVuY3Rpb24gbWVyZ2VUcmFuc2FjdGlvbihhLCBiLCBzZXF1ZW50aWFsKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBtYXBGb3JBLCBtYXBGb3JCLCBjaGFuZ2VzO1xuICAgIGlmIChzZXF1ZW50aWFsKSB7XG4gICAgICAgIG1hcEZvckEgPSBiLmNoYW5nZXM7XG4gICAgICAgIG1hcEZvckIgPSBDaGFuZ2VTZXQuZW1wdHkoYi5jaGFuZ2VzLmxlbmd0aCk7XG4gICAgICAgIGNoYW5nZXMgPSBhLmNoYW5nZXMuY29tcG9zZShiLmNoYW5nZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWFwRm9yQSA9IGIuY2hhbmdlcy5tYXAoYS5jaGFuZ2VzKTtcbiAgICAgICAgbWFwRm9yQiA9IGEuY2hhbmdlcy5tYXBEZXNjKGIuY2hhbmdlcywgdHJ1ZSk7XG4gICAgICAgIGNoYW5nZXMgPSBhLmNoYW5nZXMuY29tcG9zZShtYXBGb3JBKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgc2VsZWN0aW9uOiBiLnNlbGVjdGlvbiA/IGIuc2VsZWN0aW9uLm1hcChtYXBGb3JCKSA6IChfYSA9IGEuc2VsZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKG1hcEZvckEpLFxuICAgICAgICBlZmZlY3RzOiBTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGEuZWZmZWN0cywgbWFwRm9yQSkuY29uY2F0KFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoYi5lZmZlY3RzLCBtYXBGb3JCKSksXG4gICAgICAgIGFubm90YXRpb25zOiBhLmFubm90YXRpb25zLmxlbmd0aCA/IGEuYW5ub3RhdGlvbnMuY29uY2F0KGIuYW5ub3RhdGlvbnMpIDogYi5hbm5vdGF0aW9ucyxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IGEuc2Nyb2xsSW50b1ZpZXcgfHwgYi5zY3JvbGxJbnRvVmlld1xuICAgIH07XG59XG5mdW5jdGlvbiByZXNvbHZlVHJhbnNhY3Rpb25Jbm5lcihzdGF0ZSwgc3BlYywgZG9jU2l6ZSkge1xuICAgIGxldCBzZWwgPSBzcGVjLnNlbGVjdGlvbiwgYW5ub3RhdGlvbnMgPSBhc0FycmF5KHNwZWMuYW5ub3RhdGlvbnMpO1xuICAgIGlmIChzcGVjLnVzZXJFdmVudClcbiAgICAgICAgYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucy5jb25jYXQoVHJhbnNhY3Rpb24udXNlckV2ZW50Lm9mKHNwZWMudXNlckV2ZW50KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hhbmdlczogc3BlYy5jaGFuZ2VzIGluc3RhbmNlb2YgQ2hhbmdlU2V0ID8gc3BlYy5jaGFuZ2VzXG4gICAgICAgICAgICA6IENoYW5nZVNldC5vZihzcGVjLmNoYW5nZXMgfHwgW10sIGRvY1NpemUsIHN0YXRlLmZhY2V0KGxpbmVTZXBhcmF0b3IpKSxcbiAgICAgICAgc2VsZWN0aW9uOiBzZWwgJiYgKHNlbCBpbnN0YW5jZW9mIEVkaXRvclNlbGVjdGlvbiA/IHNlbCA6IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoc2VsLmFuY2hvciwgc2VsLmhlYWQpKSxcbiAgICAgICAgZWZmZWN0czogYXNBcnJheShzcGVjLmVmZmVjdHMpLFxuICAgICAgICBhbm5vdGF0aW9ucyxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6ICEhc3BlYy5zY3JvbGxJbnRvVmlld1xuICAgIH07XG59XG5mdW5jdGlvbiByZXNvbHZlVHJhbnNhY3Rpb24oc3RhdGUsIHNwZWNzLCBmaWx0ZXIpIHtcbiAgICBsZXQgcyA9IHJlc29sdmVUcmFuc2FjdGlvbklubmVyKHN0YXRlLCBzcGVjcy5sZW5ndGggPyBzcGVjc1swXSA6IHt9LCBzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICBpZiAoc3BlY3MubGVuZ3RoICYmIHNwZWNzWzBdLmZpbHRlciA9PT0gZmFsc2UpXG4gICAgICAgIGZpbHRlciA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3BlY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNwZWNzW2ldLmZpbHRlciA9PT0gZmFsc2UpXG4gICAgICAgICAgICBmaWx0ZXIgPSBmYWxzZTtcbiAgICAgICAgbGV0IHNlcSA9ICEhc3BlY3NbaV0uc2VxdWVudGlhbDtcbiAgICAgICAgcyA9IG1lcmdlVHJhbnNhY3Rpb24ocywgcmVzb2x2ZVRyYW5zYWN0aW9uSW5uZXIoc3RhdGUsIHNwZWNzW2ldLCBzZXEgPyBzLmNoYW5nZXMubmV3TGVuZ3RoIDogc3RhdGUuZG9jLmxlbmd0aCksIHNlcSk7XG4gICAgfVxuICAgIGxldCB0ciA9IFRyYW5zYWN0aW9uLmNyZWF0ZShzdGF0ZSwgcy5jaGFuZ2VzLCBzLnNlbGVjdGlvbiwgcy5lZmZlY3RzLCBzLmFubm90YXRpb25zLCBzLnNjcm9sbEludG9WaWV3KTtcbiAgICByZXR1cm4gZXh0ZW5kVHJhbnNhY3Rpb24oZmlsdGVyID8gZmlsdGVyVHJhbnNhY3Rpb24odHIpIDogdHIpO1xufVxuLy8gRmluaXNoIGEgdHJhbnNhY3Rpb24gYnkgYXBwbHlpbmcgZmlsdGVycyBpZiBuZWNlc3NhcnkuXG5mdW5jdGlvbiBmaWx0ZXJUcmFuc2FjdGlvbih0cikge1xuICAgIGxldCBzdGF0ZSA9IHRyLnN0YXJ0U3RhdGU7XG4gICAgLy8gQ2hhbmdlIGZpbHRlcnNcbiAgICBsZXQgcmVzdWx0ID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBmaWx0ZXIgb2Ygc3RhdGUuZmFjZXQoY2hhbmdlRmlsdGVyKSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBmaWx0ZXIodHIpO1xuICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gdHJ1ZSA/IHZhbHVlIDogam9pblJhbmdlcyhyZXN1bHQsIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCAhPT0gdHJ1ZSkge1xuICAgICAgICBsZXQgY2hhbmdlcywgYmFjaztcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJhY2sgPSB0ci5jaGFuZ2VzLmludmVydGVkRGVzYztcbiAgICAgICAgICAgIGNoYW5nZXMgPSBDaGFuZ2VTZXQuZW1wdHkoc3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZmlsdGVyZWQgPSB0ci5jaGFuZ2VzLmZpbHRlcihyZXN1bHQpO1xuICAgICAgICAgICAgY2hhbmdlcyA9IGZpbHRlcmVkLmNoYW5nZXM7XG4gICAgICAgICAgICBiYWNrID0gZmlsdGVyZWQuZmlsdGVyZWQubWFwRGVzYyhmaWx0ZXJlZC5jaGFuZ2VzKS5pbnZlcnRlZERlc2M7XG4gICAgICAgIH1cbiAgICAgICAgdHIgPSBUcmFuc2FjdGlvbi5jcmVhdGUoc3RhdGUsIGNoYW5nZXMsIHRyLnNlbGVjdGlvbiAmJiB0ci5zZWxlY3Rpb24ubWFwKGJhY2spLCBTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKHRyLmVmZmVjdHMsIGJhY2spLCB0ci5hbm5vdGF0aW9ucywgdHIuc2Nyb2xsSW50b1ZpZXcpO1xuICAgIH1cbiAgICAvLyBUcmFuc2FjdGlvbiBmaWx0ZXJzXG4gICAgbGV0IGZpbHRlcnMgPSBzdGF0ZS5mYWNldCh0cmFuc2FjdGlvbkZpbHRlcik7XG4gICAgZm9yIChsZXQgaSA9IGZpbHRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IGZpbHRlcmVkID0gZmlsdGVyc1tpXSh0cik7XG4gICAgICAgIGlmIChmaWx0ZXJlZCBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgdHIgPSBmaWx0ZXJlZDtcbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXJlZCkgJiYgZmlsdGVyZWQubGVuZ3RoID09IDEgJiYgZmlsdGVyZWRbMF0gaW5zdGFuY2VvZiBUcmFuc2FjdGlvbilcbiAgICAgICAgICAgIHRyID0gZmlsdGVyZWRbMF07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRyID0gcmVzb2x2ZVRyYW5zYWN0aW9uKHN0YXRlLCBhc0FycmF5KGZpbHRlcmVkKSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdHI7XG59XG5mdW5jdGlvbiBleHRlbmRUcmFuc2FjdGlvbih0cikge1xuICAgIGxldCBzdGF0ZSA9IHRyLnN0YXJ0U3RhdGUsIGV4dGVuZGVycyA9IHN0YXRlLmZhY2V0KHRyYW5zYWN0aW9uRXh0ZW5kZXIpLCBzcGVjID0gdHI7XG4gICAgZm9yIChsZXQgaSA9IGV4dGVuZGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgZXh0ZW5zaW9uID0gZXh0ZW5kZXJzW2ldKHRyKTtcbiAgICAgICAgaWYgKGV4dGVuc2lvbiAmJiBPYmplY3Qua2V5cyhleHRlbnNpb24pLmxlbmd0aClcbiAgICAgICAgICAgIHNwZWMgPSBtZXJnZVRyYW5zYWN0aW9uKHNwZWMsIHJlc29sdmVUcmFuc2FjdGlvbklubmVyKHN0YXRlLCBleHRlbnNpb24sIHRyLmNoYW5nZXMubmV3TGVuZ3RoKSwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBzcGVjID09IHRyID8gdHIgOiBUcmFuc2FjdGlvbi5jcmVhdGUoc3RhdGUsIHRyLmNoYW5nZXMsIHRyLnNlbGVjdGlvbiwgc3BlYy5lZmZlY3RzLCBzcGVjLmFubm90YXRpb25zLCBzcGVjLnNjcm9sbEludG9WaWV3KTtcbn1cbmNvbnN0IG5vbmUgPSBbXTtcbmZ1bmN0aW9uIGFzQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IG5vbmUgOiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbn1cblxuLyoqXG5UaGUgY2F0ZWdvcmllcyBwcm9kdWNlZCBieSBhIFtjaGFyYWN0ZXJcbmNhdGVnb3JpemVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYXJDYXRlZ29yaXplcikuIFRoZXNlIGFyZSB1c2VkXG5kbyB0aGluZ3MgbGlrZSBzZWxlY3RpbmcgYnkgd29yZC5cbiovXG52YXIgQ2hhckNhdGVnb3J5ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQ2hhckNhdGVnb3J5KSB7XG4gICAgLyoqXG4gICAgV29yZCBjaGFyYWN0ZXJzLlxuICAgICovXG4gICAgQ2hhckNhdGVnb3J5W0NoYXJDYXRlZ29yeVtcIldvcmRcIl0gPSAwXSA9IFwiV29yZFwiO1xuICAgIC8qKlxuICAgIFdoaXRlc3BhY2UuXG4gICAgKi9cbiAgICBDaGFyQ2F0ZWdvcnlbQ2hhckNhdGVnb3J5W1wiU3BhY2VcIl0gPSAxXSA9IFwiU3BhY2VcIjtcbiAgICAvKipcbiAgICBBbnl0aGluZyBlbHNlLlxuICAgICovXG4gICAgQ2hhckNhdGVnb3J5W0NoYXJDYXRlZ29yeVtcIk90aGVyXCJdID0gMl0gPSBcIk90aGVyXCI7XG5yZXR1cm4gQ2hhckNhdGVnb3J5fSkoQ2hhckNhdGVnb3J5IHx8IChDaGFyQ2F0ZWdvcnkgPSB7fSkpO1xuY29uc3Qgbm9uQVNDSUlTaW5nbGVDYXNlV29yZENoYXIgPSAvW1xcdTAwZGZcXHUwNTg3XFx1MDU5MC1cXHUwNWY0XFx1MDYwMC1cXHUwNmZmXFx1MzA0MC1cXHUzMDlmXFx1MzBhMC1cXHUzMGZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmNjXFx1YWMwMC1cXHVkN2FmXS87XG5sZXQgd29yZENoYXI7XG50cnkge1xuICAgIHdvcmRDaGFyID0gLypAX19QVVJFX18qL25ldyBSZWdFeHAoXCJbXFxcXHB7QWxwaGFiZXRpY31cXFxccHtOdW1iZXJ9X11cIiwgXCJ1XCIpO1xufVxuY2F0Y2ggKF8pIHsgfVxuZnVuY3Rpb24gaGFzV29yZENoYXIoc3RyKSB7XG4gICAgaWYgKHdvcmRDaGFyKVxuICAgICAgICByZXR1cm4gd29yZENoYXIudGVzdChzdHIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjaCA9IHN0cltpXTtcbiAgICAgICAgaWYgKC9cXHcvLnRlc3QoY2gpIHx8IGNoID4gXCJcXHg4MFwiICYmIChjaC50b1VwcGVyQ2FzZSgpICE9IGNoLnRvTG93ZXJDYXNlKCkgfHwgbm9uQVNDSUlTaW5nbGVDYXNlV29yZENoYXIudGVzdChjaCkpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG1ha2VDYXRlZ29yaXplcih3b3JkQ2hhcnMpIHtcbiAgICByZXR1cm4gKGNoYXIpID0+IHtcbiAgICAgICAgaWYgKCEvXFxTLy50ZXN0KGNoYXIpKVxuICAgICAgICAgICAgcmV0dXJuIENoYXJDYXRlZ29yeS5TcGFjZTtcbiAgICAgICAgaWYgKGhhc1dvcmRDaGFyKGNoYXIpKVxuICAgICAgICAgICAgcmV0dXJuIENoYXJDYXRlZ29yeS5Xb3JkO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRDaGFycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChjaGFyLmluZGV4T2Yod29yZENoYXJzW2ldKSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiBDaGFyQ2F0ZWdvcnkuV29yZDtcbiAgICAgICAgcmV0dXJuIENoYXJDYXRlZ29yeS5PdGhlcjtcbiAgICB9O1xufVxuXG4vKipcblRoZSBlZGl0b3Igc3RhdGUgY2xhc3MgaXMgYSBwZXJzaXN0ZW50IChpbW11dGFibGUpIGRhdGEgc3RydWN0dXJlLlxuVG8gdXBkYXRlIGEgc3RhdGUsIHlvdSBbY3JlYXRlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnVwZGF0ZSkgYVxuW3RyYW5zYWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uKSwgd2hpY2ggcHJvZHVjZXMgYSBfbmV3XyBzdGF0ZVxuaW5zdGFuY2UsIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbCBvYmplY3QuXG5cbkFzIHN1Y2gsIF9uZXZlcl8gbXV0YXRlIHByb3BlcnRpZXMgb2YgYSBzdGF0ZSBkaXJlY3RseS4gVGhhdCdsbFxuanVzdCBicmVhayB0aGluZ3MuXG4qL1xuY2xhc3MgRWRpdG9yU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uZmlnLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBkb2N1bWVudC5cbiAgICAqL1xuICAgIGRvYywgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICovXG4gICAgc2VsZWN0aW9uLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHZhbHVlcywgY29tcHV0ZVNsb3QsIHRyKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IGNvbmZpZy5zdGF0dXNUZW1wbGF0ZS5zbGljZSgpO1xuICAgICAgICB0aGlzLmNvbXB1dGVTbG90ID0gY29tcHV0ZVNsb3Q7XG4gICAgICAgIC8vIEZpbGwgaW4gdGhlIGNvbXB1dGVkIHN0YXRlIGltbWVkaWF0ZWx5LCBzbyB0aGF0IGZ1cnRoZXIgcXVlcmllc1xuICAgICAgICAvLyBmb3IgaXQgbWFkZSBkdXJpbmcgdGhlIHVwZGF0ZSByZXR1cm4gdGhpcyBzdGF0ZVxuICAgICAgICBpZiAodHIpXG4gICAgICAgICAgICB0ci5fc3RhdGUgPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29uZmlnLmR5bmFtaWNTbG90cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGVuc3VyZUFkZHIodGhpcywgaSA8PCAxKTtcbiAgICAgICAgdGhpcy5jb21wdXRlU2xvdCA9IG51bGw7XG4gICAgfVxuICAgIGZpZWxkKGZpZWxkLCByZXF1aXJlID0gdHJ1ZSkge1xuICAgICAgICBsZXQgYWRkciA9IHRoaXMuY29uZmlnLmFkZHJlc3NbZmllbGQuaWRdO1xuICAgICAgICBpZiAoYWRkciA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmVxdWlyZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkZpZWxkIGlzIG5vdCBwcmVzZW50IGluIHRoaXMgc3RhdGVcIik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVuc3VyZUFkZHIodGhpcywgYWRkcik7XG4gICAgICAgIHJldHVybiBnZXRBZGRyKHRoaXMsIGFkZHIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbdHJhbnNhY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24pIHRoYXQgdXBkYXRlcyB0aGlzXG4gICAgc3RhdGUuIEFueSBudW1iZXIgb2YgW3RyYW5zYWN0aW9uIHNwZWNzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYylcbiAgICBjYW4gYmUgcGFzc2VkLiBVbmxlc3NcbiAgICBbYHNlcXVlbnRpYWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5zZXF1ZW50aWFsKSBpcyBzZXQsIHRoZVxuICAgIFtjaGFuZ2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5jaGFuZ2VzKSAoaWYgYW55KSBvZiBlYWNoIHNwZWNcbiAgICBhcmUgYXNzdW1lZCB0byBzdGFydCBpbiB0aGUgX2N1cnJlbnRfIGRvY3VtZW50IChub3QgdGhlIGRvY3VtZW50XG4gICAgcHJvZHVjZWQgYnkgcHJldmlvdXMgc3BlY3MpLCBhbmQgaXRzXG4gICAgW3NlbGVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuc2VsZWN0aW9uKSBhbmRcbiAgICBbZWZmZWN0c10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZWZmZWN0cykgYXJlIGFzc3VtZWQgdG8gcmVmZXJcbiAgICB0byB0aGUgZG9jdW1lbnQgY3JlYXRlZCBieSBpdHMgX293bl8gY2hhbmdlcy4gVGhlIHJlc3VsdGluZ1xuICAgIHRyYW5zYWN0aW9uIGNvbnRhaW5zIHRoZSBjb21iaW5lZCBlZmZlY3Qgb2YgYWxsIHRoZSBkaWZmZXJlbnRcbiAgICBzcGVjcy4gRm9yIFtzZWxlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlbGVjdGlvbiksIGxhdGVyXG4gICAgc3BlY3MgdGFrZSBwcmVjZWRlbmNlIG92ZXIgZWFybGllciBvbmVzLlxuICAgICovXG4gICAgdXBkYXRlKC4uLnNwZWNzKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlVHJhbnNhY3Rpb24odGhpcywgc3BlY3MsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFwcGx5VHJhbnNhY3Rpb24odHIpIHtcbiAgICAgICAgbGV0IGNvbmYgPSB0aGlzLmNvbmZpZywgeyBiYXNlLCBjb21wYXJ0bWVudHMgfSA9IGNvbmY7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKENvbXBhcnRtZW50LnJlY29uZmlndXJlKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb25mKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhcnRtZW50cyA9IG5ldyBNYXA7XG4gICAgICAgICAgICAgICAgICAgIGNvbmYuY29tcGFydG1lbnRzLmZvckVhY2goKHZhbCwga2V5KSA9PiBjb21wYXJ0bWVudHMuc2V0KGtleSwgdmFsKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbmYgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21wYXJ0bWVudHMuc2V0KGVmZmVjdC52YWx1ZS5jb21wYXJ0bWVudCwgZWZmZWN0LnZhbHVlLmV4dGVuc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXMoU3RhdGVFZmZlY3QucmVjb25maWd1cmUpKSB7XG4gICAgICAgICAgICAgICAgY29uZiA9IG51bGw7XG4gICAgICAgICAgICAgICAgYmFzZSA9IGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyhTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29uZiA9IG51bGw7XG4gICAgICAgICAgICAgICAgYmFzZSA9IGFzQXJyYXkoYmFzZSkuY29uY2F0KGVmZmVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0VmFsdWVzO1xuICAgICAgICBpZiAoIWNvbmYpIHtcbiAgICAgICAgICAgIGNvbmYgPSBDb25maWd1cmF0aW9uLnJlc29sdmUoYmFzZSwgY29tcGFydG1lbnRzLCB0aGlzKTtcbiAgICAgICAgICAgIGxldCBpbnRlcm1lZGlhdGVTdGF0ZSA9IG5ldyBFZGl0b3JTdGF0ZShjb25mLCB0aGlzLmRvYywgdGhpcy5zZWxlY3Rpb24sIGNvbmYuZHluYW1pY1Nsb3RzLm1hcCgoKSA9PiBudWxsKSwgKHN0YXRlLCBzbG90KSA9PiBzbG90LnJlY29uZmlndXJlKHN0YXRlLCB0aGlzKSwgbnVsbCk7XG4gICAgICAgICAgICBzdGFydFZhbHVlcyA9IGludGVybWVkaWF0ZVN0YXRlLnZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0VmFsdWVzID0gdHIuc3RhcnRTdGF0ZS52YWx1ZXMuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VsZWN0aW9uID0gdHIuc3RhcnRTdGF0ZS5mYWNldChhbGxvd011bHRpcGxlU2VsZWN0aW9ucykgPyB0ci5uZXdTZWxlY3Rpb24gOiB0ci5uZXdTZWxlY3Rpb24uYXNTaW5nbGUoKTtcbiAgICAgICAgbmV3IEVkaXRvclN0YXRlKGNvbmYsIHRyLm5ld0RvYywgc2VsZWN0aW9uLCBzdGFydFZhbHVlcywgKHN0YXRlLCBzbG90KSA9PiBzbG90LnVwZGF0ZShzdGF0ZSwgdHIpLCB0cik7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFt0cmFuc2FjdGlvbiBzcGVjXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYykgdGhhdFxuICAgIHJlcGxhY2VzIGV2ZXJ5IHNlbGVjdGlvbiByYW5nZSB3aXRoIHRoZSBnaXZlbiBjb250ZW50LlxuICAgICovXG4gICAgcmVwbGFjZVNlbGVjdGlvbih0ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGV4dCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGV4dCA9IHRoaXMudG9UZXh0KHRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+ICh7IGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuZnJvbSwgdG86IHJhbmdlLnRvLCBpbnNlcnQ6IHRleHQgfSxcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gKyB0ZXh0Lmxlbmd0aCkgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZXQgb2YgY2hhbmdlcyBhbmQgYSBuZXcgc2VsZWN0aW9uIGJ5IHJ1bm5pbmcgdGhlIGdpdmVuXG4gICAgZnVuY3Rpb24gZm9yIGVhY2ggcmFuZ2UgaW4gdGhlIGFjdGl2ZSBzZWxlY3Rpb24uIFRoZSBmdW5jdGlvblxuICAgIGNhbiByZXR1cm4gYW4gb3B0aW9uYWwgc2V0IG9mIGNoYW5nZXMgKGluIHRoZSBjb29yZGluYXRlIHNwYWNlXG4gICAgb2YgdGhlIHN0YXJ0IGRvY3VtZW50KSwgcGx1cyBhbiB1cGRhdGVkIHJhbmdlIChpbiB0aGUgY29vcmRpbmF0ZVxuICAgIHNwYWNlIG9mIHRoZSBkb2N1bWVudCBwcm9kdWNlZCBieSB0aGUgY2FsbCdzIG93biBjaGFuZ2VzKS4gVGhpc1xuICAgIG1ldGhvZCB3aWxsIG1lcmdlIGFsbCB0aGUgY2hhbmdlcyBhbmQgcmFuZ2VzIGludG8gYSBzaW5nbGVcbiAgICBjaGFuZ2VzZXQgYW5kIHNlbGVjdGlvbiwgYW5kIHJldHVybiBpdCBhcyBhIFt0cmFuc2FjdGlvblxuICAgIHNwZWNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjKSwgd2hpY2ggY2FuIGJlIHBhc3NlZCB0b1xuICAgIFtgdXBkYXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS51cGRhdGUpLlxuICAgICovXG4gICAgY2hhbmdlQnlSYW5nZShmKSB7XG4gICAgICAgIGxldCBzZWwgPSB0aGlzLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0IHJlc3VsdDEgPSBmKHNlbC5yYW5nZXNbMF0pO1xuICAgICAgICBsZXQgY2hhbmdlcyA9IHRoaXMuY2hhbmdlcyhyZXN1bHQxLmNoYW5nZXMpLCByYW5nZXMgPSBbcmVzdWx0MS5yYW5nZV07XG4gICAgICAgIGxldCBlZmZlY3RzID0gYXNBcnJheShyZXN1bHQxLmVmZmVjdHMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBmKHNlbC5yYW5nZXNbaV0pO1xuICAgICAgICAgICAgbGV0IG5ld0NoYW5nZXMgPSB0aGlzLmNoYW5nZXMocmVzdWx0LmNoYW5nZXMpLCBuZXdNYXBwZWQgPSBuZXdDaGFuZ2VzLm1hcChjaGFuZ2VzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaTsgaisrKVxuICAgICAgICAgICAgICAgIHJhbmdlc1tqXSA9IHJhbmdlc1tqXS5tYXAobmV3TWFwcGVkKTtcbiAgICAgICAgICAgIGxldCBtYXBCeSA9IGNoYW5nZXMubWFwRGVzYyhuZXdDaGFuZ2VzLCB0cnVlKTtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHJlc3VsdC5yYW5nZS5tYXAobWFwQnkpKTtcbiAgICAgICAgICAgIGNoYW5nZXMgPSBjaGFuZ2VzLmNvbXBvc2UobmV3TWFwcGVkKTtcbiAgICAgICAgICAgIGVmZmVjdHMgPSBTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGVmZmVjdHMsIG5ld01hcHBlZCkuY29uY2F0KFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoYXNBcnJheShyZXN1bHQuZWZmZWN0cyksIG1hcEJ5KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYW5nZXMsXG4gICAgICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCBzZWwubWFpbkluZGV4KSxcbiAgICAgICAgICAgIGVmZmVjdHNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgW2NoYW5nZSBzZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0KSBmcm9tIHRoZSBnaXZlbiBjaGFuZ2VcbiAgICBkZXNjcmlwdGlvbiwgdGFraW5nIHRoZSBzdGF0ZSdzIGRvY3VtZW50IGxlbmd0aCBhbmQgbGluZVxuICAgIHNlcGFyYXRvciBpbnRvIGFjY291bnQuXG4gICAgKi9cbiAgICBjaGFuZ2VzKHNwZWMgPSBbXSkge1xuICAgICAgICBpZiAoc3BlYyBpbnN0YW5jZW9mIENoYW5nZVNldClcbiAgICAgICAgICAgIHJldHVybiBzcGVjO1xuICAgICAgICByZXR1cm4gQ2hhbmdlU2V0Lm9mKHNwZWMsIHRoaXMuZG9jLmxlbmd0aCwgdGhpcy5mYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVzaW5nIHRoZSBzdGF0ZSdzIFtsaW5lXG4gICAgc2VwYXJhdG9yXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmxpbmVTZXBhcmF0b3IpLCBjcmVhdGUgYVxuICAgIFtgVGV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVGV4dCkgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICovXG4gICAgdG9UZXh0KHN0cmluZykge1xuICAgICAgICByZXR1cm4gVGV4dC5vZihzdHJpbmcuc3BsaXQodGhpcy5mYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKSB8fCBEZWZhdWx0U3BsaXQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIHRoZSBnaXZlbiByYW5nZSBvZiB0aGUgZG9jdW1lbnQgYXMgYSBzdHJpbmcuXG4gICAgKi9cbiAgICBzbGljZURvYyhmcm9tID0gMCwgdG8gPSB0aGlzLmRvYy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jLnNsaWNlU3RyaW5nKGZyb20sIHRvLCB0aGlzLmxpbmVCcmVhayk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdmFsdWUgb2YgYSBzdGF0ZSBbZmFjZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRmFjZXQpLlxuICAgICovXG4gICAgZmFjZXQoZmFjZXQpIHtcbiAgICAgICAgbGV0IGFkZHIgPSB0aGlzLmNvbmZpZy5hZGRyZXNzW2ZhY2V0LmlkXTtcbiAgICAgICAgaWYgKGFkZHIgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWNldC5kZWZhdWx0O1xuICAgICAgICBlbnN1cmVBZGRyKHRoaXMsIGFkZHIpO1xuICAgICAgICByZXR1cm4gZ2V0QWRkcih0aGlzLCBhZGRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29udmVydCB0aGlzIHN0YXRlIHRvIGEgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0LiBXaGVuIGN1c3RvbVxuICAgIGZpZWxkcyBzaG91bGQgYmUgc2VyaWFsaXplZCwgeW91IGNhbiBwYXNzIHRoZW0gaW4gYXMgYW4gb2JqZWN0XG4gICAgbWFwcGluZyBwcm9wZXJ0eSBuYW1lcyAoaW4gdGhlIHJlc3VsdGluZyBvYmplY3QsIHdoaWNoIHNob3VsZFxuICAgIG5vdCB1c2UgYGRvY2Agb3IgYHNlbGVjdGlvbmApIHRvIGZpZWxkcy5cbiAgICAqL1xuICAgIHRvSlNPTihmaWVsZHMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGRvYzogdGhpcy5zbGljZURvYygpLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiB0aGlzLnNlbGVjdGlvbi50b0pTT04oKVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZmllbGRzKVxuICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBmaWVsZHNbcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU3RhdGVGaWVsZCAmJiB0aGlzLmNvbmZpZy5hZGRyZXNzW3ZhbHVlLmlkXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcHJvcF0gPSB2YWx1ZS5zcGVjLnRvSlNPTih0aGlzLmZpZWxkKGZpZWxkc1twcm9wXSksIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIHN0YXRlIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uIFdoZW4gY3VzdG9tXG4gICAgZmllbGRzIHNob3VsZCBiZSBkZXNlcmlhbGl6ZWQsIHBhc3MgdGhlIHNhbWUgb2JqZWN0IHlvdSBwYXNzZWRcbiAgICB0byBbYHRvSlNPTmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudG9KU09OKSB3aGVuIHNlcmlhbGl6aW5nIGFzXG4gICAgdGhpcmQgYXJndW1lbnQuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbiwgY29uZmlnID0ge30sIGZpZWxkcykge1xuICAgICAgICBpZiAoIWpzb24gfHwgdHlwZW9mIGpzb24uZG9jICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgRWRpdG9yU3RhdGVcIik7XG4gICAgICAgIGxldCBmaWVsZEluaXQgPSBbXTtcbiAgICAgICAgaWYgKGZpZWxkcylcbiAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChqc29uLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmllbGQgPSBmaWVsZHNbcHJvcF0sIHZhbHVlID0ganNvbltwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRJbml0LnB1c2goZmllbGQuaW5pdChzdGF0ZSA9PiBmaWVsZC5zcGVjLmZyb21KU09OKHZhbHVlLCBzdGF0ZSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBFZGl0b3JTdGF0ZS5jcmVhdGUoe1xuICAgICAgICAgICAgZG9jOiBqc29uLmRvYyxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmZyb21KU09OKGpzb24uc2VsZWN0aW9uKSxcbiAgICAgICAgICAgIGV4dGVuc2lvbnM6IGNvbmZpZy5leHRlbnNpb25zID8gZmllbGRJbml0LmNvbmNhdChbY29uZmlnLmV4dGVuc2lvbnNdKSA6IGZpZWxkSW5pdFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IHN0YXRlLiBZb3UnbGwgdXN1YWxseSBvbmx5IG5lZWQgdGhpcyB3aGVuXG4gICAgaW5pdGlhbGl6aW5nIGFuIGVkaXRvcuKAlHVwZGF0ZWQgc3RhdGVzIGFyZSBjcmVhdGVkIGJ5IGFwcGx5aW5nXG4gICAgdHJhbnNhY3Rpb25zLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShjb25maWcgPSB7fSkge1xuICAgICAgICBsZXQgY29uZmlndXJhdGlvbiA9IENvbmZpZ3VyYXRpb24ucmVzb2x2ZShjb25maWcuZXh0ZW5zaW9ucyB8fCBbXSwgbmV3IE1hcCk7XG4gICAgICAgIGxldCBkb2MgPSBjb25maWcuZG9jIGluc3RhbmNlb2YgVGV4dCA/IGNvbmZpZy5kb2NcbiAgICAgICAgICAgIDogVGV4dC5vZigoY29uZmlnLmRvYyB8fCBcIlwiKS5zcGxpdChjb25maWd1cmF0aW9uLnN0YXRpY0ZhY2V0KEVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IpIHx8IERlZmF1bHRTcGxpdCkpO1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gIWNvbmZpZy5zZWxlY3Rpb24gPyBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKDApXG4gICAgICAgICAgICA6IGNvbmZpZy5zZWxlY3Rpb24gaW5zdGFuY2VvZiBFZGl0b3JTZWxlY3Rpb24gPyBjb25maWcuc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgOiBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKGNvbmZpZy5zZWxlY3Rpb24uYW5jaG9yLCBjb25maWcuc2VsZWN0aW9uLmhlYWQpO1xuICAgICAgICBjaGVja1NlbGVjdGlvbihzZWxlY3Rpb24sIGRvYy5sZW5ndGgpO1xuICAgICAgICBpZiAoIWNvbmZpZ3VyYXRpb24uc3RhdGljRmFjZXQoYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMpKVxuICAgICAgICAgICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uLmFzU2luZ2xlKCk7XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU3RhdGUoY29uZmlndXJhdGlvbiwgZG9jLCBzZWxlY3Rpb24sIGNvbmZpZ3VyYXRpb24uZHluYW1pY1Nsb3RzLm1hcCgoKSA9PiBudWxsKSwgKHN0YXRlLCBzbG90KSA9PiBzbG90LmNyZWF0ZShzdGF0ZSksIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc2l6ZSAoaW4gY29sdW1ucykgb2YgYSB0YWIgaW4gdGhlIGRvY3VtZW50LCBkZXRlcm1pbmVkIGJ5XG4gICAgdGhlIFtgdGFiU2l6ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedGFiU2l6ZSkgZmFjZXQuXG4gICAgKi9cbiAgICBnZXQgdGFiU2l6ZSgpIHsgcmV0dXJuIHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUudGFiU2l6ZSk7IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHByb3BlciBbbGluZS1icmVha10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5saW5lU2VwYXJhdG9yKVxuICAgIHN0cmluZyBmb3IgdGhpcyBzdGF0ZS5cbiAgICAqL1xuICAgIGdldCBsaW5lQnJlYWsoKSB7IHJldHVybiB0aGlzLmZhY2V0KEVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IpIHx8IFwiXFxuXCI7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgd2hlbiB0aGUgZWRpdG9yIGlzXG4gICAgW2NvbmZpZ3VyZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVecmVhZE9ubHkpIHRvIGJlIHJlYWQtb25seS5cbiAgICAqL1xuICAgIGdldCByZWFkT25seSgpIHsgcmV0dXJuIHRoaXMuZmFjZXQocmVhZE9ubHkpOyB9XG4gICAgLyoqXG4gICAgTG9vayB1cCBhIHRyYW5zbGF0aW9uIGZvciB0aGUgZ2l2ZW4gcGhyYXNlICh2aWEgdGhlXG4gICAgW2BwaHJhc2VzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5waHJhc2VzKSBmYWNldCksIG9yIHJldHVybiB0aGVcbiAgICBvcmlnaW5hbCBzdHJpbmcgaWYgbm8gdHJhbnNsYXRpb24gaXMgZm91bmQuXG4gICAgXG4gICAgSWYgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHBhc3NlZCwgdGhleSB3aWxsIGJlIGluc2VydGVkIGluXG4gICAgcGxhY2Ugb2YgbWFya2VycyBsaWtlIGAkMWAgKGZvciB0aGUgZmlyc3QgdmFsdWUpIGFuZCBgJDJgLCBldGMuXG4gICAgQSBzaW5nbGUgYCRgIGlzIGVxdWl2YWxlbnQgdG8gYCQxYCwgYW5kIGAkJGAgd2lsbCBwcm9kdWNlIGFcbiAgICBsaXRlcmFsIGRvbGxhciBzaWduLlxuICAgICovXG4gICAgcGhyYXNlKHBocmFzZSwgLi4uaW5zZXJ0KSB7XG4gICAgICAgIGZvciAobGV0IG1hcCBvZiB0aGlzLmZhY2V0KEVkaXRvclN0YXRlLnBocmFzZXMpKVxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIHBocmFzZSkpIHtcbiAgICAgICAgICAgICAgICBwaHJhc2UgPSBtYXBbcGhyYXNlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKGluc2VydC5sZW5ndGgpXG4gICAgICAgICAgICBwaHJhc2UgPSBwaHJhc2UucmVwbGFjZSgvXFwkKFxcJHxcXGQqKS9nLCAobSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpID09IFwiJFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIkXCI7XG4gICAgICAgICAgICAgICAgbGV0IG4gPSArKGkgfHwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFuIHx8IG4gPiBpbnNlcnQubGVuZ3RoID8gbSA6IGluc2VydFtuIC0gMV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBocmFzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgdmFsdWVzIGZvciBhIGdpdmVuIGxhbmd1YWdlIGRhdGEgZmllbGQsIHByb3ZpZGVkIGJ5IHRoZVxuICAgIHRoZSBbYGxhbmd1YWdlRGF0YWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVebGFuZ3VhZ2VEYXRhKSBmYWNldC5cbiAgICBcbiAgICBFeGFtcGxlcyBvZiBsYW5ndWFnZSBkYXRhIGZpZWxkcyBhcmUuLi5cbiAgICBcbiAgICAtIFtgXCJjb21tZW50VG9rZW5zXCJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLkNvbW1lbnRUb2tlbnMpIGZvciBzcGVjaWZ5aW5nXG4gICAgICBjb21tZW50IHN5bnRheC5cbiAgICAtIFtgXCJhdXRvY29tcGxldGVcImBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmF1dG9jb21wbGV0aW9uXmNvbmZpZy5vdmVycmlkZSlcbiAgICAgIGZvciBwcm92aWRpbmcgbGFuZ3VhZ2Utc3BlY2lmaWMgY29tcGxldGlvbiBzb3VyY2VzLlxuICAgIC0gW2BcIndvcmRDaGFyc1wiYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIpIGZvciBhZGRpbmdcbiAgICAgIGNoYXJhY3RlcnMgdGhhdCBzaG91bGQgYmUgY29uc2lkZXJlZCBwYXJ0IG9mIHdvcmRzIGluIHRoaXNcbiAgICAgIGxhbmd1YWdlLlxuICAgIC0gW2BcImNsb3NlQnJhY2tldHNcImBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLkNsb3NlQnJhY2tldENvbmZpZykgY29udHJvbHNcbiAgICAgIGJyYWNrZXQgY2xvc2luZyBiZWhhdmlvci5cbiAgICAqL1xuICAgIGxhbmd1YWdlRGF0YUF0KG5hbWUsIHBvcywgc2lkZSA9IC0xKSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcHJvdmlkZXIgb2YgdGhpcy5mYWNldChsYW5ndWFnZURhdGEpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCByZXN1bHQgb2YgcHJvdmlkZXIodGhpcywgcG9zLCBzaWRlKSkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBuYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gocmVzdWx0W25hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGNhbiBjYXRlZ29yaXplIHN0cmluZ3MgKGV4cGVjdGVkIHRvXG4gICAgcmVwcmVzZW50IGEgc2luZ2xlIFtncmFwaGVtZSBjbHVzdGVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLmZpbmRDbHVzdGVyQnJlYWspKVxuICAgIGludG8gb25lIG9mOlxuICAgIFxuICAgICAtIFdvcmQgKGNvbnRhaW5zIGFuIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXIgb3IgYSBjaGFyYWN0ZXJcbiAgICAgICBleHBsaWNpdGx5IGxpc3RlZCBpbiB0aGUgbG9jYWwgbGFuZ3VhZ2UncyBgXCJ3b3JkQ2hhcnNcImBcbiAgICAgICBsYW5ndWFnZSBkYXRhLCB3aGljaCBzaG91bGQgYmUgYSBzdHJpbmcpXG4gICAgIC0gU3BhY2UgKGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZSlcbiAgICAgLSBPdGhlciAoYW55dGhpbmcgZWxzZSlcbiAgICAqL1xuICAgIGNoYXJDYXRlZ29yaXplcihhdCkge1xuICAgICAgICByZXR1cm4gbWFrZUNhdGVnb3JpemVyKHRoaXMubGFuZ3VhZ2VEYXRhQXQoXCJ3b3JkQ2hhcnNcIiwgYXQpLmpvaW4oXCJcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSB3b3JkIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiwgbWVhbmluZyB0aGUgcmFuZ2VcbiAgICBjb250YWluaW5nIGFsbCBbd29yZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFyQ2F0ZWdvcnkuV29yZCkgY2hhcmFjdGVyc1xuICAgIGFyb3VuZCBpdC4gSWYgbm8gd29yZCBjaGFyYWN0ZXJzIGFyZSBhZGphY2VudCB0byB0aGUgcG9zaXRpb24sXG4gICAgdGhpcyByZXR1cm5zIG51bGwuXG4gICAgKi9cbiAgICB3b3JkQXQocG9zKSB7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb20sIGxlbmd0aCB9ID0gdGhpcy5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgIGxldCBjYXQgPSB0aGlzLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgICAgICBsZXQgc3RhcnQgPSBwb3MgLSBmcm9tLCBlbmQgPSBwb3MgLSBmcm9tO1xuICAgICAgICB3aGlsZSAoc3RhcnQgPiAwKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IGZpbmRDbHVzdGVyQnJlYWsodGV4dCwgc3RhcnQsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChjYXQodGV4dC5zbGljZShwcmV2LCBzdGFydCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3RhcnQgPSBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChlbmQgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZmluZENsdXN0ZXJCcmVhayh0ZXh0LCBlbmQpO1xuICAgICAgICAgICAgaWYgKGNhdCh0ZXh0LnNsaWNlKGVuZCwgbmV4dCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZW5kID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhcnQgPT0gZW5kID8gbnVsbCA6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShzdGFydCArIGZyb20sIGVuZCArIGZyb20pO1xuICAgIH1cbn1cbi8qKlxuQSBmYWNldCB0aGF0LCB3aGVuIGVuYWJsZWQsIGNhdXNlcyB0aGUgZWRpdG9yIHRvIGFsbG93IG11bHRpcGxlXG5yYW5nZXMgdG8gYmUgc2VsZWN0ZWQuIEJlIGNhcmVmdWwgdGhvdWdoLCBiZWNhdXNlIGJ5IGRlZmF1bHQgdGhlXG5lZGl0b3IgcmVsaWVzIG9uIHRoZSBuYXRpdmUgRE9NIHNlbGVjdGlvbiwgd2hpY2ggY2Fubm90IGhhbmRsZVxubXVsdGlwbGUgc2VsZWN0aW9ucy4gQW4gZXh0ZW5zaW9uIGxpa2VcbltgZHJhd1NlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5kcmF3U2VsZWN0aW9uKSBjYW4gYmUgdXNlZCB0byBtYWtlXG5zZWNvbmRhcnkgc2VsZWN0aW9ucyB2aXNpYmxlIHRvIHRoZSB1c2VyLlxuKi9cbkVkaXRvclN0YXRlLmFsbG93TXVsdGlwbGVTZWxlY3Rpb25zID0gYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnM7XG4vKipcbkNvbmZpZ3VyZXMgdGhlIHRhYiBzaXplIHRvIHVzZSBpbiB0aGlzIHN0YXRlLiBUaGUgZmlyc3RcbihoaWdoZXN0LXByZWNlZGVuY2UpIHZhbHVlIG9mIHRoZSBmYWNldCBpcyB1c2VkLiBJZiBubyB2YWx1ZSBpc1xuZ2l2ZW4sIHRoaXMgZGVmYXVsdHMgdG8gNC5cbiovXG5FZGl0b3JTdGF0ZS50YWJTaXplID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiA0XG59KTtcbi8qKlxuVGhlIGxpbmUgc2VwYXJhdG9yIHRvIHVzZS4gQnkgZGVmYXVsdCwgYW55IG9mIGBcIlxcblwiYCwgYFwiXFxyXFxuXCJgXG5hbmQgYFwiXFxyXCJgIGlzIHRyZWF0ZWQgYXMgYSBzZXBhcmF0b3Igd2hlbiBzcGxpdHRpbmcgbGluZXMsIGFuZFxubGluZXMgYXJlIGpvaW5lZCB3aXRoIGBcIlxcblwiYC5cblxuV2hlbiB5b3UgY29uZmlndXJlIGEgdmFsdWUgaGVyZSwgb25seSB0aGF0IHByZWNpc2Ugc2VwYXJhdG9yXG53aWxsIGJlIHVzZWQsIGFsbG93aW5nIHlvdSB0byByb3VuZC10cmlwIGRvY3VtZW50cyB0aHJvdWdoIHRoZVxuZWRpdG9yIHdpdGhvdXQgbm9ybWFsaXppbmcgbGluZSBzZXBhcmF0b3JzLlxuKi9cbkVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IgPSBsaW5lU2VwYXJhdG9yO1xuLyoqXG5UaGlzIGZhY2V0IGNvbnRyb2xzIHRoZSB2YWx1ZSBvZiB0aGVcbltgcmVhZE9ubHlgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnJlYWRPbmx5KSBnZXR0ZXIsIHdoaWNoIGlzXG5jb25zdWx0ZWQgYnkgY29tbWFuZHMgYW5kIGV4dGVuc2lvbnMgdGhhdCBpbXBsZW1lbnQgZWRpdGluZ1xuZnVuY3Rpb25hbGl0eSB0byBkZXRlcm1pbmUgd2hldGhlciB0aGV5IHNob3VsZCBhcHBseS4gSXRcbmRlZmF1bHRzIHRvIGZhbHNlLCBidXQgd2hlbiBpdHMgaGlnaGVzdC1wcmVjZWRlbmNlIHZhbHVlIGlzXG5gdHJ1ZWAsIHN1Y2ggZnVuY3Rpb25hbGl0eSBkaXNhYmxlcyBpdHNlbGYuXG5cbk5vdCB0byBiZSBjb25mdXNlZCB3aXRoXG5bYEVkaXRvclZpZXcuZWRpdGFibGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15lZGl0YWJsZSksIHdoaWNoXG5jb250cm9scyB3aGV0aGVyIHRoZSBlZGl0b3IncyBET00gaXMgc2V0IHRvIGJlIGVkaXRhYmxlIChhbmRcbnRodXMgZm9jdXNhYmxlKS5cbiovXG5FZGl0b3JTdGF0ZS5yZWFkT25seSA9IHJlYWRPbmx5O1xuLyoqXG5SZWdpc3RlcnMgdHJhbnNsYXRpb24gcGhyYXNlcy4gVGhlXG5bYHBocmFzZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUucGhyYXNlKSBtZXRob2Qgd2lsbCBsb29rIHRocm91Z2hcbmFsbCBvYmplY3RzIHJlZ2lzdGVyZWQgd2l0aCB0aGlzIGZhY2V0IHRvIGZpbmQgdHJhbnNsYXRpb25zIGZvclxuaXRzIGFyZ3VtZW50LlxuKi9cbkVkaXRvclN0YXRlLnBocmFzZXMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21wYXJlKGEsIGIpIHtcbiAgICAgICAgbGV0IGtBID0gT2JqZWN0LmtleXMoYSksIGtCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIHJldHVybiBrQS5sZW5ndGggPT0ga0IubGVuZ3RoICYmIGtBLmV2ZXJ5KGsgPT4gYVtrXSA9PSBiW2tdKTtcbiAgICB9XG59KTtcbi8qKlxuQSBmYWNldCB1c2VkIHRvIHJlZ2lzdGVyIFtsYW5ndWFnZVxuZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkgcHJvdmlkZXJzLlxuKi9cbkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YSA9IGxhbmd1YWdlRGF0YTtcbi8qKlxuRmFjZXQgdXNlZCB0byByZWdpc3RlciBjaGFuZ2UgZmlsdGVycywgd2hpY2ggYXJlIGNhbGxlZCBmb3IgZWFjaFxudHJhbnNhY3Rpb24gKHVubGVzcyBleHBsaWNpdGx5XG5bZGlzYWJsZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmZpbHRlcikpLCBhbmQgY2FuIHN1cHByZXNzXG5wYXJ0IG9mIHRoZSB0cmFuc2FjdGlvbidzIGNoYW5nZXMuXG5cblN1Y2ggYSBmdW5jdGlvbiBjYW4gcmV0dXJuIGB0cnVlYCB0byBpbmRpY2F0ZSB0aGF0IGl0IGRvZXNuJ3RcbndhbnQgdG8gZG8gYW55dGhpbmcsIGBmYWxzZWAgdG8gY29tcGxldGVseSBzdG9wIHRoZSBjaGFuZ2VzIGluXG50aGUgdHJhbnNhY3Rpb24sIG9yIGEgc2V0IG9mIHJhbmdlcyBpbiB3aGljaCBjaGFuZ2VzIHNob3VsZCBiZVxuc3VwcHJlc3NlZC4gU3VjaCByYW5nZXMgYXJlIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIG51bWJlcnMsXG53aXRoIGVhY2ggcGFpciBvZiB0d28gbnVtYmVycyBpbmRpY2F0aW5nIHRoZSBzdGFydCBhbmQgZW5kIG9mIGFcbnJhbmdlLiBTbyBmb3IgZXhhbXBsZSBgWzEwLCAyMCwgMTAwLCAxMTBdYCBzdXBwcmVzc2VzIGNoYW5nZXNcbmJldHdlZW4gMTAgYW5kIDIwLCBhbmQgYmV0d2VlbiAxMDAgYW5kIDExMC5cbiovXG5FZGl0b3JTdGF0ZS5jaGFuZ2VGaWx0ZXIgPSBjaGFuZ2VGaWx0ZXI7XG4vKipcbkZhY2V0IHVzZWQgdG8gcmVnaXN0ZXIgYSBob29rIHRoYXQgZ2V0cyBhIGNoYW5jZSB0byB1cGRhdGUgb3JcbnJlcGxhY2UgdHJhbnNhY3Rpb24gc3BlY3MgYmVmb3JlIHRoZXkgYXJlIGFwcGxpZWQuIFRoaXMgd2lsbFxub25seSBiZSBhcHBsaWVkIGZvciB0cmFuc2FjdGlvbnMgdGhhdCBkb24ndCBoYXZlXG5bYGZpbHRlcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmZpbHRlcikgc2V0IHRvIGBmYWxzZWAuIFlvdVxuY2FuIGVpdGhlciByZXR1cm4gYSBzaW5nbGUgdHJhbnNhY3Rpb24gc3BlYyAocG9zc2libHkgdGhlIGlucHV0XG50cmFuc2FjdGlvbiksIG9yIGFuIGFycmF5IG9mIHNwZWNzICh3aGljaCB3aWxsIGJlIGNvbWJpbmVkIGluXG50aGUgc2FtZSB3YXkgYXMgdGhlIGFyZ3VtZW50cyB0b1xuW2BFZGl0b3JTdGF0ZS51cGRhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnVwZGF0ZSkpLlxuXG5XaGVuIHBvc3NpYmxlLCBpdCBpcyByZWNvbW1lbmRlZCB0byBhdm9pZCBhY2Nlc3NpbmdcbltgVHJhbnNhY3Rpb24uc3RhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnN0YXRlKSBpbiBhIGZpbHRlcixcbnNpbmNlIGl0IHdpbGwgZm9yY2UgY3JlYXRpb24gb2YgYSBzdGF0ZSB0aGF0IHdpbGwgdGhlbiBiZVxuZGlzY2FyZGVkIGFnYWluLCBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYWN0dWFsbHkgZmlsdGVyZWQuXG5cbihUaGlzIGZ1bmN0aW9uYWxpdHkgc2hvdWxkIGJlIHVzZWQgd2l0aCBjYXJlLiBJbmRpc2NyaW1pbmF0ZWx5XG5tb2RpZnlpbmcgdHJhbnNhY3Rpb24gaXMgbGlrZWx5IHRvIGJyZWFrIHNvbWV0aGluZyBvciBkZWdyYWRlXG50aGUgdXNlciBleHBlcmllbmNlLilcbiovXG5FZGl0b3JTdGF0ZS50cmFuc2FjdGlvbkZpbHRlciA9IHRyYW5zYWN0aW9uRmlsdGVyO1xuLyoqXG5UaGlzIGlzIGEgbW9yZSBsaW1pdGVkIGZvcm0gb2ZcbltgdHJhbnNhY3Rpb25GaWx0ZXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRyYW5zYWN0aW9uRmlsdGVyKSxcbndoaWNoIGNhbiBvbmx5IGFkZFxuW2Fubm90YXRpb25zXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5hbm5vdGF0aW9ucykgYW5kXG5bZWZmZWN0c10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZWZmZWN0cykuIF9CdXRfLCB0aGlzIHR5cGVcbm9mIGZpbHRlciBydW5zIGV2ZW4gaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyBkaXNhYmxlZCByZWd1bGFyXG5bZmlsdGVyaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5maWx0ZXIpLCBtYWtpbmcgaXQgc3VpdGFibGVcbmZvciBlZmZlY3RzIHRoYXQgZG9uJ3QgbmVlZCB0byB0b3VjaCB0aGUgY2hhbmdlcyBvciBzZWxlY3Rpb24sXG5idXQgZG8gd2FudCB0byBwcm9jZXNzIGV2ZXJ5IHRyYW5zYWN0aW9uLlxuXG5FeHRlbmRlcnMgcnVuIF9hZnRlcl8gZmlsdGVycywgd2hlbiBib3RoIGFyZSBwcmVzZW50LlxuKi9cbkVkaXRvclN0YXRlLnRyYW5zYWN0aW9uRXh0ZW5kZXIgPSB0cmFuc2FjdGlvbkV4dGVuZGVyO1xuQ29tcGFydG1lbnQucmVjb25maWd1cmUgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5cbi8qKlxuVXRpbGl0eSBmdW5jdGlvbiBmb3IgY29tYmluaW5nIGJlaGF2aW9ycyB0byBmaWxsIGluIGEgY29uZmlnXG5vYmplY3QgZnJvbSBhbiBhcnJheSBvZiBwcm92aWRlZCBjb25maWdzLiBgZGVmYXVsdHNgIHNob3VsZCBob2xkXG5kZWZhdWx0IHZhbHVlcyBmb3IgYWxsIG9wdGlvbmFsIGZpZWxkcyBpbiBgQ29uZmlnYC5cblxuVGhlIGZ1bmN0aW9uIHdpbGwsIGJ5IGRlZmF1bHQsIGVycm9yXG53aGVuIGEgZmllbGQgZ2V0cyB0d28gdmFsdWVzIHRoYXQgYXJlbid0IGA9PT1gLWVxdWFsLCBidXQgeW91IGNhblxucHJvdmlkZSBjb21iaW5lIGZ1bmN0aW9ucyBwZXIgZmllbGQgdG8gZG8gc29tZXRoaW5nIGVsc2UuXG4qL1xuZnVuY3Rpb24gY29tYmluZUNvbmZpZyhjb25maWdzLCBkZWZhdWx0cywgLy8gU2hvdWxkIGhvbGQgb25seSB0aGUgb3B0aW9uYWwgcHJvcGVydGllcyBvZiBDb25maWcsIGJ1dCBJIGhhdmVuJ3QgbWFuYWdlZCB0byBleHByZXNzIHRoYXRcbmNvbWJpbmUgPSB7fSkge1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBjb25maWcgb2YgY29uZmlncylcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKGNvbmZpZykpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGNvbmZpZ1trZXldLCBjdXJyZW50ID0gcmVzdWx0W2tleV07XG4gICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA7IC8vIE5vIGNvbmZsaWN0XG4gICAgICAgICAgICBlbHNlIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChjb21iaW5lLCBrZXkpKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gY29tYmluZVtrZXldKGN1cnJlbnQsIHZhbHVlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb25maWcgbWVyZ2UgY29uZmxpY3QgZm9yIGZpZWxkIFwiICsga2V5KTtcbiAgICAgICAgfVxuICAgIGZvciAobGV0IGtleSBpbiBkZWZhdWx0cylcbiAgICAgICAgaWYgKHJlc3VsdFtrZXldID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGRlZmF1bHRzW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG5FYWNoIHJhbmdlIGlzIGFzc29jaWF0ZWQgd2l0aCBhIHZhbHVlLCB3aGljaCBtdXN0IGluaGVyaXQgZnJvbVxudGhpcyBjbGFzcy5cbiovXG5jbGFzcyBSYW5nZVZhbHVlIHtcbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgdmFsdWUgd2l0aCBhbm90aGVyIHZhbHVlLiBVc2VkIHdoZW4gY29tcGFyaW5nXG4gICAgcmFuZ2VzZXRzLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBjb21wYXJlcyBieSBpZGVudGl0eS5cbiAgICBVbmxlc3MgeW91IGFyZSBvbmx5IGNyZWF0aW5nIGEgZml4ZWQgbnVtYmVyIG9mIHVuaXF1ZSBpbnN0YW5jZXNcbiAgICBvZiB5b3VyIHZhbHVlIHR5cGUsIGl0IGlzIGEgZ29vZCBpZGVhIHRvIGltcGxlbWVudCB0aGlzXG4gICAgcHJvcGVybHkuXG4gICAgKi9cbiAgICBlcShvdGhlcikgeyByZXR1cm4gdGhpcyA9PSBvdGhlcjsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFtyYW5nZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZSkgd2l0aCB0aGlzIHZhbHVlLlxuICAgICovXG4gICAgcmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7IHJldHVybiBSYW5nZS5jcmVhdGUoZnJvbSwgdG8sIHRoaXMpOyB9XG59XG5SYW5nZVZhbHVlLnByb3RvdHlwZS5zdGFydFNpZGUgPSBSYW5nZVZhbHVlLnByb3RvdHlwZS5lbmRTaWRlID0gMDtcblJhbmdlVmFsdWUucHJvdG90eXBlLnBvaW50ID0gZmFsc2U7XG5SYW5nZVZhbHVlLnByb3RvdHlwZS5tYXBNb2RlID0gTWFwTW9kZS5UcmFja0RlbDtcbi8qKlxuQSByYW5nZSBhc3NvY2lhdGVzIGEgdmFsdWUgd2l0aCBhIHJhbmdlIG9mIHBvc2l0aW9ucy5cbiovXG5jbGFzcyBSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHJhbmdlJ3Mgc3RhcnQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBJdHMgZW5kIHBvc2l0aW9uLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhpcyByYW5nZS5cbiAgICAqL1xuICAgIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZnJvbSwgdG8sIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UoZnJvbSwgdG8sIHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbXBSYW5nZShhLCBiKSB7XG4gICAgcmV0dXJuIGEuZnJvbSAtIGIuZnJvbSB8fCBhLnZhbHVlLnN0YXJ0U2lkZSAtIGIudmFsdWUuc3RhcnRTaWRlO1xufVxuY2xhc3MgQ2h1bmsge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvLCB2YWx1ZSwgXG4gICAgLy8gQ2h1bmtzIGFyZSBtYXJrZWQgd2l0aCB0aGUgbGFyZ2VzdCBwb2ludCB0aGF0IG9jY3Vyc1xuICAgIC8vIGluIHRoZW0gKG9yIC0xIGZvciBubyBwb2ludHMpLCBzbyB0aGF0IHNjYW5zIHRoYXQgYXJlXG4gICAgLy8gb25seSBpbnRlcmVzdGVkIGluIHBvaW50cyAoc3VjaCBhcyB0aGVcbiAgICAvLyBoZWlnaHRtYXAtcmVsYXRlZCBsb2dpYykgY2FuIHNraXAgcmFuZ2Utb25seSBjaHVua3MuXG4gICAgbWF4UG9pbnQpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubWF4UG9pbnQgPSBtYXhQb2ludDtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMudG9bdGhpcy50by5sZW5ndGggLSAxXTsgfVxuICAgIC8vIEZpbmQgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgc2lkZS4gVXNlIHRoZSByYW5nZXMnXG4gICAgLy8gYGZyb21gIHBvcyB3aGVuIGBlbmQgPT0gZmFsc2VgLCBgdG9gIHdoZW4gYGVuZCA9PSB0cnVlYC5cbiAgICBmaW5kSW5kZXgocG9zLCBzaWRlLCBlbmQsIHN0YXJ0QXQgPSAwKSB7XG4gICAgICAgIGxldCBhcnIgPSBlbmQgPyB0aGlzLnRvIDogdGhpcy5mcm9tO1xuICAgICAgICBmb3IgKGxldCBsbyA9IHN0YXJ0QXQsIGhpID0gYXJyLmxlbmd0aDs7KSB7XG4gICAgICAgICAgICBpZiAobG8gPT0gaGkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvO1xuICAgICAgICAgICAgbGV0IG1pZCA9IChsbyArIGhpKSA+PiAxO1xuICAgICAgICAgICAgbGV0IGRpZmYgPSBhcnJbbWlkXSAtIHBvcyB8fCAoZW5kID8gdGhpcy52YWx1ZVttaWRdLmVuZFNpZGUgOiB0aGlzLnZhbHVlW21pZF0uc3RhcnRTaWRlKSAtIHNpZGU7XG4gICAgICAgICAgICBpZiAobWlkID09IGxvKVxuICAgICAgICAgICAgICAgIHJldHVybiBkaWZmID49IDAgPyBsbyA6IGhpO1xuICAgICAgICAgICAgaWYgKGRpZmYgPj0gMClcbiAgICAgICAgICAgICAgICBoaSA9IG1pZDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBsbyA9IG1pZCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmV0d2VlbihvZmZzZXQsIGZyb20sIHRvLCBmKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZpbmRJbmRleChmcm9tLCAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLywgdHJ1ZSksIGUgPSB0aGlzLmZpbmRJbmRleCh0bywgMTAwMDAwMDAwMCAvKiBDLkZhciAqLywgZmFsc2UsIGkpOyBpIDwgZTsgaSsrKVxuICAgICAgICAgICAgaWYgKGYodGhpcy5mcm9tW2ldICsgb2Zmc2V0LCB0aGlzLnRvW2ldICsgb2Zmc2V0LCB0aGlzLnZhbHVlW2ldKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtYXAob2Zmc2V0LCBjaGFuZ2VzKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IFtdLCBmcm9tID0gW10sIHRvID0gW10sIG5ld1BvcyA9IC0xLCBtYXhQb2ludCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2YWwgPSB0aGlzLnZhbHVlW2ldLCBjdXJGcm9tID0gdGhpcy5mcm9tW2ldICsgb2Zmc2V0LCBjdXJUbyA9IHRoaXMudG9baV0gKyBvZmZzZXQsIG5ld0Zyb20sIG5ld1RvO1xuICAgICAgICAgICAgaWYgKGN1ckZyb20gPT0gY3VyVG8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFwcGVkID0gY2hhbmdlcy5tYXBQb3MoY3VyRnJvbSwgdmFsLnN0YXJ0U2lkZSwgdmFsLm1hcE1vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChtYXBwZWQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgbmV3RnJvbSA9IG5ld1RvID0gbWFwcGVkO1xuICAgICAgICAgICAgICAgIGlmICh2YWwuc3RhcnRTaWRlICE9IHZhbC5lbmRTaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1RvID0gY2hhbmdlcy5tYXBQb3MoY3VyRnJvbSwgdmFsLmVuZFNpZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3VG8gPCBuZXdGcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3RnJvbSA9IGNoYW5nZXMubWFwUG9zKGN1ckZyb20sIHZhbC5zdGFydFNpZGUpO1xuICAgICAgICAgICAgICAgIG5ld1RvID0gY2hhbmdlcy5tYXBQb3MoY3VyVG8sIHZhbC5lbmRTaWRlKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3RnJvbSA+IG5ld1RvIHx8IG5ld0Zyb20gPT0gbmV3VG8gJiYgdmFsLnN0YXJ0U2lkZSA+IDAgJiYgdmFsLmVuZFNpZGUgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG5ld1RvIC0gbmV3RnJvbSB8fCB2YWwuZW5kU2lkZSAtIHZhbC5zdGFydFNpZGUpIDwgMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChuZXdQb3MgPCAwKVxuICAgICAgICAgICAgICAgIG5ld1BvcyA9IG5ld0Zyb207XG4gICAgICAgICAgICBpZiAodmFsLnBvaW50KVxuICAgICAgICAgICAgICAgIG1heFBvaW50ID0gTWF0aC5tYXgobWF4UG9pbnQsIG5ld1RvIC0gbmV3RnJvbSk7XG4gICAgICAgICAgICB2YWx1ZS5wdXNoKHZhbCk7XG4gICAgICAgICAgICBmcm9tLnB1c2gobmV3RnJvbSAtIG5ld1Bvcyk7XG4gICAgICAgICAgICB0by5wdXNoKG5ld1RvIC0gbmV3UG9zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtYXBwZWQ6IHZhbHVlLmxlbmd0aCA/IG5ldyBDaHVuayhmcm9tLCB0bywgdmFsdWUsIG1heFBvaW50KSA6IG51bGwsIHBvczogbmV3UG9zIH07XG4gICAgfVxufVxuLyoqXG5BIHJhbmdlIHNldCBzdG9yZXMgYSBjb2xsZWN0aW9uIG9mIFtyYW5nZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2UpIGluIGFcbndheSB0aGF0IG1ha2VzIHRoZW0gZWZmaWNpZW50IHRvIFttYXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2VTZXQubWFwKSBhbmRcblt1cGRhdGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2VTZXQudXBkYXRlKS4gVGhpcyBpcyBhbiBpbW11dGFibGUgZGF0YVxuc3RydWN0dXJlLlxuKi9cbmNsYXNzIFJhbmdlU2V0IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNodW5rUG9zLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNodW5rLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG5leHRMYXllciwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXhQb2ludCkge1xuICAgICAgICB0aGlzLmNodW5rUG9zID0gY2h1bmtQb3M7XG4gICAgICAgIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgICAgICAgdGhpcy5uZXh0TGF5ZXIgPSBuZXh0TGF5ZXI7XG4gICAgICAgIHRoaXMubWF4UG9pbnQgPSBtYXhQb2ludDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGNodW5rUG9zLCBjaHVuaywgbmV4dExheWVyLCBtYXhQb2ludCkge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlU2V0KGNodW5rUG9zLCBjaHVuaywgbmV4dExheWVyLCBtYXhQb2ludCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmNodW5rLmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiBsYXN0IDwgMCA/IDAgOiBNYXRoLm1heCh0aGlzLmNodW5rRW5kKGxhc3QpLCB0aGlzLm5leHRMYXllci5sZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbnVtYmVyIG9mIHJhbmdlcyBpbiB0aGUgc2V0LlxuICAgICovXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IHNpemUgPSB0aGlzLm5leHRMYXllci5zaXplO1xuICAgICAgICBmb3IgKGxldCBjaHVuayBvZiB0aGlzLmNodW5rKVxuICAgICAgICAgICAgc2l6ZSArPSBjaHVuay52YWx1ZS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNodW5rRW5kKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNodW5rUG9zW2luZGV4XSArIHRoaXMuY2h1bmtbaW5kZXhdLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSByYW5nZSBzZXQsIG9wdGlvbmFsbHkgYWRkaW5nIG5ldyByYW5nZXMgb3IgZmlsdGVyaW5nXG4gICAgb3V0IGV4aXN0aW5nIG9uZXMuXG4gICAgXG4gICAgKE5vdGU6IFRoZSB0eXBlIHBhcmFtZXRlciBpcyBqdXN0IHRoZXJlIGFzIGEga2x1ZGdlIHRvIHdvcmtcbiAgICBhcm91bmQgVHlwZVNjcmlwdCB2YXJpYW5jZSBpc3N1ZXMgdGhhdCBwcmV2ZW50ZWQgYFJhbmdlU2V0PFg+YFxuICAgIGZyb20gYmVpbmcgYSBzdWJ0eXBlIG9mIGBSYW5nZVNldDxZPmAgd2hlbiBgWGAgaXMgYSBzdWJ0eXBlIG9mXG4gICAgYFlgLilcbiAgICAqL1xuICAgIHVwZGF0ZSh1cGRhdGVTcGVjKSB7XG4gICAgICAgIGxldCB7IGFkZCA9IFtdLCBzb3J0ID0gZmFsc2UsIGZpbHRlckZyb20gPSAwLCBmaWx0ZXJUbyA9IHRoaXMubGVuZ3RoIH0gPSB1cGRhdGVTcGVjO1xuICAgICAgICBsZXQgZmlsdGVyID0gdXBkYXRlU3BlYy5maWx0ZXI7XG4gICAgICAgIGlmIChhZGQubGVuZ3RoID09IDAgJiYgIWZpbHRlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAoc29ydClcbiAgICAgICAgICAgIGFkZCA9IGFkZC5zbGljZSgpLnNvcnQoY21wUmFuZ2UpO1xuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIGFkZC5sZW5ndGggPyBSYW5nZVNldC5vZihhZGQpIDogdGhpcztcbiAgICAgICAgbGV0IGN1ciA9IG5ldyBMYXllckN1cnNvcih0aGlzLCBudWxsLCAtMSkuZ290bygwKSwgaSA9IDAsIHNwaWxsID0gW107XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICB3aGlsZSAoY3VyLnZhbHVlIHx8IGkgPCBhZGQubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaSA8IGFkZC5sZW5ndGggJiYgKGN1ci5mcm9tIC0gYWRkW2ldLmZyb20gfHwgY3VyLnN0YXJ0U2lkZSAtIGFkZFtpXS52YWx1ZS5zdGFydFNpZGUpID49IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2UgPSBhZGRbaSsrXTtcbiAgICAgICAgICAgICAgICBpZiAoIWJ1aWxkZXIuYWRkSW5uZXIocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHJhbmdlLnZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgc3BpbGwucHVzaChyYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXIucmFuZ2VJbmRleCA9PSAxICYmIGN1ci5jaHVua0luZGV4IDwgdGhpcy5jaHVuay5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAoaSA9PSBhZGQubGVuZ3RoIHx8IHRoaXMuY2h1bmtFbmQoY3VyLmNodW5rSW5kZXgpIDwgYWRkW2ldLmZyb20pICYmXG4gICAgICAgICAgICAgICAgKCFmaWx0ZXIgfHwgZmlsdGVyRnJvbSA+IHRoaXMuY2h1bmtFbmQoY3VyLmNodW5rSW5kZXgpIHx8IGZpbHRlclRvIDwgdGhpcy5jaHVua1Bvc1tjdXIuY2h1bmtJbmRleF0pICYmXG4gICAgICAgICAgICAgICAgYnVpbGRlci5hZGRDaHVuayh0aGlzLmNodW5rUG9zW2N1ci5jaHVua0luZGV4XSwgdGhpcy5jaHVua1tjdXIuY2h1bmtJbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgY3VyLm5leHRDaHVuaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyRnJvbSA+IGN1ci50byB8fCBmaWx0ZXJUbyA8IGN1ci5mcm9tIHx8IGZpbHRlcihjdXIuZnJvbSwgY3VyLnRvLCBjdXIudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYnVpbGRlci5hZGRJbm5lcihjdXIuZnJvbSwgY3VyLnRvLCBjdXIudmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3BpbGwucHVzaChSYW5nZS5jcmVhdGUoY3VyLmZyb20sIGN1ci50bywgY3VyLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1ci5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoSW5uZXIodGhpcy5uZXh0TGF5ZXIuaXNFbXB0eSAmJiAhc3BpbGwubGVuZ3RoID8gUmFuZ2VTZXQuZW1wdHlcbiAgICAgICAgICAgIDogdGhpcy5uZXh0TGF5ZXIudXBkYXRlKHsgYWRkOiBzcGlsbCwgZmlsdGVyLCBmaWx0ZXJGcm9tLCBmaWx0ZXJUbyB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCB0aGlzIHJhbmdlIHNldCB0aHJvdWdoIGEgc2V0IG9mIGNoYW5nZXMsIHJldHVybiB0aGUgbmV3IHNldC5cbiAgICAqL1xuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmVtcHR5IHx8IHRoaXMuaXNFbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgY2h1bmtzID0gW10sIGNodW5rUG9zID0gW10sIG1heFBvaW50ID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVuay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5jaHVua1Bvc1tpXSwgY2h1bmsgPSB0aGlzLmNodW5rW2ldO1xuICAgICAgICAgICAgbGV0IHRvdWNoID0gY2hhbmdlcy50b3VjaGVzUmFuZ2Uoc3RhcnQsIHN0YXJ0ICsgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmICh0b3VjaCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBtYXhQb2ludCA9IE1hdGgubWF4KG1heFBvaW50LCBjaHVuay5tYXhQb2ludCk7XG4gICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgIGNodW5rUG9zLnB1c2goY2hhbmdlcy5tYXBQb3Moc3RhcnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRvdWNoID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgbWFwcGVkLCBwb3MgfSA9IGNodW5rLm1hcChzdGFydCwgY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICBtYXhQb2ludCA9IE1hdGgubWF4KG1heFBvaW50LCBtYXBwZWQubWF4UG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaChtYXBwZWQpO1xuICAgICAgICAgICAgICAgICAgICBjaHVua1Bvcy5wdXNoKHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5uZXh0TGF5ZXIubWFwKGNoYW5nZXMpO1xuICAgICAgICByZXR1cm4gY2h1bmtzLmxlbmd0aCA9PSAwID8gbmV4dCA6IG5ldyBSYW5nZVNldChjaHVua1BvcywgY2h1bmtzLCBuZXh0IHx8IFJhbmdlU2V0LmVtcHR5LCBtYXhQb2ludCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgcmFuZ2VzIHRoYXQgdG91Y2ggdGhlIHJlZ2lvbiBgZnJvbWAgdG8gYHRvYCxcbiAgICBjYWxsaW5nIGBmYCBmb3IgZWFjaC4gVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIHJhbmdlcyB3aWxsXG4gICAgYmUgcmVwb3J0ZWQgaW4gYW55IHNwZWNpZmljIG9yZGVyLiBXaGVuIHRoZSBjYWxsYmFjayByZXR1cm5zXG4gICAgYGZhbHNlYCwgaXRlcmF0aW9uIHN0b3BzLlxuICAgICovXG4gICAgYmV0d2Vlbihmcm9tLCB0bywgZikge1xuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmsubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMuY2h1bmtQb3NbaV0sIGNodW5rID0gdGhpcy5jaHVua1tpXTtcbiAgICAgICAgICAgIGlmICh0byA+PSBzdGFydCAmJiBmcm9tIDw9IHN0YXJ0ICsgY2h1bmsubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgY2h1bmsuYmV0d2VlbihzdGFydCwgZnJvbSAtIHN0YXJ0LCB0byAtIHN0YXJ0LCBmKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmV4dExheWVyLmJldHdlZW4oZnJvbSwgdG8sIGYpO1xuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyBpbiB0aGlzIHNldCwgaW4gb3JkZXIsIGluY2x1ZGluZyBhbGxcbiAgICByYW5nZXMgdGhhdCBlbmQgYXQgb3IgYWZ0ZXIgYGZyb21gLlxuICAgICovXG4gICAgaXRlcihmcm9tID0gMCkge1xuICAgICAgICByZXR1cm4gSGVhcEN1cnNvci5mcm9tKFt0aGlzXSkuZ290byhmcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgaXNFbXB0eSgpIHsgcmV0dXJuIHRoaXMubmV4dExheWVyID09IHRoaXM7IH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyBpbiBhIGNvbGxlY3Rpb24gb2Ygc2V0cywgaW4gb3JkZXIsXG4gICAgc3RhcnRpbmcgZnJvbSBgZnJvbWAuXG4gICAgKi9cbiAgICBzdGF0aWMgaXRlcihzZXRzLCBmcm9tID0gMCkge1xuICAgICAgICByZXR1cm4gSGVhcEN1cnNvci5mcm9tKHNldHMpLmdvdG8oZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0d28gZ3JvdXBzIG9mIHNldHMsIGNhbGxpbmcgbWV0aG9kcyBvbiBgY29tcGFyYXRvcmBcbiAgICB0byBub3RpZnkgaXQgb2YgcG9zc2libGUgZGlmZmVyZW5jZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgY29tcGFyZShvbGRTZXRzLCBuZXdTZXRzLCBcbiAgICAvKipcbiAgICBUaGlzIGluZGljYXRlcyBob3cgdGhlIHVuZGVybHlpbmcgZGF0YSBjaGFuZ2VkIGJldHdlZW4gdGhlc2VcbiAgICByYW5nZXMsIGFuZCBpcyBuZWVkZWQgdG8gc3luY2hyb25pemUgdGhlIGl0ZXJhdGlvbi5cbiAgICAqL1xuICAgIHRleHREaWZmLCBjb21wYXJhdG9yLCBcbiAgICAvKipcbiAgICBDYW4gYmUgdXNlZCB0byBpZ25vcmUgYWxsIG5vbi1wb2ludCByYW5nZXMsIGFuZCBwb2ludHMgYmVsb3dcbiAgICB0aGUgZ2l2ZW4gc2l6ZS4gV2hlbiAtMSwgYWxsIHJhbmdlcyBhcmUgY29tcGFyZWQuXG4gICAgKi9cbiAgICBtaW5Qb2ludFNpemUgPSAtMSkge1xuICAgICAgICBsZXQgYSA9IG9sZFNldHMuZmlsdGVyKHNldCA9PiBzZXQubWF4UG9pbnQgPiAwIHx8ICFzZXQuaXNFbXB0eSAmJiBzZXQubWF4UG9pbnQgPj0gbWluUG9pbnRTaXplKTtcbiAgICAgICAgbGV0IGIgPSBuZXdTZXRzLmZpbHRlcihzZXQgPT4gc2V0Lm1heFBvaW50ID4gMCB8fCAhc2V0LmlzRW1wdHkgJiYgc2V0Lm1heFBvaW50ID49IG1pblBvaW50U2l6ZSk7XG4gICAgICAgIGxldCBzaGFyZWRDaHVua3MgPSBmaW5kU2hhcmVkQ2h1bmtzKGEsIGIsIHRleHREaWZmKTtcbiAgICAgICAgbGV0IHNpZGVBID0gbmV3IFNwYW5DdXJzb3IoYSwgc2hhcmVkQ2h1bmtzLCBtaW5Qb2ludFNpemUpO1xuICAgICAgICBsZXQgc2lkZUIgPSBuZXcgU3BhbkN1cnNvcihiLCBzaGFyZWRDaHVua3MsIG1pblBvaW50U2l6ZSk7XG4gICAgICAgIHRleHREaWZmLml0ZXJHYXBzKChmcm9tQSwgZnJvbUIsIGxlbmd0aCkgPT4gY29tcGFyZShzaWRlQSwgZnJvbUEsIHNpZGVCLCBmcm9tQiwgbGVuZ3RoLCBjb21wYXJhdG9yKSk7XG4gICAgICAgIGlmICh0ZXh0RGlmZi5lbXB0eSAmJiB0ZXh0RGlmZi5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIGNvbXBhcmUoc2lkZUEsIDAsIHNpZGVCLCAwLCAwLCBjb21wYXJhdG9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGUgY29udGVudHMgb2YgdHdvIGdyb3VwcyBvZiByYW5nZSBzZXRzLCByZXR1cm5pbmcgdHJ1ZVxuICAgIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQgaW4gdGhlIGdpdmVuIHJhbmdlLlxuICAgICovXG4gICAgc3RhdGljIGVxKG9sZFNldHMsIG5ld1NldHMsIGZyb20gPSAwLCB0bykge1xuICAgICAgICBpZiAodG8gPT0gbnVsbClcbiAgICAgICAgICAgIHRvID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLyAtIDE7XG4gICAgICAgIGxldCBhID0gb2xkU2V0cy5maWx0ZXIoc2V0ID0+ICFzZXQuaXNFbXB0eSAmJiBuZXdTZXRzLmluZGV4T2Yoc2V0KSA8IDApO1xuICAgICAgICBsZXQgYiA9IG5ld1NldHMuZmlsdGVyKHNldCA9PiAhc2V0LmlzRW1wdHkgJiYgb2xkU2V0cy5pbmRleE9mKHNldCkgPCAwKTtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWEubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCBzaGFyZWRDaHVua3MgPSBmaW5kU2hhcmVkQ2h1bmtzKGEsIGIpO1xuICAgICAgICBsZXQgc2lkZUEgPSBuZXcgU3BhbkN1cnNvcihhLCBzaGFyZWRDaHVua3MsIDApLmdvdG8oZnJvbSksIHNpZGVCID0gbmV3IFNwYW5DdXJzb3IoYiwgc2hhcmVkQ2h1bmtzLCAwKS5nb3RvKGZyb20pO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoc2lkZUEudG8gIT0gc2lkZUIudG8gfHxcbiAgICAgICAgICAgICAgICAhc2FtZVZhbHVlcyhzaWRlQS5hY3RpdmUsIHNpZGVCLmFjdGl2ZSkgfHxcbiAgICAgICAgICAgICAgICBzaWRlQS5wb2ludCAmJiAoIXNpZGVCLnBvaW50IHx8ICFzaWRlQS5wb2ludC5lcShzaWRlQi5wb2ludCkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzaWRlQS50byA+IHRvKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgc2lkZUEubmV4dCgpO1xuICAgICAgICAgICAgc2lkZUIubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciBhIGdyb3VwIG9mIHJhbmdlIHNldHMgYXQgdGhlIHNhbWUgdGltZSwgbm90aWZ5aW5nXG4gICAgdGhlIGl0ZXJhdG9yIGFib3V0IHRoZSByYW5nZXMgY292ZXJpbmcgZXZlcnkgZ2l2ZW4gcGllY2Ugb2ZcbiAgICBjb250ZW50LiBSZXR1cm5zIHRoZSBvcGVuIGNvdW50IChzZWVcbiAgICBbYFNwYW5JdGVyYXRvci5zcGFuYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TcGFuSXRlcmF0b3Iuc3BhbikpIGF0IHRoZSBlbmRcbiAgICBvZiB0aGUgaXRlcmF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIHNwYW5zKHNldHMsIGZyb20sIHRvLCBpdGVyYXRvciwgXG4gICAgLyoqXG4gICAgV2hlbiBnaXZlbiBhbmQgZ3JlYXRlciB0aGFuIC0xLCBvbmx5IHBvaW50cyBvZiBhdCBsZWFzdCB0aGlzXG4gICAgc2l6ZSBhcmUgdGFrZW4gaW50byBhY2NvdW50LlxuICAgICovXG4gICAgbWluUG9pbnRTaXplID0gLTEpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBTcGFuQ3Vyc29yKHNldHMsIG51bGwsIG1pblBvaW50U2l6ZSkuZ290byhmcm9tKSwgcG9zID0gZnJvbTtcbiAgICAgICAgbGV0IG9wZW5SYW5nZXMgPSBjdXJzb3Iub3BlblN0YXJ0O1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgY3VyVG8gPSBNYXRoLm1pbihjdXJzb3IudG8sIHRvKTtcbiAgICAgICAgICAgIGlmIChjdXJzb3IucG9pbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWN0aXZlID0gY3Vyc29yLmFjdGl2ZUZvclBvaW50KGN1cnNvci50byk7XG4gICAgICAgICAgICAgICAgbGV0IG9wZW5Db3VudCA9IGN1cnNvci5wb2ludEZyb20gPCBmcm9tID8gYWN0aXZlLmxlbmd0aCArIDFcbiAgICAgICAgICAgICAgICAgICAgOiBjdXJzb3IucG9pbnQuc3RhcnRTaWRlIDwgMCA/IGFjdGl2ZS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIDogTWF0aC5taW4oYWN0aXZlLmxlbmd0aCwgb3BlblJhbmdlcyk7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IucG9pbnQocG9zLCBjdXJUbywgY3Vyc29yLnBvaW50LCBhY3RpdmUsIG9wZW5Db3VudCwgY3Vyc29yLnBvaW50UmFuayk7XG4gICAgICAgICAgICAgICAgb3BlblJhbmdlcyA9IE1hdGgubWluKGN1cnNvci5vcGVuRW5kKGN1clRvKSwgYWN0aXZlLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJUbyA+IHBvcykge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnNwYW4ocG9zLCBjdXJUbywgY3Vyc29yLmFjdGl2ZSwgb3BlblJhbmdlcyk7XG4gICAgICAgICAgICAgICAgb3BlblJhbmdlcyA9IGN1cnNvci5vcGVuRW5kKGN1clRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPiB0bylcbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlblJhbmdlcyArIChjdXJzb3IucG9pbnQgJiYgY3Vyc29yLnRvID4gdG8gPyAxIDogMCk7XG4gICAgICAgICAgICBwb3MgPSBjdXJzb3IudG87XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHJhbmdlIHNldCBmb3IgdGhlIGdpdmVuIHJhbmdlIG9yIGFycmF5IG9mIHJhbmdlcy4gQnlcbiAgICBkZWZhdWx0LCB0aGlzIGV4cGVjdHMgdGhlIHJhbmdlcyB0byBiZSBfc29ydGVkXyAoYnkgc3RhcnRcbiAgICBwb3NpdGlvbiBhbmQsIGlmIHR3byBzdGFydCBhdCB0aGUgc2FtZSBwb3NpdGlvbixcbiAgICBgdmFsdWUuc3RhcnRTaWRlYCkuIFlvdSBjYW4gcGFzcyBgdHJ1ZWAgYXMgc2Vjb25kIGFyZ3VtZW50IHRvXG4gICAgY2F1c2UgdGhlIG1ldGhvZCB0byBzb3J0IHRoZW0uXG4gICAgKi9cbiAgICBzdGF0aWMgb2YocmFuZ2VzLCBzb3J0ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGJ1aWxkID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICBmb3IgKGxldCByYW5nZSBvZiByYW5nZXMgaW5zdGFuY2VvZiBSYW5nZSA/IFtyYW5nZXNdIDogc29ydCA/IGxhenlTb3J0KHJhbmdlcykgOiByYW5nZXMpXG4gICAgICAgICAgICBidWlsZC5hZGQocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHJhbmdlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkLmZpbmlzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBKb2luIGFuIGFycmF5IG9mIHJhbmdlIHNldHMgaW50byBhIHNpbmdsZSBzZXQuXG4gICAgKi9cbiAgICBzdGF0aWMgam9pbihzZXRzKSB7XG4gICAgICAgIGlmICghc2V0cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gUmFuZ2VTZXQuZW1wdHk7XG4gICAgICAgIGxldCByZXN1bHQgPSBzZXRzW3NldHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGZvciAobGV0IGkgPSBzZXRzLmxlbmd0aCAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBsYXllciA9IHNldHNbaV07IGxheWVyICE9IFJhbmdlU2V0LmVtcHR5OyBsYXllciA9IGxheWVyLm5leHRMYXllcilcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgUmFuZ2VTZXQobGF5ZXIuY2h1bmtQb3MsIGxheWVyLmNodW5rLCByZXN1bHQsIE1hdGgubWF4KGxheWVyLm1heFBvaW50LCByZXN1bHQubWF4UG9pbnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNldCBvZiByYW5nZXMuXG4qL1xuUmFuZ2VTZXQuZW1wdHkgPSAvKkBfX1BVUkVfXyovbmV3IFJhbmdlU2V0KFtdLCBbXSwgbnVsbCwgLTEpO1xuZnVuY3Rpb24gbGF6eVNvcnQocmFuZ2VzKSB7XG4gICAgaWYgKHJhbmdlcy5sZW5ndGggPiAxKVxuICAgICAgICBmb3IgKGxldCBwcmV2ID0gcmFuZ2VzWzBdLCBpID0gMTsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1ciA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgIGlmIChjbXBSYW5nZShwcmV2LCBjdXIpID4gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VzLnNsaWNlKCkuc29ydChjbXBSYW5nZSk7XG4gICAgICAgICAgICBwcmV2ID0gY3VyO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cblJhbmdlU2V0LmVtcHR5Lm5leHRMYXllciA9IFJhbmdlU2V0LmVtcHR5O1xuLyoqXG5BIHJhbmdlIHNldCBidWlsZGVyIGlzIGEgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBoZWxwcyBidWlsZCB1cCBhXG5bcmFuZ2Ugc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlU2V0KSBkaXJlY3RseSwgd2l0aG91dCBmaXJzdCBhbGxvY2F0aW5nXG5hbiBhcnJheSBvZiBbYFJhbmdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZSkgb2JqZWN0cy5cbiovXG5jbGFzcyBSYW5nZVNldEJ1aWxkZXIge1xuICAgIGZpbmlzaENodW5rKG5ld0FycmF5cykge1xuICAgICAgICB0aGlzLmNodW5rcy5wdXNoKG5ldyBDaHVuayh0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMudmFsdWUsIHRoaXMubWF4UG9pbnQpKTtcbiAgICAgICAgdGhpcy5jaHVua1Bvcy5wdXNoKHRoaXMuY2h1bmtTdGFydCk7XG4gICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IC0xO1xuICAgICAgICB0aGlzLnNldE1heFBvaW50ID0gTWF0aC5tYXgodGhpcy5zZXRNYXhQb2ludCwgdGhpcy5tYXhQb2ludCk7XG4gICAgICAgIHRoaXMubWF4UG9pbnQgPSAtMTtcbiAgICAgICAgaWYgKG5ld0FycmF5cykge1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gW107XG4gICAgICAgICAgICB0aGlzLnRvID0gW107XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGVtcHR5IGJ1aWxkZXIuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1BvcyA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0RnJvbSA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICB0aGlzLmxhc3RUbyA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICB0aGlzLmZyb20gPSBbXTtcbiAgICAgICAgdGhpcy50byA9IFtdO1xuICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgIHRoaXMubWF4UG9pbnQgPSAtMTtcbiAgICAgICAgdGhpcy5zZXRNYXhQb2ludCA9IC0xO1xuICAgICAgICB0aGlzLm5leHRMYXllciA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhIHJhbmdlLiBSYW5nZXMgc2hvdWxkIGJlIGFkZGVkIGluIHNvcnRlZCAoYnkgYGZyb21gIGFuZFxuICAgIGB2YWx1ZS5zdGFydFNpZGVgKSBvcmRlci5cbiAgICAqL1xuICAgIGFkZChmcm9tLCB0bywgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFkZElubmVyKGZyb20sIHRvLCB2YWx1ZSkpXG4gICAgICAgICAgICAodGhpcy5uZXh0TGF5ZXIgfHwgKHRoaXMubmV4dExheWVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcikpLmFkZChmcm9tLCB0bywgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFkZElubmVyKGZyb20sIHRvLCB2YWx1ZSkge1xuICAgICAgICBsZXQgZGlmZiA9IGZyb20gLSB0aGlzLmxhc3RUbyB8fCB2YWx1ZS5zdGFydFNpZGUgLSB0aGlzLmxhc3QuZW5kU2lkZTtcbiAgICAgICAgaWYgKGRpZmYgPD0gMCAmJiAoZnJvbSAtIHRoaXMubGFzdEZyb20gfHwgdmFsdWUuc3RhcnRTaWRlIC0gdGhpcy5sYXN0LnN0YXJ0U2lkZSkgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuZ2VzIG11c3QgYmUgYWRkZWQgc29ydGVkIGJ5IGBmcm9tYCBwb3NpdGlvbiBhbmQgYHN0YXJ0U2lkZWBcIik7XG4gICAgICAgIGlmIChkaWZmIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5sZW5ndGggPT0gMjUwIC8qIEMuQ2h1bmtTaXplICovKVxuICAgICAgICAgICAgdGhpcy5maW5pc2hDaHVuayh0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtTdGFydCA8IDApXG4gICAgICAgICAgICB0aGlzLmNodW5rU3RhcnQgPSBmcm9tO1xuICAgICAgICB0aGlzLmZyb20ucHVzaChmcm9tIC0gdGhpcy5jaHVua1N0YXJ0KTtcbiAgICAgICAgdGhpcy50by5wdXNoKHRvIC0gdGhpcy5jaHVua1N0YXJ0KTtcbiAgICAgICAgdGhpcy5sYXN0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMubGFzdEZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLmxhc3RUbyA9IHRvO1xuICAgICAgICB0aGlzLnZhbHVlLnB1c2godmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUucG9pbnQpXG4gICAgICAgICAgICB0aGlzLm1heFBvaW50ID0gTWF0aC5tYXgodGhpcy5tYXhQb2ludCwgdG8gLSBmcm9tKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYWRkQ2h1bmsoZnJvbSwgY2h1bmspIHtcbiAgICAgICAgaWYgKChmcm9tIC0gdGhpcy5sYXN0VG8gfHwgY2h1bmsudmFsdWVbMF0uc3RhcnRTaWRlIC0gdGhpcy5sYXN0LmVuZFNpZGUpIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKHRydWUpO1xuICAgICAgICB0aGlzLnNldE1heFBvaW50ID0gTWF0aC5tYXgodGhpcy5zZXRNYXhQb2ludCwgY2h1bmsubWF4UG9pbnQpO1xuICAgICAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgdGhpcy5jaHVua1Bvcy5wdXNoKGZyb20pO1xuICAgICAgICBsZXQgbGFzdCA9IGNodW5rLnZhbHVlLmxlbmd0aCAtIDE7XG4gICAgICAgIHRoaXMubGFzdCA9IGNodW5rLnZhbHVlW2xhc3RdO1xuICAgICAgICB0aGlzLmxhc3RGcm9tID0gY2h1bmsuZnJvbVtsYXN0XSArIGZyb207XG4gICAgICAgIHRoaXMubGFzdFRvID0gY2h1bmsudG9bbGFzdF0gKyBmcm9tO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluaXNoIHRoZSByYW5nZSBzZXQuIFJldHVybnMgdGhlIG5ldyBzZXQuIFRoZSBidWlsZGVyIGNhbid0IGJlXG4gICAgdXNlZCBhbnltb3JlIGFmdGVyIHRoaXMgaGFzIGJlZW4gY2FsbGVkLlxuICAgICovXG4gICAgZmluaXNoKCkgeyByZXR1cm4gdGhpcy5maW5pc2hJbm5lcihSYW5nZVNldC5lbXB0eSk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZpbmlzaElubmVyKG5leHQpIHtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKGZhbHNlKTtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIGxldCByZXN1bHQgPSBSYW5nZVNldC5jcmVhdGUodGhpcy5jaHVua1BvcywgdGhpcy5jaHVua3MsIHRoaXMubmV4dExheWVyID8gdGhpcy5uZXh0TGF5ZXIuZmluaXNoSW5uZXIobmV4dCkgOiBuZXh0LCB0aGlzLnNldE1heFBvaW50KTtcbiAgICAgICAgdGhpcy5mcm9tID0gbnVsbDsgLy8gTWFrZSBzdXJlIGZ1cnRoZXIgYGFkZGAgY2FsbHMgcHJvZHVjZSBlcnJvcnNcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kU2hhcmVkQ2h1bmtzKGEsIGIsIHRleHREaWZmKSB7XG4gICAgbGV0IGluQSA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGxldCBzZXQgb2YgYSlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQuY2h1bmsubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoc2V0LmNodW5rW2ldLm1heFBvaW50IDw9IDApXG4gICAgICAgICAgICAgICAgaW5BLnNldChzZXQuY2h1bmtbaV0sIHNldC5jaHVua1Bvc1tpXSk7XG4gICAgbGV0IHNoYXJlZCA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBzZXQgb2YgYilcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQuY2h1bmsubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBrbm93biA9IGluQS5nZXQoc2V0LmNodW5rW2ldKTtcbiAgICAgICAgICAgIGlmIChrbm93biAhPSBudWxsICYmICh0ZXh0RGlmZiA/IHRleHREaWZmLm1hcFBvcyhrbm93bikgOiBrbm93bikgPT0gc2V0LmNodW5rUG9zW2ldICYmXG4gICAgICAgICAgICAgICAgISh0ZXh0RGlmZiA9PT0gbnVsbCB8fCB0ZXh0RGlmZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGV4dERpZmYudG91Y2hlc1JhbmdlKGtub3duLCBrbm93biArIHNldC5jaHVua1tpXS5sZW5ndGgpKSlcbiAgICAgICAgICAgICAgICBzaGFyZWQuYWRkKHNldC5jaHVua1tpXSk7XG4gICAgICAgIH1cbiAgICByZXR1cm4gc2hhcmVkO1xufVxuY2xhc3MgTGF5ZXJDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGxheWVyLCBza2lwLCBtaW5Qb2ludCwgcmFuayA9IDApIHtcbiAgICAgICAgdGhpcy5sYXllciA9IGxheWVyO1xuICAgICAgICB0aGlzLnNraXAgPSBza2lwO1xuICAgICAgICB0aGlzLm1pblBvaW50ID0gbWluUG9pbnQ7XG4gICAgICAgIHRoaXMucmFuayA9IHJhbms7XG4gICAgfVxuICAgIGdldCBzdGFydFNpZGUoKSB7IHJldHVybiB0aGlzLnZhbHVlID8gdGhpcy52YWx1ZS5zdGFydFNpZGUgOiAwOyB9XG4gICAgZ2V0IGVuZFNpZGUoKSB7IHJldHVybiB0aGlzLnZhbHVlID8gdGhpcy52YWx1ZS5lbmRTaWRlIDogMDsgfVxuICAgIGdvdG8ocG9zLCBzaWRlID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi8pIHtcbiAgICAgICAgdGhpcy5jaHVua0luZGV4ID0gdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5nb3RvSW5uZXIocG9zLCBzaWRlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnb3RvSW5uZXIocG9zLCBzaWRlLCBmb3J3YXJkKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmNodW5rSW5kZXggPCB0aGlzLmxheWVyLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLmxheWVyLmNodW5rW3RoaXMuY2h1bmtJbmRleF07XG4gICAgICAgICAgICBpZiAoISh0aGlzLnNraXAgJiYgdGhpcy5za2lwLmhhcyhuZXh0KSB8fFxuICAgICAgICAgICAgICAgIHRoaXMubGF5ZXIuY2h1bmtFbmQodGhpcy5jaHVua0luZGV4KSA8IHBvcyB8fFxuICAgICAgICAgICAgICAgIG5leHQubWF4UG9pbnQgPCB0aGlzLm1pblBvaW50KSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtJbmRleCsrO1xuICAgICAgICAgICAgZm9yd2FyZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNodW5rSW5kZXggPCB0aGlzLmxheWVyLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHJhbmdlSW5kZXggPSB0aGlzLmxheWVyLmNodW5rW3RoaXMuY2h1bmtJbmRleF0uZmluZEluZGV4KHBvcyAtIHRoaXMubGF5ZXIuY2h1bmtQb3NbdGhpcy5jaHVua0luZGV4XSwgc2lkZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIWZvcndhcmQgfHwgdGhpcy5yYW5nZUluZGV4IDwgcmFuZ2VJbmRleClcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJhbmdlSW5kZXgocmFuZ2VJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIGZvcndhcmQocG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICgodGhpcy50byAtIHBvcyB8fCB0aGlzLmVuZFNpZGUgLSBzaWRlKSA8IDApXG4gICAgICAgICAgICB0aGlzLmdvdG9Jbm5lcihwb3MsIHNpZGUsIHRydWUpO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaHVua0luZGV4ID09IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tID0gdGhpcy50byA9IDEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgY2h1bmtQb3MgPSB0aGlzLmxheWVyLmNodW5rUG9zW3RoaXMuY2h1bmtJbmRleF0sIGNodW5rID0gdGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdO1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gY2h1bmtQb3MgKyBjaHVuay5mcm9tW3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvID0gY2h1bmtQb3MgKyBjaHVuay50b1t0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBjaHVuay52YWx1ZVt0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmFuZ2VJbmRleCh0aGlzLnJhbmdlSW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5taW5Qb2ludCA8IDAgfHwgdGhpcy52YWx1ZS5wb2ludCAmJiB0aGlzLnRvIC0gdGhpcy5mcm9tID49IHRoaXMubWluUG9pbnQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldFJhbmdlSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID09IHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XS52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtJbmRleCsrO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2tpcCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmNodW5rSW5kZXggPCB0aGlzLmxheWVyLmNodW5rLmxlbmd0aCAmJiB0aGlzLnNraXAuaGFzKHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XSkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmFuZ2VJbmRleCA9IGluZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIG5leHRDaHVuaygpIHtcbiAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgIHRoaXMucmFuZ2VJbmRleCA9IDA7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBjb21wYXJlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20gLSBvdGhlci5mcm9tIHx8IHRoaXMuc3RhcnRTaWRlIC0gb3RoZXIuc3RhcnRTaWRlIHx8IHRoaXMucmFuayAtIG90aGVyLnJhbmsgfHxcbiAgICAgICAgICAgIHRoaXMudG8gLSBvdGhlci50byB8fCB0aGlzLmVuZFNpZGUgLSBvdGhlci5lbmRTaWRlO1xuICAgIH1cbn1cbmNsYXNzIEhlYXBDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGhlYXApIHtcbiAgICAgICAgdGhpcy5oZWFwID0gaGVhcDtcbiAgICB9XG4gICAgc3RhdGljIGZyb20oc2V0cywgc2tpcCA9IG51bGwsIG1pblBvaW50ID0gLTEpIHtcbiAgICAgICAgbGV0IGhlYXAgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjdXIgPSBzZXRzW2ldOyAhY3VyLmlzRW1wdHk7IGN1ciA9IGN1ci5uZXh0TGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLm1heFBvaW50ID49IG1pblBvaW50KVxuICAgICAgICAgICAgICAgICAgICBoZWFwLnB1c2gobmV3IExheWVyQ3Vyc29yKGN1ciwgc2tpcCwgbWluUG9pbnQsIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhcC5sZW5ndGggPT0gMSA/IGhlYXBbMF0gOiBuZXcgSGVhcEN1cnNvcihoZWFwKTtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0U2lkZSgpIHsgcmV0dXJuIHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLnN0YXJ0U2lkZSA6IDA7IH1cbiAgICBnb3RvKHBvcywgc2lkZSA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovKSB7XG4gICAgICAgIGZvciAobGV0IGN1ciBvZiB0aGlzLmhlYXApXG4gICAgICAgICAgICBjdXIuZ290byhwb3MsIHNpZGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5oZWFwLmxlbmd0aCA+PiAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIGhlYXBCdWJibGUodGhpcy5oZWFwLCBpKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmb3J3YXJkKHBvcywgc2lkZSkge1xuICAgICAgICBmb3IgKGxldCBjdXIgb2YgdGhpcy5oZWFwKVxuICAgICAgICAgICAgY3VyLmZvcndhcmQocG9zLCBzaWRlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaGVhcC5sZW5ndGggPj4gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICBoZWFwQnViYmxlKHRoaXMuaGVhcCwgaSk7XG4gICAgICAgIGlmICgodGhpcy50byAtIHBvcyB8fCB0aGlzLnZhbHVlLmVuZFNpZGUgLSBzaWRlKSA8IDApXG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVhcC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gdGhpcy50byA9IDEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucmFuayA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMuaGVhcFswXTtcbiAgICAgICAgICAgIHRoaXMuZnJvbSA9IHRvcC5mcm9tO1xuICAgICAgICAgICAgdGhpcy50byA9IHRvcC50bztcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0b3AudmFsdWU7XG4gICAgICAgICAgICB0aGlzLnJhbmsgPSB0b3AucmFuaztcbiAgICAgICAgICAgIGlmICh0b3AudmFsdWUpXG4gICAgICAgICAgICAgICAgdG9wLm5leHQoKTtcbiAgICAgICAgICAgIGhlYXBCdWJibGUodGhpcy5oZWFwLCAwKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGhlYXBCdWJibGUoaGVhcCwgaW5kZXgpIHtcbiAgICBmb3IgKGxldCBjdXIgPSBoZWFwW2luZGV4XTs7KSB7XG4gICAgICAgIGxldCBjaGlsZEluZGV4ID0gKGluZGV4IDw8IDEpICsgMTtcbiAgICAgICAgaWYgKGNoaWxkSW5kZXggPj0gaGVhcC5sZW5ndGgpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGNoaWxkID0gaGVhcFtjaGlsZEluZGV4XTtcbiAgICAgICAgaWYgKGNoaWxkSW5kZXggKyAxIDwgaGVhcC5sZW5ndGggJiYgY2hpbGQuY29tcGFyZShoZWFwW2NoaWxkSW5kZXggKyAxXSkgPj0gMCkge1xuICAgICAgICAgICAgY2hpbGQgPSBoZWFwW2NoaWxkSW5kZXggKyAxXTtcbiAgICAgICAgICAgIGNoaWxkSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyLmNvbXBhcmUoY2hpbGQpIDwgMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBoZWFwW2NoaWxkSW5kZXhdID0gY3VyO1xuICAgICAgICBoZWFwW2luZGV4XSA9IGNoaWxkO1xuICAgICAgICBpbmRleCA9IGNoaWxkSW5kZXg7XG4gICAgfVxufVxuY2xhc3MgU3BhbkN1cnNvciB7XG4gICAgY29uc3RydWN0b3Ioc2V0cywgc2tpcCwgbWluUG9pbnQpIHtcbiAgICAgICAgdGhpcy5taW5Qb2ludCA9IG1pblBvaW50O1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZVRvID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlUmFuayA9IFtdO1xuICAgICAgICB0aGlzLm1pbkFjdGl2ZSA9IC0xO1xuICAgICAgICAvLyBBIGN1cnJlbnRseSBhY3RpdmUgcG9pbnQgcmFuZ2UsIGlmIGFueVxuICAgICAgICB0aGlzLnBvaW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wb2ludEZyb20gPSAwO1xuICAgICAgICB0aGlzLnBvaW50UmFuayA9IDA7XG4gICAgICAgIHRoaXMudG8gPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgdGhpcy5lbmRTaWRlID0gMDtcbiAgICAgICAgLy8gVGhlIGFtb3VudCBvZiBvcGVuIGFjdGl2ZSByYW5nZXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgLy8gTm90IGluY2x1ZGluZyBwb2ludHMuXG4gICAgICAgIHRoaXMub3BlblN0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gSGVhcEN1cnNvci5mcm9tKHNldHMsIHNraXAsIG1pblBvaW50KTtcbiAgICB9XG4gICAgZ290byhwb3MsIHNpZGUgPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLykge1xuICAgICAgICB0aGlzLmN1cnNvci5nb3RvKHBvcywgc2lkZSk7XG4gICAgICAgIHRoaXMuYWN0aXZlLmxlbmd0aCA9IHRoaXMuYWN0aXZlVG8ubGVuZ3RoID0gdGhpcy5hY3RpdmVSYW5rLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gLTE7XG4gICAgICAgIHRoaXMudG8gPSBwb3M7XG4gICAgICAgIHRoaXMuZW5kU2lkZSA9IHNpZGU7XG4gICAgICAgIHRoaXMub3BlblN0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZm9yd2FyZChwb3MsIHNpZGUpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMubWluQWN0aXZlID4gLTEgJiYgKHRoaXMuYWN0aXZlVG9bdGhpcy5taW5BY3RpdmVdIC0gcG9zIHx8IHRoaXMuYWN0aXZlW3RoaXMubWluQWN0aXZlXS5lbmRTaWRlIC0gc2lkZSkgPCAwKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVBY3RpdmUodGhpcy5taW5BY3RpdmUpO1xuICAgICAgICB0aGlzLmN1cnNvci5mb3J3YXJkKHBvcywgc2lkZSk7XG4gICAgfVxuICAgIHJlbW92ZUFjdGl2ZShpbmRleCkge1xuICAgICAgICByZW1vdmUodGhpcy5hY3RpdmUsIGluZGV4KTtcbiAgICAgICAgcmVtb3ZlKHRoaXMuYWN0aXZlVG8sIGluZGV4KTtcbiAgICAgICAgcmVtb3ZlKHRoaXMuYWN0aXZlUmFuaywgaW5kZXgpO1xuICAgICAgICB0aGlzLm1pbkFjdGl2ZSA9IGZpbmRNaW5JbmRleCh0aGlzLmFjdGl2ZSwgdGhpcy5hY3RpdmVUbyk7XG4gICAgfVxuICAgIGFkZEFjdGl2ZSh0cmFja09wZW4pIHtcbiAgICAgICAgbGV0IGkgPSAwLCB7IHZhbHVlLCB0bywgcmFuayB9ID0gdGhpcy5jdXJzb3I7XG4gICAgICAgIC8vIE9yZ2FuaXplIGFjdGl2ZSBtYXJrcyBieSByYW5rIGZpcnN0LCB0aGVuIGJ5IHNpemVcbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLmFjdGl2ZVJhbmsubGVuZ3RoICYmIChyYW5rIC0gdGhpcy5hY3RpdmVSYW5rW2ldIHx8IHRvIC0gdGhpcy5hY3RpdmVUb1tpXSkgPiAwKVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICBpbnNlcnQodGhpcy5hY3RpdmUsIGksIHZhbHVlKTtcbiAgICAgICAgaW5zZXJ0KHRoaXMuYWN0aXZlVG8sIGksIHRvKTtcbiAgICAgICAgaW5zZXJ0KHRoaXMuYWN0aXZlUmFuaywgaSwgcmFuayk7XG4gICAgICAgIGlmICh0cmFja09wZW4pXG4gICAgICAgICAgICBpbnNlcnQodHJhY2tPcGVuLCBpLCB0aGlzLmN1cnNvci5mcm9tKTtcbiAgICAgICAgdGhpcy5taW5BY3RpdmUgPSBmaW5kTWluSW5kZXgodGhpcy5hY3RpdmUsIHRoaXMuYWN0aXZlVG8pO1xuICAgIH1cbiAgICAvLyBBZnRlciBjYWxsaW5nIHRoaXMsIGlmIGB0aGlzLnBvaW50YCAhPSBudWxsLCB0aGUgbmV4dCByYW5nZSBpcyBhXG4gICAgLy8gcG9pbnQuIE90aGVyd2lzZSwgaXQncyBhIHJlZ3VsYXIgcmFuZ2UsIGNvdmVyZWQgYnkgYHRoaXMuYWN0aXZlYC5cbiAgICBuZXh0KCkge1xuICAgICAgICBsZXQgZnJvbSA9IHRoaXMudG8sIHdhc1BvaW50ID0gdGhpcy5wb2ludDtcbiAgICAgICAgdGhpcy5wb2ludCA9IG51bGw7XG4gICAgICAgIGxldCB0cmFja09wZW4gPSB0aGlzLm9wZW5TdGFydCA8IDAgPyBbXSA6IG51bGw7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBhID0gdGhpcy5taW5BY3RpdmU7XG4gICAgICAgICAgICBpZiAoYSA+IC0xICYmICh0aGlzLmFjdGl2ZVRvW2FdIC0gdGhpcy5jdXJzb3IuZnJvbSB8fCB0aGlzLmFjdGl2ZVthXS5lbmRTaWRlIC0gdGhpcy5jdXJzb3Iuc3RhcnRTaWRlKSA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVUb1thXSA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50byA9IHRoaXMuYWN0aXZlVG9bYV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kU2lkZSA9IHRoaXMuYWN0aXZlW2FdLmVuZFNpZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUFjdGl2ZShhKTtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tPcGVuKVxuICAgICAgICAgICAgICAgICAgICByZW1vdmUodHJhY2tPcGVuLCBhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmN1cnNvci52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudG8gPSB0aGlzLmVuZFNpZGUgPSAxMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jdXJzb3IuZnJvbSA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvID0gdGhpcy5jdXJzb3IuZnJvbTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZFNpZGUgPSB0aGlzLmN1cnNvci5zdGFydFNpZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFZhbCA9IHRoaXMuY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghbmV4dFZhbC5wb2ludCkgeyAvLyBPcGVuaW5nIGEgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRBY3RpdmUodHJhY2tPcGVuKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh3YXNQb2ludCAmJiB0aGlzLmN1cnNvci50byA9PSB0aGlzLnRvICYmIHRoaXMuY3Vyc29yLmZyb20gPCB0aGlzLmN1cnNvci50bykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgYW55IG5vbi1lbXB0eSBwb2ludHMgdGhhdCBlbmQgcHJlY2lzZWx5IGF0IHRoZSBlbmQgb2YgdGhlIHByZXYgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHsgLy8gTmV3IHBvaW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnQgPSBuZXh0VmFsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50RnJvbSA9IHRoaXMuY3Vyc29yLmZyb207XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRSYW5rID0gdGhpcy5jdXJzb3IucmFuaztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50byA9IHRoaXMuY3Vyc29yLnRvO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZFNpZGUgPSBuZXh0VmFsLmVuZFNpZGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3J3YXJkKHRoaXMudG8sIHRoaXMuZW5kU2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2tPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5TdGFydCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdHJhY2tPcGVuLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiB0cmFja09wZW5baV0gPCBmcm9tOyBpLS0pXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuU3RhcnQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhY3RpdmVGb3JQb2ludCh0bykge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZTtcbiAgICAgICAgbGV0IGFjdGl2ZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5hY3RpdmUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVJhbmtbaV0gPCB0aGlzLnBvaW50UmFuaylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVRvW2ldID4gdG8gfHwgdGhpcy5hY3RpdmVUb1tpXSA9PSB0byAmJiB0aGlzLmFjdGl2ZVtpXS5lbmRTaWRlID49IHRoaXMucG9pbnQuZW5kU2lkZSlcbiAgICAgICAgICAgICAgICBhY3RpdmUucHVzaCh0aGlzLmFjdGl2ZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjdGl2ZS5yZXZlcnNlKCk7XG4gICAgfVxuICAgIG9wZW5FbmQodG8pIHtcbiAgICAgICAgbGV0IG9wZW4gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5hY3RpdmVUby5sZW5ndGggLSAxOyBpID49IDAgJiYgdGhpcy5hY3RpdmVUb1tpXSA+IHRvOyBpLS0pXG4gICAgICAgICAgICBvcGVuKys7XG4gICAgICAgIHJldHVybiBvcGVuO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgc3RhcnRBLCBiLCBzdGFydEIsIGxlbmd0aCwgY29tcGFyYXRvcikge1xuICAgIGEuZ290byhzdGFydEEpO1xuICAgIGIuZ290byhzdGFydEIpO1xuICAgIGxldCBlbmRCID0gc3RhcnRCICsgbGVuZ3RoO1xuICAgIGxldCBwb3MgPSBzdGFydEIsIGRQb3MgPSBzdGFydEIgLSBzdGFydEE7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgZEVuZCA9IChhLnRvICsgZFBvcykgLSBiLnRvLCBkaWZmID0gZEVuZCB8fCBhLmVuZFNpZGUgLSBiLmVuZFNpZGU7XG4gICAgICAgIGxldCBlbmQgPSBkaWZmIDwgMCA/IGEudG8gKyBkUG9zIDogYi50bywgY2xpcEVuZCA9IE1hdGgubWluKGVuZCwgZW5kQik7XG4gICAgICAgIGlmIChhLnBvaW50IHx8IGIucG9pbnQpIHtcbiAgICAgICAgICAgIGlmICghKGEucG9pbnQgJiYgYi5wb2ludCAmJiAoYS5wb2ludCA9PSBiLnBvaW50IHx8IGEucG9pbnQuZXEoYi5wb2ludCkpICYmXG4gICAgICAgICAgICAgICAgc2FtZVZhbHVlcyhhLmFjdGl2ZUZvclBvaW50KGEudG8pLCBiLmFjdGl2ZUZvclBvaW50KGIudG8pKSkpXG4gICAgICAgICAgICAgICAgY29tcGFyYXRvci5jb21wYXJlUG9pbnQocG9zLCBjbGlwRW5kLCBhLnBvaW50LCBiLnBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjbGlwRW5kID4gcG9zICYmICFzYW1lVmFsdWVzKGEuYWN0aXZlLCBiLmFjdGl2ZSkpXG4gICAgICAgICAgICAgICAgY29tcGFyYXRvci5jb21wYXJlUmFuZ2UocG9zLCBjbGlwRW5kLCBhLmFjdGl2ZSwgYi5hY3RpdmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPiBlbmRCKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmICgoZEVuZCB8fCBhLm9wZW5FbmQgIT0gYi5vcGVuRW5kKSAmJiBjb21wYXJhdG9yLmJvdW5kQ2hhbmdlKVxuICAgICAgICAgICAgY29tcGFyYXRvci5ib3VuZENoYW5nZShlbmQpO1xuICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgIGlmIChkaWZmIDw9IDApXG4gICAgICAgICAgICBhLm5leHQoKTtcbiAgICAgICAgaWYgKGRpZmYgPj0gMClcbiAgICAgICAgICAgIGIubmV4dCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVWYWx1ZXMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKGFbaV0gIT0gYltpXSAmJiAhYVtpXS5lcShiW2ldKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlbW92ZShhcnJheSwgaW5kZXgpIHtcbiAgICBmb3IgKGxldCBpID0gaW5kZXgsIGUgPSBhcnJheS5sZW5ndGggLSAxOyBpIDwgZTsgaSsrKVxuICAgICAgICBhcnJheVtpXSA9IGFycmF5W2kgKyAxXTtcbiAgICBhcnJheS5wb3AoKTtcbn1cbmZ1bmN0aW9uIGluc2VydChhcnJheSwgaW5kZXgsIHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gaW5kZXg7IGktLSlcbiAgICAgICAgYXJyYXlbaSArIDFdID0gYXJyYXlbaV07XG4gICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG59XG5mdW5jdGlvbiBmaW5kTWluSW5kZXgodmFsdWUsIGFycmF5KSB7XG4gICAgbGV0IGZvdW5kID0gLTEsIGZvdW5kUG9zID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoKGFycmF5W2ldIC0gZm91bmRQb3MgfHwgdmFsdWVbaV0uZW5kU2lkZSAtIHZhbHVlW2ZvdW5kXS5lbmRTaWRlKSA8IDApIHtcbiAgICAgICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgICAgIGZvdW5kUG9zID0gYXJyYXlbaV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG59XG5cbi8qKlxuQ291bnQgdGhlIGNvbHVtbiBwb3NpdGlvbiBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IGludG8gdGhlIHN0cmluZyxcbnRha2luZyBleHRlbmRpbmcgY2hhcmFjdGVycyBhbmQgdGFiIHNpemUgaW50byBhY2NvdW50LlxuKi9cbmZ1bmN0aW9uIGNvdW50Q29sdW1uKHN0cmluZywgdGFiU2l6ZSwgdG8gPSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgbGV0IG4gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG8gJiYgaSA8IHN0cmluZy5sZW5ndGg7KSB7XG4gICAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdChpKSA9PSA5KSB7XG4gICAgICAgICAgICBuICs9IHRhYlNpemUgLSAobiAlIHRhYlNpemUpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbisrO1xuICAgICAgICAgICAgaSA9IGZpbmRDbHVzdGVyQnJlYWsoc3RyaW5nLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbjtcbn1cbi8qKlxuRmluZCB0aGUgb2Zmc2V0IHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGdpdmVuIGNvbHVtbiBwb3NpdGlvbiBpbiBhXG5zdHJpbmcsIHRha2luZyBleHRlbmRpbmcgY2hhcmFjdGVycyBhbmQgdGFiIHNpemUgaW50byBhY2NvdW50LiBCeVxuZGVmYXVsdCwgdGhlIHN0cmluZyBsZW5ndGggaXMgcmV0dXJuZWQgd2hlbiBpdCBpcyB0b28gc2hvcnQgdG9cbnJlYWNoIHRoZSBjb2x1bW4uIFBhc3MgYHN0cmljdGAgdHJ1ZSB0byBtYWtlIGl0IHJldHVybiAtMSBpbiB0aGF0XG5zaXR1YXRpb24uXG4qL1xuZnVuY3Rpb24gZmluZENvbHVtbihzdHJpbmcsIGNvbCwgdGFiU2l6ZSwgc3RyaWN0KSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSAwOzspIHtcbiAgICAgICAgaWYgKG4gPj0gY29sKVxuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIGlmIChpID09IHN0cmluZy5sZW5ndGgpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbiArPSBzdHJpbmcuY2hhckNvZGVBdChpKSA9PSA5ID8gdGFiU2l6ZSAtIChuICUgdGFiU2l6ZSkgOiAxO1xuICAgICAgICBpID0gZmluZENsdXN0ZXJCcmVhayhzdHJpbmcsIGkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaWN0ID09PSB0cnVlID8gLTEgOiBzdHJpbmcubGVuZ3RoO1xufVxuXG5leHBvcnQgeyBBbm5vdGF0aW9uLCBBbm5vdGF0aW9uVHlwZSwgQ2hhbmdlRGVzYywgQ2hhbmdlU2V0LCBDaGFyQ2F0ZWdvcnksIENvbXBhcnRtZW50LCBFZGl0b3JTZWxlY3Rpb24sIEVkaXRvclN0YXRlLCBGYWNldCwgTGluZSwgTWFwTW9kZSwgUHJlYywgUmFuZ2UsIFJhbmdlU2V0LCBSYW5nZVNldEJ1aWxkZXIsIFJhbmdlVmFsdWUsIFNlbGVjdGlvblJhbmdlLCBTdGF0ZUVmZmVjdCwgU3RhdGVFZmZlY3RUeXBlLCBTdGF0ZUZpZWxkLCBUZXh0LCBUcmFuc2FjdGlvbiwgY29kZVBvaW50QXQsIGNvZGVQb2ludFNpemUsIGNvbWJpbmVDb25maWcsIGNvdW50Q29sdW1uLCBmaW5kQ2x1c3RlckJyZWFrLCBmaW5kQ29sdW1uLCBmcm9tQ29kZVBvaW50IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/@codemirror+state@6.5.2/node_modules/@codemirror/state/dist/index.js\n");

/***/ })

};
;